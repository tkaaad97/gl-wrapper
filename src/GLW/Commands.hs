{-# LANGUAGE CPP            #-}
{-# LANGUAGE DataKinds      #-}
{-# LANGUAGE KindSignatures #-}
module GLW.Commands
    ( glActiveShaderProgram
    , glActiveStencilFaceEXT
    , glActiveTexture
    , glActiveTextureARB
    , glActiveVaryingNV
    , glAlphaFragmentOp1ATI
    , glAlphaFragmentOp2ATI
    , glAlphaFragmentOp3ATI
    , glApplyTextureEXT
    , glAreProgramsResidentNV
    , glAreTexturesResidentEXT
    , glArrayElementEXT
    , glArrayObjectATI
    , glAsyncMarkerSGIX
    , glAttachObjectARB
    , glAttachShader
    , glBeginConditionalRender
    , glBeginConditionalRenderNVX
    , glBeginFragmentShaderATI
    , glBeginOcclusionQueryNV
    , glBeginQuery
    , glBeginQueryARB
    , glBeginQueryIndexed
    , glBeginTransformFeedback
    , glBeginTransformFeedbackEXT
    , glBeginTransformFeedbackNV
    , glBeginVertexShaderEXT
    , glBeginVideoCaptureNV
    , glBindAttribLocation
    , glBindAttribLocationARB
    , glBindBuffer
    , glBindBufferARB
    , glBindBufferBase
    , glBindBufferBaseEXT
    , glBindBufferBaseNV
    , glBindBufferOffsetEXT
    , glBindBufferOffsetNV
    , glBindBufferRange
    , glBindBufferRangeEXT
    , glBindBufferRangeNV
    , glBindBuffersBase
    , glBindBuffersRange
    , glBindFragDataLocation
    , glBindFragDataLocationEXT
    , glBindFragDataLocationIndexed
    , glBindFragmentShaderATI
    , glBindFramebuffer
    , glBindFramebufferEXT
    , glBindImageTexture
    , glBindImageTextureEXT
    , glBindImageTextures
    , glBindLightParameterEXT
    , glBindMaterialParameterEXT
    , glBindMultiTextureEXT
    , glBindParameterEXT
    , glBindProgramARB
    , glBindProgramNV
    , glBindProgramPipeline
    , glBindRenderbuffer
    , glBindRenderbufferEXT
    , glBindSampler
    , glBindSamplers
    , glBindTexGenParameterEXT
    , glBindTexture
    , glBindTextureEXT
    , glBindTextureUnit
    , glBindTextureUnitParameterEXT
    , glBindTextures
    , glBindTransformFeedback
    , glBindTransformFeedbackNV
    , glBindVertexArray
    , glBindVertexArrayAPPLE
    , glBindVertexBuffer
    , glBindVertexBuffers
    , glBindVertexShaderEXT
    , glBindVideoCaptureStreamBufferNV
    , glBindVideoCaptureStreamTextureNV
    , glBinormal3bEXT
    , glBinormal3bvEXT
    , glBinormal3dEXT
    , glBinormal3dvEXT
    , glBinormal3fEXT
    , glBinormal3fvEXT
    , glBinormal3iEXT
    , glBinormal3ivEXT
    , glBinormal3sEXT
    , glBinormal3svEXT
    , glBinormalPointerEXT
    , glBlendColor
    , glBlendColorEXT
    , glBlendEquation
    , glBlendEquationIndexedAMD
    , glBlendEquationSeparate
    , glBlendEquationSeparateEXT
    , glBlendEquationSeparateIndexedAMD
    , glBlendEquationSeparatei
    , glBlendEquationi
    , glBlendFunc
    , glBlendFuncIndexedAMD
    , glBlendFuncSeparate
    , glBlendFuncSeparateEXT
    , glBlendFuncSeparateINGR
    , glBlendFuncSeparateIndexedAMD
    , glBlendFuncSeparatei
    , glBlendFunci
    , glBlitFramebuffer
    , glBlitFramebufferEXT
    , glBlitNamedFramebuffer
    , glBufferAddressRangeNV
    , glBufferData
    , glBufferDataARB
    , glBufferParameteriAPPLE
    , glBufferStorage
    , glBufferSubData
    , glBufferSubDataARB
    , glCallCommandListNV
    , glCheckFramebufferStatus
    , glCheckFramebufferStatusEXT
    , glCheckNamedFramebufferStatus
    , glCheckNamedFramebufferStatusEXT
    , glClampColor
    , glClampColorARB
    , glClear
    , glClearBufferData
    , glClearBufferSubData
    , glClearBufferfi
    , glClearBufferfv
    , glClearBufferiv
    , glClearBufferuiv
    , glClearColor
    , glClearColorIiEXT
    , glClearColorIuiEXT
    , glClearDepth
    , glClearDepthdNV
    , glClearDepthf
    , glClearNamedBufferData
    , glClearNamedBufferDataEXT
    , glClearNamedBufferSubData
    , glClearNamedBufferSubDataEXT
    , glClearNamedFramebufferfi
    , glClearNamedFramebufferfv
    , glClearNamedFramebufferiv
    , glClearNamedFramebufferuiv
    , glClearStencil
    , glClearTexImage
    , glClearTexSubImage
    , glClientActiveTextureARB
    , glClientActiveVertexStreamATI
    , glClientAttribDefaultEXT
    , glClientWaitSync
    , glClipControl
    , glColor3fVertex3fSUN
    , glColor3fVertex3fvSUN
    , glColor3hNV
    , glColor3hvNV
    , glColor4fNormal3fVertex3fSUN
    , glColor4fNormal3fVertex3fvSUN
    , glColor4hNV
    , glColor4hvNV
    , glColor4ubVertex2fSUN
    , glColor4ubVertex2fvSUN
    , glColor4ubVertex3fSUN
    , glColor4ubVertex3fvSUN
    , glColorFormatNV
    , glColorFragmentOp1ATI
    , glColorFragmentOp2ATI
    , glColorFragmentOp3ATI
    , glColorMask
    , glColorMaskIndexedEXT
    , glColorMaski
    , glColorP3ui
    , glColorP3uiv
    , glColorP4ui
    , glColorP4uiv
    , glColorPointerEXT
    , glColorPointerListIBM
    , glColorPointervINTEL
    , glColorSubTableEXT
    , glColorTableEXT
    , glColorTableParameterfvSGI
    , glColorTableParameterivSGI
    , glColorTableSGI
    , glCombinerInputNV
    , glCombinerOutputNV
    , glCombinerParameterfNV
    , glCombinerParameterfvNV
    , glCombinerParameteriNV
    , glCombinerParameterivNV
    , glCombinerStageParameterfvNV
    , glCommandListSegmentsNV
    , glCompileCommandListNV
    , glCompileShader
    , glCompileShaderARB
    , glCompressedMultiTexImage1DEXT
    , glCompressedMultiTexImage2DEXT
    , glCompressedMultiTexImage3DEXT
    , glCompressedMultiTexSubImage1DEXT
    , glCompressedMultiTexSubImage2DEXT
    , glCompressedMultiTexSubImage3DEXT
    , glCompressedTexImage1D
    , glCompressedTexImage1DARB
    , glCompressedTexImage2D
    , glCompressedTexImage2DARB
    , glCompressedTexImage3D
    , glCompressedTexImage3DARB
    , glCompressedTexSubImage1D
    , glCompressedTexSubImage1DARB
    , glCompressedTexSubImage2D
    , glCompressedTexSubImage2DARB
    , glCompressedTexSubImage3D
    , glCompressedTexSubImage3DARB
    , glCompressedTextureImage1DEXT
    , glCompressedTextureImage2DEXT
    , glCompressedTextureImage3DEXT
    , glCompressedTextureSubImage1D
    , glCompressedTextureSubImage1DEXT
    , glCompressedTextureSubImage2D
    , glCompressedTextureSubImage2DEXT
    , glCompressedTextureSubImage3D
    , glCompressedTextureSubImage3DEXT
    , glConservativeRasterParameterfNV
    , glConvolutionFilter1DEXT
    , glConvolutionFilter2DEXT
    , glConvolutionParameterfEXT
    , glConvolutionParameterfvEXT
    , glConvolutionParameteriEXT
    , glConvolutionParameterivEXT
    , glCopyBufferSubData
    , glCopyColorSubTableEXT
    , glCopyColorTableSGI
    , glCopyConvolutionFilter1DEXT
    , glCopyConvolutionFilter2DEXT
    , glCopyImageSubData
    , glCopyImageSubDataNV
    , glCopyMultiTexImage1DEXT
    , glCopyMultiTexImage2DEXT
    , glCopyMultiTexSubImage1DEXT
    , glCopyMultiTexSubImage2DEXT
    , glCopyMultiTexSubImage3DEXT
    , glCopyNamedBufferSubData
    , glCopyTexImage1D
    , glCopyTexImage1DEXT
    , glCopyTexImage2D
    , glCopyTexImage2DEXT
    , glCopyTexSubImage1D
    , glCopyTexSubImage1DEXT
    , glCopyTexSubImage2D
    , glCopyTexSubImage2DEXT
    , glCopyTexSubImage3D
    , glCopyTexSubImage3DEXT
    , glCopyTextureImage1DEXT
    , glCopyTextureImage2DEXT
    , glCopyTextureSubImage1D
    , glCopyTextureSubImage1DEXT
    , glCopyTextureSubImage2D
    , glCopyTextureSubImage2DEXT
    , glCopyTextureSubImage3D
    , glCopyTextureSubImage3DEXT
    , glCreateBuffers
    , glCreateCommandListsNV
    , glCreateFramebuffers
    , glCreateProgram
    , glCreateProgramObjectARB
    , glCreateProgramPipelines
    , glCreateQueries
    , glCreateRenderbuffers
    , glCreateSamplers
    , glCreateShader
    , glCreateShaderObjectARB
    , glCreateShaderProgramv
    , glCreateStatesNV
    , glCreateTextures
    , glCreateTransformFeedbacks
    , glCreateVertexArrays
    , glCullFace
    , glCullParameterdvEXT
    , glCullParameterfvEXT
    , glCurrentPaletteMatrixARB
    , glDebugMessageCallback
    , glDebugMessageCallbackAMD
    , glDebugMessageControl
    , glDebugMessageEnableAMD
    , glDebugMessageInsert
    , glDebugMessageInsertAMD
    , glDeformSGIX
    , glDeformationMap3dSGIX
    , glDeformationMap3fSGIX
    , glDeleteAsyncMarkersSGIX
    , glDeleteBuffers
    , glDeleteBuffersARB
    , glDeleteCommandListsNV
    , glDeleteFencesAPPLE
    , glDeleteFragmentShaderATI
    , glDeleteFramebuffers
    , glDeleteFramebuffersEXT
    , glDeleteNamesAMD
    , glDeleteObjectARB
    , glDeleteOcclusionQueriesNV
    , glDeleteProgram
    , glDeleteProgramPipelines
    , glDeleteProgramsARB
    , glDeleteProgramsNV
    , glDeleteQueries
    , glDeleteQueriesARB
    , glDeleteRenderbuffers
    , glDeleteRenderbuffersEXT
    , glDeleteSamplers
    , glDeleteShader
    , glDeleteStatesNV
    , glDeleteSync
    , glDeleteTextures
    , glDeleteTexturesEXT
    , glDeleteTransformFeedbacks
    , glDeleteTransformFeedbacksNV
    , glDeleteVertexArrays
    , glDeleteVertexArraysAPPLE
    , glDeleteVertexShaderEXT
    , glDepthBoundsEXT
    , glDepthBoundsdNV
    , glDepthFunc
    , glDepthMask
    , glDepthRange
    , glDepthRangeArrayv
    , glDepthRangeIndexed
    , glDepthRangedNV
    , glDepthRangef
    , glDetachObjectARB
    , glDetachShader
    , glDetailTexFuncSGIS
    , glDisable
    , glDisableClientStateIndexedEXT
    , glDisableClientStateiEXT
    , glDisableIndexedEXT
    , glDisableVariantClientStateEXT
    , glDisableVertexArrayAttrib
    , glDisableVertexArrayAttribEXT
    , glDisableVertexArrayEXT
    , glDisableVertexAttribAPPLE
    , glDisableVertexAttribArray
    , glDisableVertexAttribArrayARB
    , glDisablei
    , glDispatchCompute
    , glDispatchComputeIndirect
    , glDrawArrays
    , glDrawArraysEXT
    , glDrawArraysIndirect
    , glDrawArraysInstanced
    , glDrawArraysInstancedARB
    , glDrawArraysInstancedBaseInstance
    , glDrawBuffer
    , glDrawBuffers
    , glDrawBuffersARB
    , glDrawBuffersATI
    , glDrawCommandsAddressNV
    , glDrawCommandsNV
    , glDrawCommandsStatesAddressNV
    , glDrawCommandsStatesNV
    , glDrawElementArrayAPPLE
    , glDrawElementArrayATI
    , glDrawElements
    , glDrawElementsBaseVertex
    , glDrawElementsIndirect
    , glDrawElementsInstanced
    , glDrawElementsInstancedARB
    , glDrawElementsInstancedBaseInstance
    , glDrawElementsInstancedBaseVertex
    , glDrawElementsInstancedBaseVertexBaseInstance
    , glDrawMeshArraysSUN
    , glDrawRangeElementArrayAPPLE
    , glDrawRangeElementArrayATI
    , glDrawRangeElements
    , glDrawRangeElementsBaseVertex
    , glDrawRangeElementsEXT
    , glDrawTextureNV
    , glDrawTransformFeedback
    , glDrawTransformFeedbackInstanced
    , glDrawTransformFeedbackNV
    , glDrawTransformFeedbackStream
    , glDrawTransformFeedbackStreamInstanced
    , glEdgeFlagFormatNV
    , glEdgeFlagPointerEXT
    , glEdgeFlagPointerListIBM
    , glElementPointerAPPLE
    , glElementPointerATI
    , glEnable
    , glEnableClientStateIndexedEXT
    , glEnableClientStateiEXT
    , glEnableIndexedEXT
    , glEnableVariantClientStateEXT
    , glEnableVertexArrayAttrib
    , glEnableVertexArrayAttribEXT
    , glEnableVertexArrayEXT
    , glEnableVertexAttribAPPLE
    , glEnableVertexAttribArray
    , glEnableVertexAttribArrayARB
    , glEnablei
    , glEndConditionalRender
    , glEndConditionalRenderNVX
    , glEndFragmentShaderATI
    , glEndOcclusionQueryNV
    , glEndQuery
    , glEndQueryARB
    , glEndQueryIndexed
    , glEndTransformFeedback
    , glEndTransformFeedbackEXT
    , glEndTransformFeedbackNV
    , glEndVertexShaderEXT
    , glEndVideoCaptureNV
    , glEvalMapsNV
    , glEvaluateDepthValuesARB
    , glExecuteProgramNV
    , glExtractComponentEXT
    , glFenceSync
    , glFinalCombinerInputNV
    , glFinish
    , glFinishAsyncSGIX
    , glFinishFenceAPPLE
    , glFinishObjectAPPLE
    , glFinishTextureSUNX
    , glFlush
    , glFlushMappedBufferRange
    , glFlushMappedBufferRangeAPPLE
    , glFlushMappedNamedBufferRange
    , glFlushMappedNamedBufferRangeEXT
    , glFlushPixelDataRangeNV
    , glFlushRasterSGIX
    , glFlushStaticDataIBM
    , glFlushVertexArrayRangeAPPLE
    , glFlushVertexArrayRangeNV
    , glFogCoordFormatNV
    , glFogCoordPointerEXT
    , glFogCoordPointerListIBM
    , glFogCoorddEXT
    , glFogCoorddvEXT
    , glFogCoordfEXT
    , glFogCoordfvEXT
    , glFogCoordhNV
    , glFogCoordhvNV
    , glFogFuncSGIS
    , glFragmentColorMaterialSGIX
    , glFragmentLightModelfSGIX
    , glFragmentLightModelfvSGIX
    , glFragmentLightModeliSGIX
    , glFragmentLightModelivSGIX
    , glFragmentLightfSGIX
    , glFragmentLightfvSGIX
    , glFragmentLightiSGIX
    , glFragmentLightivSGIX
    , glFragmentMaterialfSGIX
    , glFragmentMaterialfvSGIX
    , glFragmentMaterialiSGIX
    , glFragmentMaterialivSGIX
    , glFrameTerminatorGREMEDY
    , glFrameZoomSGIX
    , glFramebufferDrawBufferEXT
    , glFramebufferDrawBuffersEXT
    , glFramebufferParameteri
    , glFramebufferReadBufferEXT
    , glFramebufferRenderbuffer
    , glFramebufferRenderbufferEXT
    , glFramebufferSampleLocationsfvARB
    , glFramebufferTexture
    , glFramebufferTexture1D
    , glFramebufferTexture1DEXT
    , glFramebufferTexture2D
    , glFramebufferTexture2DEXT
    , glFramebufferTexture3D
    , glFramebufferTexture3DEXT
    , glFramebufferTextureARB
    , glFramebufferTextureEXT
    , glFramebufferTextureFaceARB
    , glFramebufferTextureFaceEXT
    , glFramebufferTextureLayer
    , glFramebufferTextureLayerARB
    , glFramebufferTextureLayerEXT
    , glFreeObjectBufferATI
    , glFrontFace
    , glGenAsyncMarkersSGIX
    , glGenBuffers
    , glGenBuffersARB
    , glGenFencesAPPLE
    , glGenFragmentShadersATI
    , glGenFramebuffers
    , glGenFramebuffersEXT
    , glGenNamesAMD
    , glGenOcclusionQueriesNV
    , glGenProgramPipelines
    , glGenProgramsARB
    , glGenProgramsNV
    , glGenQueries
    , glGenQueriesARB
    , glGenRenderbuffers
    , glGenRenderbuffersEXT
    , glGenSamplers
    , glGenSymbolsEXT
    , glGenTextures
    , glGenTexturesEXT
    , glGenTransformFeedbacks
    , glGenTransformFeedbacksNV
    , glGenVertexArrays
    , glGenVertexArraysAPPLE
    , glGenVertexShadersEXT
    , glGenerateMipmap
    , glGenerateMipmapEXT
    , glGenerateMultiTexMipmapEXT
    , glGenerateTextureMipmap
    , glGenerateTextureMipmapEXT
    , glGetActiveAtomicCounterBufferiv
    , glGetActiveAttrib
    , glGetActiveAttribARB
    , glGetActiveSubroutineName
    , glGetActiveSubroutineUniformName
    , glGetActiveSubroutineUniformiv
    , glGetActiveUniform
    , glGetActiveUniformARB
    , glGetActiveUniformBlockName
    , glGetActiveUniformBlockiv
    , glGetActiveUniformName
    , glGetActiveUniformsiv
    , glGetActiveVaryingNV
    , glGetArrayObjectfvATI
    , glGetArrayObjectivATI
    , glGetAttachedObjectsARB
    , glGetAttachedShaders
    , glGetAttribLocation
    , glGetAttribLocationARB
    , glGetBooleanIndexedvEXT
    , glGetBooleani_v
    , glGetBooleanv
    , glGetBufferParameteri64v
    , glGetBufferParameteriv
    , glGetBufferParameterivARB
    , glGetBufferParameterui64vNV
    , glGetBufferPointerv
    , glGetBufferPointervARB
    , glGetBufferSubData
    , glGetBufferSubDataARB
    , glGetColorTableEXT
    , glGetColorTableParameterfvEXT
    , glGetColorTableParameterfvSGI
    , glGetColorTableParameterivEXT
    , glGetColorTableParameterivSGI
    , glGetColorTableSGI
    , glGetCombinerInputParameterfvNV
    , glGetCombinerInputParameterivNV
    , glGetCombinerOutputParameterfvNV
    , glGetCombinerOutputParameterivNV
    , glGetCombinerStageParameterfvNV
    , glGetCommandHeaderNV
    , glGetCompressedMultiTexImageEXT
    , glGetCompressedTexImage
    , glGetCompressedTexImageARB
    , glGetCompressedTextureImage
    , glGetCompressedTextureImageEXT
    , glGetCompressedTextureSubImage
    , glGetConvolutionFilterEXT
    , glGetConvolutionParameterfvEXT
    , glGetConvolutionParameterivEXT
    , glGetDebugMessageLog
    , glGetDebugMessageLogAMD
    , glGetDetailTexFuncSGIS
    , glGetDoubleIndexedvEXT
    , glGetDoublei_v
    , glGetDoublei_vEXT
    , glGetDoublev
    , glGetError
    , glGetFinalCombinerInputParameterfvNV
    , glGetFinalCombinerInputParameterivNV
    , glGetFloatIndexedvEXT
    , glGetFloati_v
    , glGetFloati_vEXT
    , glGetFloatv
    , glGetFogFuncSGIS
    , glGetFragDataIndex
    , glGetFragDataLocation
    , glGetFragDataLocationEXT
    , glGetFragmentLightfvSGIX
    , glGetFragmentLightivSGIX
    , glGetFragmentMaterialfvSGIX
    , glGetFragmentMaterialivSGIX
    , glGetFramebufferAttachmentParameteriv
    , glGetFramebufferAttachmentParameterivEXT
    , glGetFramebufferParameteriv
    , glGetFramebufferParameterivEXT
    , glGetGraphicsResetStatus
    , glGetHandleARB
    , glGetHistogramEXT
    , glGetHistogramParameterfvEXT
    , glGetHistogramParameterivEXT
    , glGetImageTransformParameterfvHP
    , glGetImageTransformParameterivHP
    , glGetInfoLogARB
    , glGetInstrumentsSGIX
    , glGetInteger64i_v
    , glGetInteger64v
    , glGetIntegerIndexedvEXT
    , glGetIntegeri_v
    , glGetIntegerui64i_vNV
    , glGetIntegerui64vNV
    , glGetIntegerv
    , glGetInternalformati64v
    , glGetInternalformativ
    , glGetInvariantBooleanvEXT
    , glGetInvariantFloatvEXT
    , glGetInvariantIntegervEXT
    , glGetListParameterfvSGIX
    , glGetListParameterivSGIX
    , glGetLocalConstantBooleanvEXT
    , glGetLocalConstantFloatvEXT
    , glGetLocalConstantIntegervEXT
    , glGetMapAttribParameterfvNV
    , glGetMapAttribParameterivNV
    , glGetMapControlPointsNV
    , glGetMapParameterfvNV
    , glGetMapParameterivNV
    , glGetMinmaxEXT
    , glGetMinmaxParameterfvEXT
    , glGetMinmaxParameterivEXT
    , glGetMultiTexEnvfvEXT
    , glGetMultiTexEnvivEXT
    , glGetMultiTexGendvEXT
    , glGetMultiTexGenfvEXT
    , glGetMultiTexGenivEXT
    , glGetMultiTexImageEXT
    , glGetMultiTexLevelParameterfvEXT
    , glGetMultiTexLevelParameterivEXT
    , glGetMultiTexParameterIivEXT
    , glGetMultiTexParameterIuivEXT
    , glGetMultiTexParameterfvEXT
    , glGetMultiTexParameterivEXT
    , glGetMultisamplefv
    , glGetMultisamplefvNV
    , glGetNamedBufferParameteri64v
    , glGetNamedBufferParameteriv
    , glGetNamedBufferParameterivEXT
    , glGetNamedBufferParameterui64vNV
    , glGetNamedBufferPointerv
    , glGetNamedBufferPointervEXT
    , glGetNamedBufferSubData
    , glGetNamedBufferSubDataEXT
    , glGetNamedFramebufferAttachmentParameteriv
    , glGetNamedFramebufferAttachmentParameterivEXT
    , glGetNamedFramebufferParameteriv
    , glGetNamedFramebufferParameterivEXT
    , glGetNamedProgramLocalParameterIivEXT
    , glGetNamedProgramLocalParameterIuivEXT
    , glGetNamedProgramLocalParameterdvEXT
    , glGetNamedProgramLocalParameterfvEXT
    , glGetNamedProgramStringEXT
    , glGetNamedProgramivEXT
    , glGetNamedRenderbufferParameteriv
    , glGetNamedRenderbufferParameterivEXT
    , glGetObjectBufferfvATI
    , glGetObjectBufferivATI
    , glGetObjectLabel
    , glGetObjectParameterfvARB
    , glGetObjectParameterivAPPLE
    , glGetObjectParameterivARB
    , glGetObjectPtrLabel
    , glGetOcclusionQueryivNV
    , glGetOcclusionQueryuivNV
    , glGetPixelTexGenParameterfvSGIS
    , glGetPixelTexGenParameterivSGIS
    , glGetPixelTransformParameterfvEXT
    , glGetPixelTransformParameterivEXT
    , glGetPointerIndexedvEXT
    , glGetPointeri_vEXT
    , glGetPointervEXT
    , glGetProgramBinary
    , glGetProgramEnvParameterIivNV
    , glGetProgramEnvParameterIuivNV
    , glGetProgramEnvParameterdvARB
    , glGetProgramEnvParameterfvARB
    , glGetProgramInfoLog
    , glGetProgramInterfaceiv
    , glGetProgramLocalParameterIivNV
    , glGetProgramLocalParameterIuivNV
    , glGetProgramLocalParameterdvARB
    , glGetProgramLocalParameterfvARB
    , glGetProgramNamedParameterdvNV
    , glGetProgramNamedParameterfvNV
    , glGetProgramParameterdvNV
    , glGetProgramParameterfvNV
    , glGetProgramPipelineInfoLog
    , glGetProgramPipelineiv
    , glGetProgramResourceIndex
    , glGetProgramResourceLocation
    , glGetProgramResourceLocationIndex
    , glGetProgramResourceName
    , glGetProgramResourceiv
    , glGetProgramStageiv
    , glGetProgramStringARB
    , glGetProgramStringNV
    , glGetProgramSubroutineParameteruivNV
    , glGetProgramiv
    , glGetProgramivARB
    , glGetProgramivNV
    , glGetQueryBufferObjecti64v
    , glGetQueryBufferObjectiv
    , glGetQueryBufferObjectui64v
    , glGetQueryBufferObjectuiv
    , glGetQueryIndexediv
    , glGetQueryObjecti64v
    , glGetQueryObjecti64vEXT
    , glGetQueryObjectiv
    , glGetQueryObjectivARB
    , glGetQueryObjectui64v
    , glGetQueryObjectui64vEXT
    , glGetQueryObjectuiv
    , glGetQueryObjectuivARB
    , glGetQueryiv
    , glGetQueryivARB
    , glGetRenderbufferParameteriv
    , glGetRenderbufferParameterivEXT
    , glGetSamplerParameterIiv
    , glGetSamplerParameterIuiv
    , glGetSamplerParameterfv
    , glGetSamplerParameteriv
    , glGetSeparableFilterEXT
    , glGetShaderInfoLog
    , glGetShaderPrecisionFormat
    , glGetShaderSource
    , glGetShaderSourceARB
    , glGetShaderiv
    , glGetSharpenTexFuncSGIS
    , glGetStageIndexNV
    , glGetString
    , glGetStringi
    , glGetSubroutineIndex
    , glGetSubroutineUniformLocation
    , glGetSynciv
    , glGetTexBumpParameterfvATI
    , glGetTexBumpParameterivATI
    , glGetTexFilterFuncSGIS
    , glGetTexImage
    , glGetTexLevelParameterfv
    , glGetTexLevelParameteriv
    , glGetTexParameterIiv
    , glGetTexParameterIivEXT
    , glGetTexParameterIuiv
    , glGetTexParameterIuivEXT
    , glGetTexParameterPointervAPPLE
    , glGetTexParameterfv
    , glGetTexParameteriv
    , glGetTextureImage
    , glGetTextureImageEXT
    , glGetTextureLevelParameterfv
    , glGetTextureLevelParameterfvEXT
    , glGetTextureLevelParameteriv
    , glGetTextureLevelParameterivEXT
    , glGetTextureParameterIiv
    , glGetTextureParameterIivEXT
    , glGetTextureParameterIuiv
    , glGetTextureParameterIuivEXT
    , glGetTextureParameterfv
    , glGetTextureParameterfvEXT
    , glGetTextureParameteriv
    , glGetTextureParameterivEXT
    , glGetTextureSubImage
    , glGetTrackMatrixivNV
    , glGetTransformFeedbackVarying
    , glGetTransformFeedbackVaryingEXT
    , glGetTransformFeedbackVaryingNV
    , glGetTransformFeedbacki64_v
    , glGetTransformFeedbacki_v
    , glGetTransformFeedbackiv
    , glGetUniformBlockIndex
    , glGetUniformBufferSizeEXT
    , glGetUniformIndices
    , glGetUniformLocation
    , glGetUniformLocationARB
    , glGetUniformOffsetEXT
    , glGetUniformSubroutineuiv
    , glGetUniformdv
    , glGetUniformfv
    , glGetUniformfvARB
    , glGetUniformi64vARB
    , glGetUniformi64vNV
    , glGetUniformiv
    , glGetUniformivARB
    , glGetUniformui64vARB
    , glGetUniformui64vNV
    , glGetUniformuiv
    , glGetUniformuivEXT
    , glGetVariantArrayObjectfvATI
    , glGetVariantArrayObjectivATI
    , glGetVariantBooleanvEXT
    , glGetVariantFloatvEXT
    , glGetVariantIntegervEXT
    , glGetVariantPointervEXT
    , glGetVaryingLocationNV
    , glGetVertexArrayIndexed64iv
    , glGetVertexArrayIndexediv
    , glGetVertexArrayIntegeri_vEXT
    , glGetVertexArrayIntegervEXT
    , glGetVertexArrayPointeri_vEXT
    , glGetVertexArrayPointervEXT
    , glGetVertexArrayiv
    , glGetVertexAttribArrayObjectfvATI
    , glGetVertexAttribArrayObjectivATI
    , glGetVertexAttribIiv
    , glGetVertexAttribIivEXT
    , glGetVertexAttribIuiv
    , glGetVertexAttribIuivEXT
    , glGetVertexAttribLdv
    , glGetVertexAttribLdvEXT
    , glGetVertexAttribLi64vNV
    , glGetVertexAttribLui64vNV
    , glGetVertexAttribPointerv
    , glGetVertexAttribPointervARB
    , glGetVertexAttribPointervNV
    , glGetVertexAttribdv
    , glGetVertexAttribdvARB
    , glGetVertexAttribdvNV
    , glGetVertexAttribfv
    , glGetVertexAttribfvARB
    , glGetVertexAttribfvNV
    , glGetVertexAttribiv
    , glGetVertexAttribivARB
    , glGetVertexAttribivNV
    , glGetVideoCaptureStreamdvNV
    , glGetVideoCaptureStreamfvNV
    , glGetVideoCaptureStreamivNV
    , glGetVideoCaptureivNV
    , glGetVideoi64vNV
    , glGetVideoivNV
    , glGetVideoui64vNV
    , glGetVideouivNV
    , glGetnColorTable
    , glGetnCompressedTexImage
    , glGetnConvolutionFilter
    , glGetnHistogram
    , glGetnMapdv
    , glGetnMapfv
    , glGetnMapiv
    , glGetnMinmax
    , glGetnPixelMapfv
    , glGetnPixelMapuiv
    , glGetnPixelMapusv
    , glGetnPolygonStipple
    , glGetnSeparableFilter
    , glGetnTexImage
    , glGetnUniformdv
    , glGetnUniformfv
    , glGetnUniformi64vARB
    , glGetnUniformiv
    , glGetnUniformui64vARB
    , glGetnUniformuiv
    , glGlobalAlphaFactorbSUN
    , glGlobalAlphaFactordSUN
    , glGlobalAlphaFactorfSUN
    , glGlobalAlphaFactoriSUN
    , glGlobalAlphaFactorsSUN
    , glGlobalAlphaFactorubSUN
    , glGlobalAlphaFactoruiSUN
    , glGlobalAlphaFactorusSUN
    , glHint
    , glHintPGI
    , glHistogramEXT
    , glIglooInterfaceSGIX
    , glImageTransformParameterfHP
    , glImageTransformParameterfvHP
    , glImageTransformParameteriHP
    , glImageTransformParameterivHP
    , glImportSyncEXT
    , glIndexFormatNV
    , glIndexFuncEXT
    , glIndexMaterialEXT
    , glIndexPointerEXT
    , glIndexPointerListIBM
    , glInsertComponentEXT
    , glInstrumentsBufferSGIX
    , glInvalidateBufferData
    , glInvalidateBufferSubData
    , glInvalidateFramebuffer
    , glInvalidateNamedFramebufferData
    , glInvalidateNamedFramebufferSubData
    , glInvalidateSubFramebuffer
    , glInvalidateTexImage
    , glInvalidateTexSubImage
    , glIsAsyncMarkerSGIX
    , glIsBuffer
    , glIsBufferARB
    , glIsBufferResidentNV
    , glIsCommandListNV
    , glIsEnabled
    , glIsEnabledIndexedEXT
    , glIsEnabledi
    , glIsFenceAPPLE
    , glIsFramebuffer
    , glIsFramebufferEXT
    , glIsNameAMD
    , glIsNamedBufferResidentNV
    , glIsObjectBufferATI
    , glIsOcclusionQueryNV
    , glIsProgram
    , glIsProgramARB
    , glIsProgramNV
    , glIsProgramPipeline
    , glIsQuery
    , glIsQueryARB
    , glIsRenderbuffer
    , glIsRenderbufferEXT
    , glIsSampler
    , glIsShader
    , glIsStateNV
    , glIsSync
    , glIsTexture
    , glIsTextureEXT
    , glIsTransformFeedback
    , glIsTransformFeedbackNV
    , glIsVariantEnabledEXT
    , glIsVertexArray
    , glIsVertexArrayAPPLE
    , glIsVertexAttribEnabledAPPLE
    , glLightEnviSGIX
    , glLineWidth
    , glLinkProgram
    , glLinkProgramARB
    , glListDrawCommandsStatesClientNV
    , glListParameterfSGIX
    , glListParameterfvSGIX
    , glListParameteriSGIX
    , glListParameterivSGIX
    , glLoadIdentityDeformationMapSGIX
    , glLoadProgramNV
    , glLoadTransposeMatrixdARB
    , glLoadTransposeMatrixfARB
    , glLockArraysEXT
    , glLogicOp
    , glMakeBufferNonResidentNV
    , glMakeBufferResidentNV
    , glMakeNamedBufferNonResidentNV
    , glMakeNamedBufferResidentNV
    , glMapBuffer
    , glMapBufferARB
    , glMapBufferRange
    , glMapControlPointsNV
    , glMapNamedBuffer
    , glMapNamedBufferEXT
    , glMapNamedBufferRange
    , glMapNamedBufferRangeEXT
    , glMapObjectBufferATI
    , glMapParameterfvNV
    , glMapParameterivNV
    , glMapTexture2DINTEL
    , glMapVertexAttrib1dAPPLE
    , glMapVertexAttrib1fAPPLE
    , glMapVertexAttrib2dAPPLE
    , glMapVertexAttrib2fAPPLE
    , glMatrixFrustumEXT
    , glMatrixIndexPointerARB
    , glMatrixIndexubvARB
    , glMatrixIndexuivARB
    , glMatrixIndexusvARB
    , glMatrixLoadIdentityEXT
    , glMatrixLoadTransposedEXT
    , glMatrixLoadTransposefEXT
    , glMatrixLoaddEXT
    , glMatrixLoadfEXT
    , glMatrixMultTransposedEXT
    , glMatrixMultTransposefEXT
    , glMatrixMultdEXT
    , glMatrixMultfEXT
    , glMatrixOrthoEXT
    , glMatrixPopEXT
    , glMatrixPushEXT
    , glMatrixRotatedEXT
    , glMatrixRotatefEXT
    , glMatrixScaledEXT
    , glMatrixScalefEXT
    , glMatrixTranslatedEXT
    , glMatrixTranslatefEXT
    , glMaxShaderCompilerThreadsARB
    , glMemoryBarrier
    , glMemoryBarrierByRegion
    , glMemoryBarrierEXT
    , glMinSampleShading
    , glMinmaxEXT
    , glMultTransposeMatrixdARB
    , glMultTransposeMatrixfARB
    , glMultiDrawArrays
    , glMultiDrawArraysIndirect
    , glMultiDrawArraysIndirectAMD
    , glMultiDrawArraysIndirectBindlessCountNV
    , glMultiDrawArraysIndirectBindlessNV
    , glMultiDrawElementArrayAPPLE
    , glMultiDrawElements
    , glMultiDrawElementsBaseVertex
    , glMultiDrawElementsIndirect
    , glMultiDrawElementsIndirectAMD
    , glMultiDrawElementsIndirectBindlessCountNV
    , glMultiDrawElementsIndirectBindlessNV
    , glMultiDrawRangeElementArrayAPPLE
    , glMultiModeDrawArraysIBM
    , glMultiModeDrawElementsIBM
    , glMultiTexBufferEXT
    , glMultiTexCoord1dARB
    , glMultiTexCoord1dvARB
    , glMultiTexCoord1fARB
    , glMultiTexCoord1fvARB
    , glMultiTexCoord1hNV
    , glMultiTexCoord1hvNV
    , glMultiTexCoord1iARB
    , glMultiTexCoord1ivARB
    , glMultiTexCoord1sARB
    , glMultiTexCoord1svARB
    , glMultiTexCoord2dARB
    , glMultiTexCoord2dvARB
    , glMultiTexCoord2fARB
    , glMultiTexCoord2fvARB
    , glMultiTexCoord2hNV
    , glMultiTexCoord2hvNV
    , glMultiTexCoord2iARB
    , glMultiTexCoord2ivARB
    , glMultiTexCoord2sARB
    , glMultiTexCoord2svARB
    , glMultiTexCoord3dARB
    , glMultiTexCoord3dvARB
    , glMultiTexCoord3fARB
    , glMultiTexCoord3fvARB
    , glMultiTexCoord3hNV
    , glMultiTexCoord3hvNV
    , glMultiTexCoord3iARB
    , glMultiTexCoord3ivARB
    , glMultiTexCoord3sARB
    , glMultiTexCoord3svARB
    , glMultiTexCoord4dARB
    , glMultiTexCoord4dvARB
    , glMultiTexCoord4fARB
    , glMultiTexCoord4fvARB
    , glMultiTexCoord4hNV
    , glMultiTexCoord4hvNV
    , glMultiTexCoord4iARB
    , glMultiTexCoord4ivARB
    , glMultiTexCoord4sARB
    , glMultiTexCoord4svARB
    , glMultiTexCoordP1ui
    , glMultiTexCoordP1uiv
    , glMultiTexCoordP2ui
    , glMultiTexCoordP2uiv
    , glMultiTexCoordP3ui
    , glMultiTexCoordP3uiv
    , glMultiTexCoordP4ui
    , glMultiTexCoordP4uiv
    , glMultiTexCoordPointerEXT
    , glMultiTexEnvfEXT
    , glMultiTexEnvfvEXT
    , glMultiTexEnviEXT
    , glMultiTexEnvivEXT
    , glMultiTexGendEXT
    , glMultiTexGendvEXT
    , glMultiTexGenfEXT
    , glMultiTexGenfvEXT
    , glMultiTexGeniEXT
    , glMultiTexGenivEXT
    , glMultiTexImage1DEXT
    , glMultiTexImage2DEXT
    , glMultiTexImage3DEXT
    , glMultiTexParameterIivEXT
    , glMultiTexParameterIuivEXT
    , glMultiTexParameterfEXT
    , glMultiTexParameterfvEXT
    , glMultiTexParameteriEXT
    , glMultiTexParameterivEXT
    , glMultiTexRenderbufferEXT
    , glMultiTexSubImage1DEXT
    , glMultiTexSubImage2DEXT
    , glMultiTexSubImage3DEXT
    , glNamedBufferData
    , glNamedBufferDataEXT
    , glNamedBufferStorage
    , glNamedBufferStorageEXT
    , glNamedBufferSubData
    , glNamedBufferSubDataEXT
    , glNamedCopyBufferSubDataEXT
    , glNamedFramebufferDrawBuffer
    , glNamedFramebufferDrawBuffers
    , glNamedFramebufferParameteri
    , glNamedFramebufferParameteriEXT
    , glNamedFramebufferReadBuffer
    , glNamedFramebufferRenderbuffer
    , glNamedFramebufferRenderbufferEXT
    , glNamedFramebufferSampleLocationsfvARB
    , glNamedFramebufferTexture
    , glNamedFramebufferTexture1DEXT
    , glNamedFramebufferTexture2DEXT
    , glNamedFramebufferTexture3DEXT
    , glNamedFramebufferTextureEXT
    , glNamedFramebufferTextureFaceEXT
    , glNamedFramebufferTextureLayer
    , glNamedFramebufferTextureLayerEXT
    , glNamedProgramLocalParameter4dEXT
    , glNamedProgramLocalParameter4dvEXT
    , glNamedProgramLocalParameter4fEXT
    , glNamedProgramLocalParameter4fvEXT
    , glNamedProgramLocalParameterI4iEXT
    , glNamedProgramLocalParameterI4ivEXT
    , glNamedProgramLocalParameterI4uiEXT
    , glNamedProgramLocalParameterI4uivEXT
    , glNamedProgramLocalParameters4fvEXT
    , glNamedProgramLocalParametersI4ivEXT
    , glNamedProgramLocalParametersI4uivEXT
    , glNamedProgramStringEXT
    , glNamedRenderbufferStorage
    , glNamedRenderbufferStorageEXT
    , glNamedRenderbufferStorageMultisample
    , glNamedRenderbufferStorageMultisampleCoverageEXT
    , glNamedRenderbufferStorageMultisampleEXT
    , glNewObjectBufferATI
    , glNormal3fVertex3fSUN
    , glNormal3fVertex3fvSUN
    , glNormal3hNV
    , glNormal3hvNV
    , glNormalFormatNV
    , glNormalP3ui
    , glNormalP3uiv
    , glNormalPointerEXT
    , glNormalPointerListIBM
    , glNormalPointervINTEL
    , glNormalStream3bATI
    , glNormalStream3bvATI
    , glNormalStream3dATI
    , glNormalStream3dvATI
    , glNormalStream3fATI
    , glNormalStream3fvATI
    , glNormalStream3iATI
    , glNormalStream3ivATI
    , glNormalStream3sATI
    , glNormalStream3svATI
    , glObjectLabel
    , glObjectPtrLabel
    , glObjectPurgeableAPPLE
    , glObjectUnpurgeableAPPLE
    , glPNTrianglesfATI
    , glPNTrianglesiATI
    , glPassTexCoordATI
    , glPatchParameterfv
    , glPatchParameteri
    , glPauseTransformFeedback
    , glPauseTransformFeedbackNV
    , glPixelDataRangeNV
    , glPixelStoref
    , glPixelStorei
    , glPixelTexGenParameterfSGIS
    , glPixelTexGenParameterfvSGIS
    , glPixelTexGenParameteriSGIS
    , glPixelTexGenParameterivSGIS
    , glPixelTexGenSGIX
    , glPixelTransformParameterfEXT
    , glPixelTransformParameterfvEXT
    , glPixelTransformParameteriEXT
    , glPixelTransformParameterivEXT
    , glPointParameterf
    , glPointParameterfARB
    , glPointParameterfEXT
    , glPointParameterfSGIS
    , glPointParameterfv
    , glPointParameterfvARB
    , glPointParameterfvEXT
    , glPointParameterfvSGIS
    , glPointParameteri
    , glPointParameteriNV
    , glPointParameteriv
    , glPointParameterivNV
    , glPointSize
    , glPollAsyncSGIX
    , glPollInstrumentsSGIX
    , glPolygonMode
    , glPolygonOffset
    , glPolygonOffsetEXT
    , glPopDebugGroup
    , glPresentFrameDualFillNV
    , glPresentFrameKeyedNV
    , glPrimitiveBoundingBoxARB
    , glPrimitiveRestartIndex
    , glPrimitiveRestartIndexNV
    , glPrimitiveRestartNV
    , glPrioritizeTexturesEXT
    , glProgramBinary
    , glProgramBufferParametersIivNV
    , glProgramBufferParametersIuivNV
    , glProgramBufferParametersfvNV
    , glProgramEnvParameter4dARB
    , glProgramEnvParameter4dvARB
    , glProgramEnvParameter4fARB
    , glProgramEnvParameter4fvARB
    , glProgramEnvParameterI4iNV
    , glProgramEnvParameterI4ivNV
    , glProgramEnvParameterI4uiNV
    , glProgramEnvParameterI4uivNV
    , glProgramEnvParameters4fvEXT
    , glProgramEnvParametersI4ivNV
    , glProgramEnvParametersI4uivNV
    , glProgramLocalParameter4dARB
    , glProgramLocalParameter4dvARB
    , glProgramLocalParameter4fARB
    , glProgramLocalParameter4fvARB
    , glProgramLocalParameterI4iNV
    , glProgramLocalParameterI4ivNV
    , glProgramLocalParameterI4uiNV
    , glProgramLocalParameterI4uivNV
    , glProgramLocalParameters4fvEXT
    , glProgramLocalParametersI4ivNV
    , glProgramLocalParametersI4uivNV
    , glProgramNamedParameter4dNV
    , glProgramNamedParameter4dvNV
    , glProgramNamedParameter4fNV
    , glProgramNamedParameter4fvNV
    , glProgramParameter4dNV
    , glProgramParameter4dvNV
    , glProgramParameter4fNV
    , glProgramParameter4fvNV
    , glProgramParameteri
    , glProgramParameteriARB
    , glProgramParameteriEXT
    , glProgramParameters4dvNV
    , glProgramParameters4fvNV
    , glProgramStringARB
    , glProgramSubroutineParametersuivNV
    , glProgramUniform1d
    , glProgramUniform1dEXT
    , glProgramUniform1dv
    , glProgramUniform1dvEXT
    , glProgramUniform1f
    , glProgramUniform1fEXT
    , glProgramUniform1fv
    , glProgramUniform1fvEXT
    , glProgramUniform1i
    , glProgramUniform1i64ARB
    , glProgramUniform1i64NV
    , glProgramUniform1i64vARB
    , glProgramUniform1i64vNV
    , glProgramUniform1iEXT
    , glProgramUniform1iv
    , glProgramUniform1ivEXT
    , glProgramUniform1ui
    , glProgramUniform1ui64ARB
    , glProgramUniform1ui64NV
    , glProgramUniform1ui64vARB
    , glProgramUniform1ui64vNV
    , glProgramUniform1uiEXT
    , glProgramUniform1uiv
    , glProgramUniform1uivEXT
    , glProgramUniform2d
    , glProgramUniform2dEXT
    , glProgramUniform2dv
    , glProgramUniform2dvEXT
    , glProgramUniform2f
    , glProgramUniform2fEXT
    , glProgramUniform2fv
    , glProgramUniform2fvEXT
    , glProgramUniform2i
    , glProgramUniform2i64ARB
    , glProgramUniform2i64NV
    , glProgramUniform2i64vARB
    , glProgramUniform2i64vNV
    , glProgramUniform2iEXT
    , glProgramUniform2iv
    , glProgramUniform2ivEXT
    , glProgramUniform2ui
    , glProgramUniform2ui64ARB
    , glProgramUniform2ui64NV
    , glProgramUniform2ui64vARB
    , glProgramUniform2ui64vNV
    , glProgramUniform2uiEXT
    , glProgramUniform2uiv
    , glProgramUniform2uivEXT
    , glProgramUniform3d
    , glProgramUniform3dEXT
    , glProgramUniform3dv
    , glProgramUniform3dvEXT
    , glProgramUniform3f
    , glProgramUniform3fEXT
    , glProgramUniform3fv
    , glProgramUniform3fvEXT
    , glProgramUniform3i
    , glProgramUniform3i64ARB
    , glProgramUniform3i64NV
    , glProgramUniform3i64vARB
    , glProgramUniform3i64vNV
    , glProgramUniform3iEXT
    , glProgramUniform3iv
    , glProgramUniform3ivEXT
    , glProgramUniform3ui
    , glProgramUniform3ui64ARB
    , glProgramUniform3ui64NV
    , glProgramUniform3ui64vARB
    , glProgramUniform3ui64vNV
    , glProgramUniform3uiEXT
    , glProgramUniform3uiv
    , glProgramUniform3uivEXT
    , glProgramUniform4d
    , glProgramUniform4dEXT
    , glProgramUniform4dv
    , glProgramUniform4dvEXT
    , glProgramUniform4f
    , glProgramUniform4fEXT
    , glProgramUniform4fv
    , glProgramUniform4fvEXT
    , glProgramUniform4i
    , glProgramUniform4i64ARB
    , glProgramUniform4i64NV
    , glProgramUniform4i64vARB
    , glProgramUniform4i64vNV
    , glProgramUniform4iEXT
    , glProgramUniform4iv
    , glProgramUniform4ivEXT
    , glProgramUniform4ui
    , glProgramUniform4ui64ARB
    , glProgramUniform4ui64NV
    , glProgramUniform4ui64vARB
    , glProgramUniform4ui64vNV
    , glProgramUniform4uiEXT
    , glProgramUniform4uiv
    , glProgramUniform4uivEXT
    , glProgramUniformMatrix2dv
    , glProgramUniformMatrix2dvEXT
    , glProgramUniformMatrix2fv
    , glProgramUniformMatrix2fvEXT
    , glProgramUniformMatrix2x3dv
    , glProgramUniformMatrix2x3dvEXT
    , glProgramUniformMatrix2x3fv
    , glProgramUniformMatrix2x3fvEXT
    , glProgramUniformMatrix2x4dv
    , glProgramUniformMatrix2x4dvEXT
    , glProgramUniformMatrix2x4fv
    , glProgramUniformMatrix2x4fvEXT
    , glProgramUniformMatrix3dv
    , glProgramUniformMatrix3dvEXT
    , glProgramUniformMatrix3fv
    , glProgramUniformMatrix3fvEXT
    , glProgramUniformMatrix3x2dv
    , glProgramUniformMatrix3x2dvEXT
    , glProgramUniformMatrix3x2fv
    , glProgramUniformMatrix3x2fvEXT
    , glProgramUniformMatrix3x4dv
    , glProgramUniformMatrix3x4dvEXT
    , glProgramUniformMatrix3x4fv
    , glProgramUniformMatrix3x4fvEXT
    , glProgramUniformMatrix4dv
    , glProgramUniformMatrix4dvEXT
    , glProgramUniformMatrix4fv
    , glProgramUniformMatrix4fvEXT
    , glProgramUniformMatrix4x2dv
    , glProgramUniformMatrix4x2dvEXT
    , glProgramUniformMatrix4x2fv
    , glProgramUniformMatrix4x2fvEXT
    , glProgramUniformMatrix4x3dv
    , glProgramUniformMatrix4x3dvEXT
    , glProgramUniformMatrix4x3fv
    , glProgramUniformMatrix4x3fvEXT
    , glProgramUniformui64NV
    , glProgramUniformui64vNV
    , glProgramVertexLimitNV
    , glProvokingVertex
    , glProvokingVertexEXT
    , glPushClientAttribDefaultEXT
    , glPushDebugGroup
    , glQueryCounter
    , glQueryObjectParameteruiAMD
    , glReadBuffer
    , glReadInstrumentsSGIX
    , glReadPixels
    , glReadnPixels
    , glReferencePlaneSGIX
    , glReleaseShaderCompiler
    , glRenderbufferStorage
    , glRenderbufferStorageEXT
    , glRenderbufferStorageMultisample
    , glRenderbufferStorageMultisampleCoverageNV
    , glRenderbufferStorageMultisampleEXT
    , glReplacementCodePointerSUN
    , glReplacementCodeubSUN
    , glReplacementCodeubvSUN
    , glReplacementCodeuiColor3fVertex3fSUN
    , glReplacementCodeuiColor3fVertex3fvSUN
    , glReplacementCodeuiColor4fNormal3fVertex3fSUN
    , glReplacementCodeuiColor4fNormal3fVertex3fvSUN
    , glReplacementCodeuiColor4ubVertex3fSUN
    , glReplacementCodeuiColor4ubVertex3fvSUN
    , glReplacementCodeuiNormal3fVertex3fSUN
    , glReplacementCodeuiNormal3fVertex3fvSUN
    , glReplacementCodeuiSUN
    , glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
    , glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
    , glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
    , glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
    , glReplacementCodeuiTexCoord2fVertex3fSUN
    , glReplacementCodeuiTexCoord2fVertex3fvSUN
    , glReplacementCodeuiVertex3fSUN
    , glReplacementCodeuiVertex3fvSUN
    , glReplacementCodeuivSUN
    , glReplacementCodeusSUN
    , glReplacementCodeusvSUN
    , glRequestResidentProgramsNV
    , glResetHistogramEXT
    , glResetMinmaxEXT
    , glResizeBuffersMESA
    , glResumeTransformFeedback
    , glResumeTransformFeedbackNV
    , glSampleCoverage
    , glSampleCoverageARB
    , glSampleMapATI
    , glSampleMaskEXT
    , glSampleMaskIndexedNV
    , glSampleMaskSGIS
    , glSampleMaski
    , glSamplePatternEXT
    , glSamplePatternSGIS
    , glSamplerParameterIiv
    , glSamplerParameterIuiv
    , glSamplerParameterf
    , glSamplerParameterfv
    , glSamplerParameteri
    , glSamplerParameteriv
    , glScissor
    , glScissorArrayv
    , glScissorIndexed
    , glScissorIndexedv
    , glSecondaryColor3bEXT
    , glSecondaryColor3bvEXT
    , glSecondaryColor3dEXT
    , glSecondaryColor3dvEXT
    , glSecondaryColor3fEXT
    , glSecondaryColor3fvEXT
    , glSecondaryColor3hNV
    , glSecondaryColor3hvNV
    , glSecondaryColor3iEXT
    , glSecondaryColor3ivEXT
    , glSecondaryColor3sEXT
    , glSecondaryColor3svEXT
    , glSecondaryColor3ubEXT
    , glSecondaryColor3ubvEXT
    , glSecondaryColor3uiEXT
    , glSecondaryColor3uivEXT
    , glSecondaryColor3usEXT
    , glSecondaryColor3usvEXT
    , glSecondaryColorFormatNV
    , glSecondaryColorP3ui
    , glSecondaryColorP3uiv
    , glSecondaryColorPointerEXT
    , glSecondaryColorPointerListIBM
    , glSeparableFilter2DEXT
    , glSetFenceAPPLE
    , glSetFragmentShaderConstantATI
    , glSetInvariantEXT
    , glSetLocalConstantEXT
    , glSetMultisamplefvAMD
    , glShaderBinary
    , glShaderOp1EXT
    , glShaderOp2EXT
    , glShaderOp3EXT
    , glShaderSource
    , glShaderSourceARB
    , glShaderStorageBlockBinding
    , glSharpenTexFuncSGIS
    , glSpriteParameterfSGIX
    , glSpriteParameterfvSGIX
    , glSpriteParameteriSGIX
    , glSpriteParameterivSGIX
    , glStartInstrumentsSGIX
    , glStateCaptureNV
    , glStencilClearTagEXT
    , glStencilFunc
    , glStencilFuncSeparate
    , glStencilFuncSeparateATI
    , glStencilMask
    , glStencilMaskSeparate
    , glStencilOp
    , glStencilOpSeparate
    , glStencilOpSeparateATI
    , glStencilOpValueAMD
    , glStopInstrumentsSGIX
    , glStringMarkerGREMEDY
    , glSwizzleEXT
    , glSyncTextureINTEL
    , glTagSampleBufferSGIX
    , glTangent3bEXT
    , glTangent3bvEXT
    , glTangent3dEXT
    , glTangent3dvEXT
    , glTangent3fEXT
    , glTangent3fvEXT
    , glTangent3iEXT
    , glTangent3ivEXT
    , glTangent3sEXT
    , glTangent3svEXT
    , glTangentPointerEXT
    , glTbufferMask3DFX
    , glTessellationFactorAMD
    , glTessellationModeAMD
    , glTestFenceAPPLE
    , glTestObjectAPPLE
    , glTexBuffer
    , glTexBufferARB
    , glTexBufferEXT
    , glTexBufferRange
    , glTexBumpParameterfvATI
    , glTexBumpParameterivATI
    , glTexCoord1hNV
    , glTexCoord1hvNV
    , glTexCoord2fColor3fVertex3fSUN
    , glTexCoord2fColor3fVertex3fvSUN
    , glTexCoord2fColor4fNormal3fVertex3fSUN
    , glTexCoord2fColor4fNormal3fVertex3fvSUN
    , glTexCoord2fColor4ubVertex3fSUN
    , glTexCoord2fColor4ubVertex3fvSUN
    , glTexCoord2fNormal3fVertex3fSUN
    , glTexCoord2fNormal3fVertex3fvSUN
    , glTexCoord2fVertex3fSUN
    , glTexCoord2fVertex3fvSUN
    , glTexCoord2hNV
    , glTexCoord2hvNV
    , glTexCoord3hNV
    , glTexCoord3hvNV
    , glTexCoord4fColor4fNormal3fVertex4fSUN
    , glTexCoord4fColor4fNormal3fVertex4fvSUN
    , glTexCoord4fVertex4fSUN
    , glTexCoord4fVertex4fvSUN
    , glTexCoord4hNV
    , glTexCoord4hvNV
    , glTexCoordFormatNV
    , glTexCoordP1ui
    , glTexCoordP1uiv
    , glTexCoordP2ui
    , glTexCoordP2uiv
    , glTexCoordP3ui
    , glTexCoordP3uiv
    , glTexCoordP4ui
    , glTexCoordP4uiv
    , glTexCoordPointerEXT
    , glTexCoordPointerListIBM
    , glTexCoordPointervINTEL
    , glTexFilterFuncSGIS
    , glTexImage1D
    , glTexImage2D
    , glTexImage2DMultisample
    , glTexImage2DMultisampleCoverageNV
    , glTexImage3D
    , glTexImage3DEXT
    , glTexImage3DMultisample
    , glTexImage3DMultisampleCoverageNV
    , glTexImage4DSGIS
    , glTexParameterIiv
    , glTexParameterIivEXT
    , glTexParameterIuiv
    , glTexParameterIuivEXT
    , glTexParameterf
    , glTexParameterfv
    , glTexParameteri
    , glTexParameteriv
    , glTexRenderbufferNV
    , glTexStorage1D
    , glTexStorage2D
    , glTexStorage2DMultisample
    , glTexStorage3D
    , glTexStorage3DMultisample
    , glTexStorageSparseAMD
    , glTexSubImage1D
    , glTexSubImage1DEXT
    , glTexSubImage2D
    , glTexSubImage2DEXT
    , glTexSubImage3D
    , glTexSubImage3DEXT
    , glTexSubImage4DSGIS
    , glTextureBarrier
    , glTextureBarrierNV
    , glTextureBuffer
    , glTextureBufferEXT
    , glTextureBufferRange
    , glTextureBufferRangeEXT
    , glTextureColorMaskSGIS
    , glTextureImage1DEXT
    , glTextureImage2DEXT
    , glTextureImage2DMultisampleCoverageNV
    , glTextureImage2DMultisampleNV
    , glTextureImage3DEXT
    , glTextureImage3DMultisampleCoverageNV
    , glTextureImage3DMultisampleNV
    , glTextureLightEXT
    , glTextureMaterialEXT
    , glTextureNormalEXT
    , glTexturePageCommitmentEXT
    , glTextureParameterIiv
    , glTextureParameterIivEXT
    , glTextureParameterIuiv
    , glTextureParameterIuivEXT
    , glTextureParameterf
    , glTextureParameterfEXT
    , glTextureParameterfv
    , glTextureParameterfvEXT
    , glTextureParameteri
    , glTextureParameteriEXT
    , glTextureParameteriv
    , glTextureParameterivEXT
    , glTextureRangeAPPLE
    , glTextureRenderbufferEXT
    , glTextureStorage1D
    , glTextureStorage1DEXT
    , glTextureStorage2D
    , glTextureStorage2DEXT
    , glTextureStorage2DMultisample
    , glTextureStorage2DMultisampleEXT
    , glTextureStorage3D
    , glTextureStorage3DEXT
    , glTextureStorage3DMultisample
    , glTextureStorage3DMultisampleEXT
    , glTextureStorageSparseAMD
    , glTextureSubImage1D
    , glTextureSubImage1DEXT
    , glTextureSubImage2D
    , glTextureSubImage2DEXT
    , glTextureSubImage3D
    , glTextureSubImage3DEXT
    , glTextureView
    , glTrackMatrixNV
    , glTransformFeedbackAttribsNV
    , glTransformFeedbackBufferBase
    , glTransformFeedbackBufferRange
    , glTransformFeedbackStreamAttribsNV
    , glTransformFeedbackVaryings
    , glTransformFeedbackVaryingsEXT
    , glTransformFeedbackVaryingsNV
    , glUniform1d
    , glUniform1dv
    , glUniform1f
    , glUniform1fARB
    , glUniform1fv
    , glUniform1fvARB
    , glUniform1i
    , glUniform1i64ARB
    , glUniform1i64NV
    , glUniform1i64vARB
    , glUniform1i64vNV
    , glUniform1iARB
    , glUniform1iv
    , glUniform1ivARB
    , glUniform1ui
    , glUniform1ui64ARB
    , glUniform1ui64NV
    , glUniform1ui64vARB
    , glUniform1ui64vNV
    , glUniform1uiEXT
    , glUniform1uiv
    , glUniform1uivEXT
    , glUniform2d
    , glUniform2dv
    , glUniform2f
    , glUniform2fARB
    , glUniform2fv
    , glUniform2fvARB
    , glUniform2i
    , glUniform2i64ARB
    , glUniform2i64NV
    , glUniform2i64vARB
    , glUniform2i64vNV
    , glUniform2iARB
    , glUniform2iv
    , glUniform2ivARB
    , glUniform2ui
    , glUniform2ui64ARB
    , glUniform2ui64NV
    , glUniform2ui64vARB
    , glUniform2ui64vNV
    , glUniform2uiEXT
    , glUniform2uiv
    , glUniform2uivEXT
    , glUniform3d
    , glUniform3dv
    , glUniform3f
    , glUniform3fARB
    , glUniform3fv
    , glUniform3fvARB
    , glUniform3i
    , glUniform3i64ARB
    , glUniform3i64NV
    , glUniform3i64vARB
    , glUniform3i64vNV
    , glUniform3iARB
    , glUniform3iv
    , glUniform3ivARB
    , glUniform3ui
    , glUniform3ui64ARB
    , glUniform3ui64NV
    , glUniform3ui64vARB
    , glUniform3ui64vNV
    , glUniform3uiEXT
    , glUniform3uiv
    , glUniform3uivEXT
    , glUniform4d
    , glUniform4dv
    , glUniform4f
    , glUniform4fARB
    , glUniform4fv
    , glUniform4fvARB
    , glUniform4i
    , glUniform4i64ARB
    , glUniform4i64NV
    , glUniform4i64vARB
    , glUniform4i64vNV
    , glUniform4iARB
    , glUniform4iv
    , glUniform4ivARB
    , glUniform4ui
    , glUniform4ui64ARB
    , glUniform4ui64NV
    , glUniform4ui64vARB
    , glUniform4ui64vNV
    , glUniform4uiEXT
    , glUniform4uiv
    , glUniform4uivEXT
    , glUniformBlockBinding
    , glUniformBufferEXT
    , glUniformMatrix2dv
    , glUniformMatrix2fv
    , glUniformMatrix2fvARB
    , glUniformMatrix2x3dv
    , glUniformMatrix2x3fv
    , glUniformMatrix2x4dv
    , glUniformMatrix2x4fv
    , glUniformMatrix3dv
    , glUniformMatrix3fv
    , glUniformMatrix3fvARB
    , glUniformMatrix3x2dv
    , glUniformMatrix3x2fv
    , glUniformMatrix3x4dv
    , glUniformMatrix3x4fv
    , glUniformMatrix4dv
    , glUniformMatrix4fv
    , glUniformMatrix4fvARB
    , glUniformMatrix4x2dv
    , glUniformMatrix4x2fv
    , glUniformMatrix4x3dv
    , glUniformMatrix4x3fv
    , glUniformSubroutinesuiv
    , glUniformui64NV
    , glUniformui64vNV
    , glUnlockArraysEXT
    , glUnmapBuffer
    , glUnmapBufferARB
    , glUnmapNamedBuffer
    , glUnmapNamedBufferEXT
    , glUnmapObjectBufferATI
    , glUnmapTexture2DINTEL
    , glUpdateObjectBufferATI
    , glUseProgram
    , glUseProgramObjectARB
    , glUseProgramStages
    , glVDPAUFiniNV
    , glVDPAUGetSurfaceivNV
    , glVDPAUInitNV
    , glVDPAUIsSurfaceNV
    , glVDPAUMapSurfacesNV
    , glVDPAURegisterOutputSurfaceNV
    , glVDPAURegisterVideoSurfaceNV
    , glVDPAUSurfaceAccessNV
    , glVDPAUUnmapSurfacesNV
    , glVDPAUUnregisterSurfaceNV
    , glValidateProgram
    , glValidateProgramARB
    , glValidateProgramPipeline
    , glVariantArrayObjectATI
    , glVariantPointerEXT
    , glVariantbvEXT
    , glVariantdvEXT
    , glVariantfvEXT
    , glVariantivEXT
    , glVariantsvEXT
    , glVariantubvEXT
    , glVariantuivEXT
    , glVariantusvEXT
    , glVertex2hNV
    , glVertex2hvNV
    , glVertex3hNV
    , glVertex3hvNV
    , glVertex4hNV
    , glVertex4hvNV
    , glVertexArrayAttribBinding
    , glVertexArrayAttribFormat
    , glVertexArrayAttribIFormat
    , glVertexArrayAttribLFormat
    , glVertexArrayBindVertexBufferEXT
    , glVertexArrayBindingDivisor
    , glVertexArrayColorOffsetEXT
    , glVertexArrayEdgeFlagOffsetEXT
    , glVertexArrayElementBuffer
    , glVertexArrayFogCoordOffsetEXT
    , glVertexArrayIndexOffsetEXT
    , glVertexArrayMultiTexCoordOffsetEXT
    , glVertexArrayNormalOffsetEXT
    , glVertexArrayParameteriAPPLE
    , glVertexArrayRangeAPPLE
    , glVertexArrayRangeNV
    , glVertexArraySecondaryColorOffsetEXT
    , glVertexArrayTexCoordOffsetEXT
    , glVertexArrayVertexAttribBindingEXT
    , glVertexArrayVertexAttribDivisorEXT
    , glVertexArrayVertexAttribFormatEXT
    , glVertexArrayVertexAttribIFormatEXT
    , glVertexArrayVertexAttribIOffsetEXT
    , glVertexArrayVertexAttribLFormatEXT
    , glVertexArrayVertexAttribLOffsetEXT
    , glVertexArrayVertexAttribOffsetEXT
    , glVertexArrayVertexBindingDivisorEXT
    , glVertexArrayVertexBuffer
    , glVertexArrayVertexBuffers
    , glVertexArrayVertexOffsetEXT
    , glVertexAttrib1d
    , glVertexAttrib1dARB
    , glVertexAttrib1dNV
    , glVertexAttrib1dv
    , glVertexAttrib1dvARB
    , glVertexAttrib1dvNV
    , glVertexAttrib1f
    , glVertexAttrib1fARB
    , glVertexAttrib1fNV
    , glVertexAttrib1fv
    , glVertexAttrib1fvARB
    , glVertexAttrib1fvNV
    , glVertexAttrib1hNV
    , glVertexAttrib1hvNV
    , glVertexAttrib1s
    , glVertexAttrib1sARB
    , glVertexAttrib1sNV
    , glVertexAttrib1sv
    , glVertexAttrib1svARB
    , glVertexAttrib1svNV
    , glVertexAttrib2d
    , glVertexAttrib2dARB
    , glVertexAttrib2dNV
    , glVertexAttrib2dv
    , glVertexAttrib2dvARB
    , glVertexAttrib2dvNV
    , glVertexAttrib2f
    , glVertexAttrib2fARB
    , glVertexAttrib2fNV
    , glVertexAttrib2fv
    , glVertexAttrib2fvARB
    , glVertexAttrib2fvNV
    , glVertexAttrib2hNV
    , glVertexAttrib2hvNV
    , glVertexAttrib2s
    , glVertexAttrib2sARB
    , glVertexAttrib2sNV
    , glVertexAttrib2sv
    , glVertexAttrib2svARB
    , glVertexAttrib2svNV
    , glVertexAttrib3d
    , glVertexAttrib3dARB
    , glVertexAttrib3dNV
    , glVertexAttrib3dv
    , glVertexAttrib3dvARB
    , glVertexAttrib3dvNV
    , glVertexAttrib3f
    , glVertexAttrib3fARB
    , glVertexAttrib3fNV
    , glVertexAttrib3fv
    , glVertexAttrib3fvARB
    , glVertexAttrib3fvNV
    , glVertexAttrib3hNV
    , glVertexAttrib3hvNV
    , glVertexAttrib3s
    , glVertexAttrib3sARB
    , glVertexAttrib3sNV
    , glVertexAttrib3sv
    , glVertexAttrib3svARB
    , glVertexAttrib3svNV
    , glVertexAttrib4Nbv
    , glVertexAttrib4NbvARB
    , glVertexAttrib4Niv
    , glVertexAttrib4NivARB
    , glVertexAttrib4Nsv
    , glVertexAttrib4NsvARB
    , glVertexAttrib4Nub
    , glVertexAttrib4NubARB
    , glVertexAttrib4Nubv
    , glVertexAttrib4NubvARB
    , glVertexAttrib4Nuiv
    , glVertexAttrib4NuivARB
    , glVertexAttrib4Nusv
    , glVertexAttrib4NusvARB
    , glVertexAttrib4bv
    , glVertexAttrib4bvARB
    , glVertexAttrib4d
    , glVertexAttrib4dARB
    , glVertexAttrib4dNV
    , glVertexAttrib4dv
    , glVertexAttrib4dvARB
    , glVertexAttrib4dvNV
    , glVertexAttrib4f
    , glVertexAttrib4fARB
    , glVertexAttrib4fNV
    , glVertexAttrib4fv
    , glVertexAttrib4fvARB
    , glVertexAttrib4fvNV
    , glVertexAttrib4hNV
    , glVertexAttrib4hvNV
    , glVertexAttrib4iv
    , glVertexAttrib4ivARB
    , glVertexAttrib4s
    , glVertexAttrib4sARB
    , glVertexAttrib4sNV
    , glVertexAttrib4sv
    , glVertexAttrib4svARB
    , glVertexAttrib4svNV
    , glVertexAttrib4ubNV
    , glVertexAttrib4ubv
    , glVertexAttrib4ubvARB
    , glVertexAttrib4ubvNV
    , glVertexAttrib4uiv
    , glVertexAttrib4uivARB
    , glVertexAttrib4usv
    , glVertexAttrib4usvARB
    , glVertexAttribArrayObjectATI
    , glVertexAttribBinding
    , glVertexAttribDivisor
    , glVertexAttribDivisorARB
    , glVertexAttribFormat
    , glVertexAttribFormatNV
    , glVertexAttribI1i
    , glVertexAttribI1iEXT
    , glVertexAttribI1iv
    , glVertexAttribI1ivEXT
    , glVertexAttribI1ui
    , glVertexAttribI1uiEXT
    , glVertexAttribI1uiv
    , glVertexAttribI1uivEXT
    , glVertexAttribI2i
    , glVertexAttribI2iEXT
    , glVertexAttribI2iv
    , glVertexAttribI2ivEXT
    , glVertexAttribI2ui
    , glVertexAttribI2uiEXT
    , glVertexAttribI2uiv
    , glVertexAttribI2uivEXT
    , glVertexAttribI3i
    , glVertexAttribI3iEXT
    , glVertexAttribI3iv
    , glVertexAttribI3ivEXT
    , glVertexAttribI3ui
    , glVertexAttribI3uiEXT
    , glVertexAttribI3uiv
    , glVertexAttribI3uivEXT
    , glVertexAttribI4bv
    , glVertexAttribI4bvEXT
    , glVertexAttribI4i
    , glVertexAttribI4iEXT
    , glVertexAttribI4iv
    , glVertexAttribI4ivEXT
    , glVertexAttribI4sv
    , glVertexAttribI4svEXT
    , glVertexAttribI4ubv
    , glVertexAttribI4ubvEXT
    , glVertexAttribI4ui
    , glVertexAttribI4uiEXT
    , glVertexAttribI4uiv
    , glVertexAttribI4uivEXT
    , glVertexAttribI4usv
    , glVertexAttribI4usvEXT
    , glVertexAttribIFormat
    , glVertexAttribIFormatNV
    , glVertexAttribIPointer
    , glVertexAttribIPointerEXT
    , glVertexAttribL1d
    , glVertexAttribL1dEXT
    , glVertexAttribL1dv
    , glVertexAttribL1dvEXT
    , glVertexAttribL1i64NV
    , glVertexAttribL1i64vNV
    , glVertexAttribL1ui64NV
    , glVertexAttribL1ui64vNV
    , glVertexAttribL2d
    , glVertexAttribL2dEXT
    , glVertexAttribL2dv
    , glVertexAttribL2dvEXT
    , glVertexAttribL2i64NV
    , glVertexAttribL2i64vNV
    , glVertexAttribL2ui64NV
    , glVertexAttribL2ui64vNV
    , glVertexAttribL3d
    , glVertexAttribL3dEXT
    , glVertexAttribL3dv
    , glVertexAttribL3dvEXT
    , glVertexAttribL3i64NV
    , glVertexAttribL3i64vNV
    , glVertexAttribL3ui64NV
    , glVertexAttribL3ui64vNV
    , glVertexAttribL4d
    , glVertexAttribL4dEXT
    , glVertexAttribL4dv
    , glVertexAttribL4dvEXT
    , glVertexAttribL4i64NV
    , glVertexAttribL4i64vNV
    , glVertexAttribL4ui64NV
    , glVertexAttribL4ui64vNV
    , glVertexAttribLFormat
    , glVertexAttribLFormatNV
    , glVertexAttribLPointer
    , glVertexAttribLPointerEXT
    , glVertexAttribP1ui
    , glVertexAttribP1uiv
    , glVertexAttribP2ui
    , glVertexAttribP2uiv
    , glVertexAttribP3ui
    , glVertexAttribP3uiv
    , glVertexAttribP4ui
    , glVertexAttribP4uiv
    , glVertexAttribParameteriAMD
    , glVertexAttribPointer
    , glVertexAttribPointerARB
    , glVertexAttribPointerNV
    , glVertexAttribs1dvNV
    , glVertexAttribs1fvNV
    , glVertexAttribs1hvNV
    , glVertexAttribs1svNV
    , glVertexAttribs2dvNV
    , glVertexAttribs2fvNV
    , glVertexAttribs2hvNV
    , glVertexAttribs2svNV
    , glVertexAttribs3dvNV
    , glVertexAttribs3fvNV
    , glVertexAttribs3hvNV
    , glVertexAttribs3svNV
    , glVertexAttribs4dvNV
    , glVertexAttribs4fvNV
    , glVertexAttribs4hvNV
    , glVertexAttribs4svNV
    , glVertexAttribs4ubvNV
    , glVertexBindingDivisor
    , glVertexBlendARB
    , glVertexBlendEnvfATI
    , glVertexBlendEnviATI
    , glVertexFormatNV
    , glVertexP2ui
    , glVertexP2uiv
    , glVertexP3ui
    , glVertexP3uiv
    , glVertexP4ui
    , glVertexP4uiv
    , glVertexPointerEXT
    , glVertexPointerListIBM
    , glVertexPointervINTEL
    , glVertexStream1dATI
    , glVertexStream1dvATI
    , glVertexStream1fATI
    , glVertexStream1fvATI
    , glVertexStream1iATI
    , glVertexStream1ivATI
    , glVertexStream1sATI
    , glVertexStream1svATI
    , glVertexStream2dATI
    , glVertexStream2dvATI
    , glVertexStream2fATI
    , glVertexStream2fvATI
    , glVertexStream2iATI
    , glVertexStream2ivATI
    , glVertexStream2sATI
    , glVertexStream2svATI
    , glVertexStream3dATI
    , glVertexStream3dvATI
    , glVertexStream3fATI
    , glVertexStream3fvATI
    , glVertexStream3iATI
    , glVertexStream3ivATI
    , glVertexStream3sATI
    , glVertexStream3svATI
    , glVertexStream4dATI
    , glVertexStream4dvATI
    , glVertexStream4fATI
    , glVertexStream4fvATI
    , glVertexStream4iATI
    , glVertexStream4ivATI
    , glVertexStream4sATI
    , glVertexStream4svATI
    , glVertexWeightPointerEXT
    , glVertexWeightfEXT
    , glVertexWeightfvEXT
    , glVertexWeighthNV
    , glVertexWeighthvNV
    , glVideoCaptureNV
    , glVideoCaptureStreamParameterdvNV
    , glVideoCaptureStreamParameterfvNV
    , glVideoCaptureStreamParameterivNV
    , glViewport
    , glViewportArrayv
    , glViewportIndexedf
    , glViewportIndexedfv
    , glViewportPositionWScaleNV
    , glWaitSync
    , glWeightPointerARB
    , glWeightbvARB
    , glWeightdvARB
    , glWeightfvARB
    , glWeightivARB
    , glWeightsvARB
    , glWeightubvARB
    , glWeightuivARB
    , glWeightusvARB
    , glWindowPos2dARB
    , glWindowPos2dMESA
    , glWindowPos2dvARB
    , glWindowPos2dvMESA
    , glWindowPos2fARB
    , glWindowPos2fMESA
    , glWindowPos2fvARB
    , glWindowPos2fvMESA
    , glWindowPos2iARB
    , glWindowPos2iMESA
    , glWindowPos2ivARB
    , glWindowPos2ivMESA
    , glWindowPos2sARB
    , glWindowPos2sMESA
    , glWindowPos2svARB
    , glWindowPos2svMESA
    , glWindowPos3dARB
    , glWindowPos3dMESA
    , glWindowPos3dvARB
    , glWindowPos3dvMESA
    , glWindowPos3fARB
    , glWindowPos3fMESA
    , glWindowPos3fvARB
    , glWindowPos3fvMESA
    , glWindowPos3iARB
    , glWindowPos3iMESA
    , glWindowPos3ivARB
    , glWindowPos3ivMESA
    , glWindowPos3sARB
    , glWindowPos3sMESA
    , glWindowPos3svARB
    , glWindowPos3svMESA
    , glWindowPos4dMESA
    , glWindowPos4dvMESA
    , glWindowPos4fMESA
    , glWindowPos4fvMESA
    , glWindowPos4iMESA
    , glWindowPos4ivMESA
    , glWindowPos4sMESA
    , glWindowPos4svMESA
    , glWriteMaskEXT
    ) where

import Control.Monad.IO.Class (MonadIO)
import Data.Coerce (coerce)
import Foreign.Ptr (Ptr)
import qualified Graphics.GL as GL
import qualified Graphics.GL.Compatibility45 as GL
import qualified Graphics.GL.Ext as GL
import GLW.Internal.Groups
import GLW.Internal.ObjectTypes
import GLW.Types
#ifdef GLW_DEBUG
import GLW.Debug
#endif
import Prelude (Maybe, Ord(..), (.), (<$>), fmap, fromIntegral, return)

glActiveShaderProgram :: MonadIO m => ProgramPipeline -> Program -> m ()
glActiveShaderProgram pipeline program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glActiveShaderProgram" [LogV'GLuint pipeline, LogV'GLuint program]
#endif
    _result <- GL.glActiveShaderProgram (coerce pipeline) (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glActiveShaderProgram" (LogV'Void)
#endif
    return _result

glActiveStencilFaceEXT :: MonadIO m => GL.GLenum -> m ()
glActiveStencilFaceEXT face = do
#ifdef GLW_DEBUG
    logGLCommandStart "glActiveStencilFaceEXT" [LogV'GLenum face]
#endif
    _result <- GL.glActiveStencilFaceEXT face
#ifdef GLW_DEBUG
    logGLCommandEnd "glActiveStencilFaceEXT" (LogV'Void)
#endif
    return _result

glActiveTexture :: MonadIO m => TextureUnit -> m ()
glActiveTexture texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glActiveTexture" [LogV'GLenum texture]
#endif
    _result <- GL.glActiveTexture (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glActiveTexture" (LogV'Void)
#endif
    return _result

glActiveTextureARB :: MonadIO m => TextureUnit -> m ()
glActiveTextureARB texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glActiveTextureARB" [LogV'GLenum texture]
#endif
    _result <- GL.glActiveTextureARB (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glActiveTextureARB" (LogV'Void)
#endif
    return _result

glActiveVaryingNV :: MonadIO m => Program -> Ptr GL.GLchar -> m ()
glActiveVaryingNV program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glActiveVaryingNV" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glActiveVaryingNV (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glActiveVaryingNV" (LogV'Void)
#endif
    return _result

glAlphaFragmentOp1ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glAlphaFragmentOp1ATI op dst dstMod arg1 arg1Rep arg1Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAlphaFragmentOp1ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod]
#endif
    _result <- GL.glAlphaFragmentOp1ATI op dst dstMod arg1 arg1Rep arg1Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glAlphaFragmentOp1ATI" (LogV'Void)
#endif
    return _result

glAlphaFragmentOp2ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glAlphaFragmentOp2ATI op dst dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAlphaFragmentOp2ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod, LogV'GLuint arg2, LogV'GLuint arg2Rep, LogV'GLuint arg2Mod]
#endif
    _result <- GL.glAlphaFragmentOp2ATI op dst dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glAlphaFragmentOp2ATI" (LogV'Void)
#endif
    return _result

glAlphaFragmentOp3ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glAlphaFragmentOp3ATI op dst dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod arg3 arg3Rep arg3Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAlphaFragmentOp3ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod, LogV'GLuint arg2, LogV'GLuint arg2Rep, LogV'GLuint arg2Mod, LogV'GLuint arg3, LogV'GLuint arg3Rep, LogV'GLuint arg3Mod]
#endif
    _result <- GL.glAlphaFragmentOp3ATI op dst dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod arg3 arg3Rep arg3Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glAlphaFragmentOp3ATI" (LogV'Void)
#endif
    return _result

glApplyTextureEXT :: MonadIO m => GL.GLenum -> m ()
glApplyTextureEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glApplyTextureEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glApplyTextureEXT mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glApplyTextureEXT" (LogV'Void)
#endif
    return _result

glAreProgramsResidentNV :: MonadIO m => GL.GLsizei -> Ptr Program -> Ptr Boolean -> m Boolean
glAreProgramsResidentNV n programs residences = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAreProgramsResidentNV" [LogV'GLsizei n, LogV'Ptr, LogV'Ptr]
#endif
    _result <- coerce <$> GL.glAreProgramsResidentNV n (coerce programs) (coerce residences)
#ifdef GLW_DEBUG
    logGLCommandEnd "glAreProgramsResidentNV" (LogV'GLboolean _result)
#endif
    return _result

glAreTexturesResidentEXT :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> Ptr Boolean -> m Boolean
glAreTexturesResidentEXT n textures residences = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAreTexturesResidentEXT" [LogV'GLsizei n, LogV'Ptr, LogV'Ptr]
#endif
    _result <- coerce <$> GL.glAreTexturesResidentEXT n (coerce textures) (coerce residences)
#ifdef GLW_DEBUG
    logGLCommandEnd "glAreTexturesResidentEXT" (LogV'GLboolean _result)
#endif
    return _result

glArrayElementEXT :: MonadIO m => GL.GLint -> m ()
glArrayElementEXT i = do
#ifdef GLW_DEBUG
    logGLCommandStart "glArrayElementEXT" [LogV'GLint i]
#endif
    _result <- GL.glArrayElementEXT i
#ifdef GLW_DEBUG
    logGLCommandEnd "glArrayElementEXT" (LogV'Void)
#endif
    return _result

glArrayObjectATI :: MonadIO m => EnableCap -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Buffer -> GL.GLuint -> m ()
glArrayObjectATI array size type' stride buffer offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glArrayObjectATI" [LogV'GLenum array, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLuint buffer, LogV'GLuint offset]
#endif
    _result <- GL.glArrayObjectATI (coerce array) size type' stride (coerce buffer) offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glArrayObjectATI" (LogV'Void)
#endif
    return _result

glAsyncMarkerSGIX :: MonadIO m => GL.GLuint -> m ()
glAsyncMarkerSGIX marker = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAsyncMarkerSGIX" [LogV'GLuint marker]
#endif
    _result <- GL.glAsyncMarkerSGIX marker
#ifdef GLW_DEBUG
    logGLCommandEnd "glAsyncMarkerSGIX" (LogV'Void)
#endif
    return _result

glAttachObjectARB :: MonadIO m => GL.GLhandleARB -> GL.GLhandleARB -> m ()
glAttachObjectARB containerObj obj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAttachObjectARB" [LogV'GLhandleARB containerObj, LogV'GLhandleARB obj]
#endif
    _result <- GL.glAttachObjectARB containerObj obj
#ifdef GLW_DEBUG
    logGLCommandEnd "glAttachObjectARB" (LogV'Void)
#endif
    return _result

glAttachShader :: MonadIO m => Program -> Shader (a :: ShaderType) -> m ()
glAttachShader program shader = do
#ifdef GLW_DEBUG
    logGLCommandStart "glAttachShader" [LogV'GLuint program, LogV'GLuint shader]
#endif
    _result <- GL.glAttachShader (coerce program) (coerce shader)
#ifdef GLW_DEBUG
    logGLCommandEnd "glAttachShader" (LogV'Void)
#endif
    return _result

glBeginConditionalRender :: MonadIO m => GL.GLuint -> GL.GLenum -> m ()
glBeginConditionalRender id mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginConditionalRender" [LogV'GLuint id, LogV'GLenum mode]
#endif
    _result <- GL.glBeginConditionalRender id mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginConditionalRender" (LogV'Void)
#endif
    return _result

glBeginConditionalRenderNVX :: MonadIO m => GL.GLuint -> m ()
glBeginConditionalRenderNVX id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginConditionalRenderNVX" [LogV'GLuint id]
#endif
    _result <- GL.glBeginConditionalRenderNVX id
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginConditionalRenderNVX" (LogV'Void)
#endif
    return _result

glBeginFragmentShaderATI :: MonadIO m => m ()
glBeginFragmentShaderATI  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginFragmentShaderATI" []
#endif
    _result <- GL.glBeginFragmentShaderATI 
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginFragmentShaderATI" (LogV'Void)
#endif
    return _result

glBeginOcclusionQueryNV :: MonadIO m => GL.GLuint -> m ()
glBeginOcclusionQueryNV id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginOcclusionQueryNV" [LogV'GLuint id]
#endif
    _result <- GL.glBeginOcclusionQueryNV id
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginOcclusionQueryNV" (LogV'Void)
#endif
    return _result

glBeginQuery :: MonadIO m => GL.GLenum -> Query (a :: QueryTarget) -> m ()
glBeginQuery target id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginQuery" [LogV'GLenum target, LogV'GLuint id]
#endif
    _result <- GL.glBeginQuery target (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginQuery" (LogV'Void)
#endif
    return _result

glBeginQueryARB :: MonadIO m => GL.GLenum -> Query (a :: QueryTarget) -> m ()
glBeginQueryARB target id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginQueryARB" [LogV'GLenum target, LogV'GLuint id]
#endif
    _result <- GL.glBeginQueryARB target (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginQueryARB" (LogV'Void)
#endif
    return _result

glBeginQueryIndexed :: MonadIO m => GL.GLenum -> GL.GLuint -> Query (a :: QueryTarget) -> m ()
glBeginQueryIndexed target index id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginQueryIndexed" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint id]
#endif
    _result <- GL.glBeginQueryIndexed target index (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginQueryIndexed" (LogV'Void)
#endif
    return _result

glBeginTransformFeedback :: MonadIO m => GL.GLenum -> m ()
glBeginTransformFeedback primitiveMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginTransformFeedback" [LogV'GLenum primitiveMode]
#endif
    _result <- GL.glBeginTransformFeedback primitiveMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginTransformFeedback" (LogV'Void)
#endif
    return _result

glBeginTransformFeedbackEXT :: MonadIO m => GL.GLenum -> m ()
glBeginTransformFeedbackEXT primitiveMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginTransformFeedbackEXT" [LogV'GLenum primitiveMode]
#endif
    _result <- GL.glBeginTransformFeedbackEXT primitiveMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginTransformFeedbackEXT" (LogV'Void)
#endif
    return _result

glBeginTransformFeedbackNV :: MonadIO m => GL.GLenum -> m ()
glBeginTransformFeedbackNV primitiveMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginTransformFeedbackNV" [LogV'GLenum primitiveMode]
#endif
    _result <- GL.glBeginTransformFeedbackNV primitiveMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glBeginVertexShaderEXT :: MonadIO m => m ()
glBeginVertexShaderEXT  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginVertexShaderEXT" []
#endif
    _result <- GL.glBeginVertexShaderEXT 
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginVertexShaderEXT" (LogV'Void)
#endif
    return _result

glBeginVideoCaptureNV :: MonadIO m => GL.GLuint -> m ()
glBeginVideoCaptureNV video_capture_slot = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBeginVideoCaptureNV" [LogV'GLuint video_capture_slot]
#endif
    _result <- GL.glBeginVideoCaptureNV video_capture_slot
#ifdef GLW_DEBUG
    logGLCommandEnd "glBeginVideoCaptureNV" (LogV'Void)
#endif
    return _result

glBindAttribLocation :: MonadIO m => Program -> AttribLocation -> Ptr GL.GLchar -> m ()
glBindAttribLocation program index name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindAttribLocation" [LogV'GLuint program, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glBindAttribLocation (coerce program) (coerce index) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindAttribLocation" (LogV'Void)
#endif
    return _result

glBindAttribLocationARB :: MonadIO m => GL.GLhandleARB -> AttribLocation -> Ptr GL.GLcharARB -> m ()
glBindAttribLocationARB programObj index name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindAttribLocationARB" [LogV'GLhandleARB programObj, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glBindAttribLocationARB programObj (coerce index) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindAttribLocationARB" (LogV'Void)
#endif
    return _result

glBindBuffer :: MonadIO m => GL.GLenum -> Buffer -> m ()
glBindBuffer target buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBuffer" [LogV'GLenum target, LogV'GLuint buffer]
#endif
    _result <- GL.glBindBuffer target (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBuffer" (LogV'Void)
#endif
    return _result

glBindBufferARB :: MonadIO m => GL.GLenum -> Buffer -> m ()
glBindBufferARB target buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferARB" [LogV'GLenum target, LogV'GLuint buffer]
#endif
    _result <- GL.glBindBufferARB target (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferARB" (LogV'Void)
#endif
    return _result

glBindBufferBase :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> m ()
glBindBufferBase target index buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferBase" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer]
#endif
    _result <- GL.glBindBufferBase target index (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferBase" (LogV'Void)
#endif
    return _result

glBindBufferBaseEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> m ()
glBindBufferBaseEXT target index buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferBaseEXT" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer]
#endif
    _result <- GL.glBindBufferBaseEXT target index (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferBaseEXT" (LogV'Void)
#endif
    return _result

glBindBufferBaseNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> m ()
glBindBufferBaseNV target index buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferBaseNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer]
#endif
    _result <- GL.glBindBufferBaseNV target index (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferBaseNV" (LogV'Void)
#endif
    return _result

glBindBufferOffsetEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> GL.GLintptr -> m ()
glBindBufferOffsetEXT target index buffer offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferOffsetEXT" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset]
#endif
    _result <- GL.glBindBufferOffsetEXT target index (coerce buffer) offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferOffsetEXT" (LogV'Void)
#endif
    return _result

glBindBufferOffsetNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> GL.GLintptr -> m ()
glBindBufferOffsetNV target index buffer offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferOffsetNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset]
#endif
    _result <- GL.glBindBufferOffsetNV target index (coerce buffer) offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferOffsetNV" (LogV'Void)
#endif
    return _result

glBindBufferRange :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glBindBufferRange target index buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferRange" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glBindBufferRange target index (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferRange" (LogV'Void)
#endif
    return _result

glBindBufferRangeEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glBindBufferRangeEXT target index buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferRangeEXT" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glBindBufferRangeEXT target index (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferRangeEXT" (LogV'Void)
#endif
    return _result

glBindBufferRangeNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glBindBufferRangeNV target index buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBufferRangeNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glBindBufferRangeNV target index (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBufferRangeNV" (LogV'Void)
#endif
    return _result

glBindBuffersBase :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr Buffer -> m ()
glBindBuffersBase target first count buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBuffersBase" [LogV'GLenum target, LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glBindBuffersBase target first count (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBuffersBase" (LogV'Void)
#endif
    return _result

glBindBuffersRange :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr Buffer -> Ptr GL.GLintptr -> Ptr GL.GLsizeiptr -> m ()
glBindBuffersRange target first count buffers offsets sizes = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindBuffersRange" [LogV'GLenum target, LogV'GLuint first, LogV'GLsizei count, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glBindBuffersRange target first count (coerce buffers) offsets sizes
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindBuffersRange" (LogV'Void)
#endif
    return _result

glBindFragDataLocation :: MonadIO m => Program -> GL.GLuint -> Ptr GL.GLchar -> m ()
glBindFragDataLocation program color name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFragDataLocation" [LogV'GLuint program, LogV'GLuint color, LogV'Ptr]
#endif
    _result <- GL.glBindFragDataLocation (coerce program) color name
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFragDataLocation" (LogV'Void)
#endif
    return _result

glBindFragDataLocationEXT :: MonadIO m => Program -> GL.GLuint -> Ptr GL.GLchar -> m ()
glBindFragDataLocationEXT program color name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFragDataLocationEXT" [LogV'GLuint program, LogV'GLuint color, LogV'Ptr]
#endif
    _result <- GL.glBindFragDataLocationEXT (coerce program) color name
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFragDataLocationEXT" (LogV'Void)
#endif
    return _result

glBindFragDataLocationIndexed :: MonadIO m => Program -> GL.GLuint -> GL.GLuint -> Ptr GL.GLchar -> m ()
glBindFragDataLocationIndexed program colorNumber index name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFragDataLocationIndexed" [LogV'GLuint program, LogV'GLuint colorNumber, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glBindFragDataLocationIndexed (coerce program) colorNumber index name
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFragDataLocationIndexed" (LogV'Void)
#endif
    return _result

glBindFragmentShaderATI :: MonadIO m => GL.GLuint -> m ()
glBindFragmentShaderATI id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFragmentShaderATI" [LogV'GLuint id]
#endif
    _result <- GL.glBindFragmentShaderATI id
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFragmentShaderATI" (LogV'Void)
#endif
    return _result

glBindFramebuffer :: MonadIO m => GL.GLenum -> Framebuffer -> m ()
glBindFramebuffer target framebuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFramebuffer" [LogV'GLenum target, LogV'GLuint framebuffer]
#endif
    _result <- GL.glBindFramebuffer target (coerce framebuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFramebuffer" (LogV'Void)
#endif
    return _result

glBindFramebufferEXT :: MonadIO m => GL.GLenum -> Framebuffer -> m ()
glBindFramebufferEXT target framebuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindFramebufferEXT" [LogV'GLenum target, LogV'GLuint framebuffer]
#endif
    _result <- GL.glBindFramebufferEXT target (coerce framebuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindFramebufferEXT" (LogV'Void)
#endif
    return _result

glBindImageTexture :: MonadIO m => GL.GLuint -> Texture (a :: TextureTarget') -> GL.GLint -> Boolean -> GL.GLint -> GL.GLenum -> GL.GLenum -> m ()
glBindImageTexture unit texture level layered layer access format = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindImageTexture" [LogV'GLuint unit, LogV'GLuint texture, LogV'GLint level, LogV'GLboolean layered, LogV'GLint layer, LogV'GLenum access, LogV'GLenum format]
#endif
    _result <- GL.glBindImageTexture unit (coerce texture) level (coerce layered) layer access format
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindImageTexture" (LogV'Void)
#endif
    return _result

glBindImageTextureEXT :: MonadIO m => GL.GLuint -> Texture (a :: TextureTarget') -> GL.GLint -> Boolean -> GL.GLint -> GL.GLenum -> GL.GLint -> m ()
glBindImageTextureEXT index texture level layered layer access format = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindImageTextureEXT" [LogV'GLuint index, LogV'GLuint texture, LogV'GLint level, LogV'GLboolean layered, LogV'GLint layer, LogV'GLenum access, LogV'GLint format]
#endif
    _result <- GL.glBindImageTextureEXT index (coerce texture) level (coerce layered) layer access format
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindImageTextureEXT" (LogV'Void)
#endif
    return _result

glBindImageTextures :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glBindImageTextures first count textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindImageTextures" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glBindImageTextures first count (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindImageTextures" (LogV'Void)
#endif
    return _result

glBindLightParameterEXT :: MonadIO m => LightName -> LightParameter -> m GL.GLuint
glBindLightParameterEXT light value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindLightParameterEXT" [LogV'GLenum light, LogV'GLenum value]
#endif
    _result <- GL.glBindLightParameterEXT (coerce light) (coerce value)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindLightParameterEXT" (LogV'GLuint _result)
#endif
    return _result

glBindMaterialParameterEXT :: MonadIO m => MaterialFace -> MaterialParameter -> m GL.GLuint
glBindMaterialParameterEXT face value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindMaterialParameterEXT" [LogV'GLenum face, LogV'GLenum value]
#endif
    _result <- GL.glBindMaterialParameterEXT (coerce face) (coerce value)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindMaterialParameterEXT" (LogV'GLuint _result)
#endif
    return _result

glBindMultiTextureEXT :: MonadIO m => TextureUnit -> TextureTarget -> Texture (a :: TextureTarget') -> m ()
glBindMultiTextureEXT texunit target texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindMultiTextureEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLuint texture]
#endif
    _result <- GL.glBindMultiTextureEXT (coerce texunit) (coerce target) (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindMultiTextureEXT" (LogV'Void)
#endif
    return _result

glBindParameterEXT :: MonadIO m => GL.GLenum -> m GL.GLuint
glBindParameterEXT value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindParameterEXT" [LogV'GLenum value]
#endif
    _result <- GL.glBindParameterEXT value
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindParameterEXT" (LogV'GLuint _result)
#endif
    return _result

glBindProgramARB :: MonadIO m => GL.GLenum -> Program -> m ()
glBindProgramARB target program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindProgramARB" [LogV'GLenum target, LogV'GLuint program]
#endif
    _result <- GL.glBindProgramARB target (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindProgramARB" (LogV'Void)
#endif
    return _result

glBindProgramNV :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glBindProgramNV target id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindProgramNV" [LogV'GLenum target, LogV'GLuint id]
#endif
    _result <- GL.glBindProgramNV target id
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindProgramNV" (LogV'Void)
#endif
    return _result

glBindProgramPipeline :: MonadIO m => ProgramPipeline -> m ()
glBindProgramPipeline pipeline = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindProgramPipeline" [LogV'GLuint pipeline]
#endif
    _result <- GL.glBindProgramPipeline (coerce pipeline)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindProgramPipeline" (LogV'Void)
#endif
    return _result

glBindRenderbuffer :: MonadIO m => GL.GLenum -> Renderbuffer -> m ()
glBindRenderbuffer target renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindRenderbuffer" [LogV'GLenum target, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glBindRenderbuffer target (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindRenderbuffer" (LogV'Void)
#endif
    return _result

glBindRenderbufferEXT :: MonadIO m => GL.GLenum -> Renderbuffer -> m ()
glBindRenderbufferEXT target renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindRenderbufferEXT" [LogV'GLenum target, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glBindRenderbufferEXT target (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindRenderbufferEXT" (LogV'Void)
#endif
    return _result

glBindSampler :: MonadIO m => GL.GLuint -> Sampler -> m ()
glBindSampler unit sampler = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindSampler" [LogV'GLuint unit, LogV'GLuint sampler]
#endif
    _result <- GL.glBindSampler unit (coerce sampler)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindSampler" (LogV'Void)
#endif
    return _result

glBindSamplers :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr Sampler -> m ()
glBindSamplers first count samplers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindSamplers" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glBindSamplers first count (coerce samplers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindSamplers" (LogV'Void)
#endif
    return _result

glBindTexGenParameterEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> m GL.GLuint
glBindTexGenParameterEXT unit coord value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTexGenParameterEXT" [LogV'GLenum unit, LogV'GLenum coord, LogV'GLenum value]
#endif
    _result <- GL.glBindTexGenParameterEXT (coerce unit) (coerce coord) (coerce value)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTexGenParameterEXT" (LogV'GLuint _result)
#endif
    return _result

glBindTexture :: MonadIO m => TextureTarget -> Texture (a :: TextureTarget') -> m ()
glBindTexture target texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTexture" [LogV'GLenum target, LogV'GLuint texture]
#endif
    _result <- GL.glBindTexture (coerce target) (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTexture" (LogV'Void)
#endif
    return _result

glBindTextureEXT :: MonadIO m => TextureTarget -> Texture (a :: TextureTarget') -> m ()
glBindTextureEXT target texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTextureEXT" [LogV'GLenum target, LogV'GLuint texture]
#endif
    _result <- GL.glBindTextureEXT (coerce target) (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTextureEXT" (LogV'Void)
#endif
    return _result

glBindTextureUnit :: MonadIO m => GL.GLuint -> Texture (a :: TextureTarget') -> m ()
glBindTextureUnit unit texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTextureUnit" [LogV'GLuint unit, LogV'GLuint texture]
#endif
    _result <- GL.glBindTextureUnit unit (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTextureUnit" (LogV'Void)
#endif
    return _result

glBindTextureUnitParameterEXT :: MonadIO m => TextureUnit -> GL.GLenum -> m GL.GLuint
glBindTextureUnitParameterEXT unit value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTextureUnitParameterEXT" [LogV'GLenum unit, LogV'GLenum value]
#endif
    _result <- GL.glBindTextureUnitParameterEXT (coerce unit) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTextureUnitParameterEXT" (LogV'GLuint _result)
#endif
    return _result

glBindTextures :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glBindTextures first count textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTextures" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glBindTextures first count (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTextures" (LogV'Void)
#endif
    return _result

glBindTransformFeedback :: MonadIO m => GL.GLenum -> TransformFeedback -> m ()
glBindTransformFeedback target id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTransformFeedback" [LogV'GLenum target, LogV'GLuint id]
#endif
    _result <- GL.glBindTransformFeedback target (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTransformFeedback" (LogV'Void)
#endif
    return _result

glBindTransformFeedbackNV :: MonadIO m => GL.GLenum -> TransformFeedback -> m ()
glBindTransformFeedbackNV target id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindTransformFeedbackNV" [LogV'GLenum target, LogV'GLuint id]
#endif
    _result <- GL.glBindTransformFeedbackNV target (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glBindVertexArray :: MonadIO m => VertexArray -> m ()
glBindVertexArray array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVertexArray" [LogV'GLuint array]
#endif
    _result <- GL.glBindVertexArray (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVertexArray" (LogV'Void)
#endif
    return _result

glBindVertexArrayAPPLE :: MonadIO m => VertexArray -> m ()
glBindVertexArrayAPPLE array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVertexArrayAPPLE" [LogV'GLuint array]
#endif
    _result <- GL.glBindVertexArrayAPPLE (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVertexArrayAPPLE" (LogV'Void)
#endif
    return _result

glBindVertexBuffer :: MonadIO m => BindingIndex -> Buffer -> GL.GLintptr -> GL.GLsizei -> m ()
glBindVertexBuffer bindingindex buffer offset stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVertexBuffer" [LogV'GLuint bindingindex, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizei stride]
#endif
    _result <- GL.glBindVertexBuffer (coerce bindingindex) (coerce buffer) offset stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVertexBuffer" (LogV'Void)
#endif
    return _result

glBindVertexBuffers :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr Buffer -> Ptr GL.GLintptr -> Ptr GL.GLsizei -> m ()
glBindVertexBuffers first count buffers offsets strides = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVertexBuffers" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glBindVertexBuffers first count (coerce buffers) offsets strides
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVertexBuffers" (LogV'Void)
#endif
    return _result

glBindVertexShaderEXT :: MonadIO m => GL.GLuint -> m ()
glBindVertexShaderEXT id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVertexShaderEXT" [LogV'GLuint id]
#endif
    _result <- GL.glBindVertexShaderEXT id
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVertexShaderEXT" (LogV'Void)
#endif
    return _result

glBindVideoCaptureStreamBufferNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLintptrARB -> m ()
glBindVideoCaptureStreamBufferNV video_capture_slot stream frame_region offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVideoCaptureStreamBufferNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum frame_region, LogV'GLintptrARB offset]
#endif
    _result <- GL.glBindVideoCaptureStreamBufferNV video_capture_slot stream frame_region offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVideoCaptureStreamBufferNV" (LogV'Void)
#endif
    return _result

glBindVideoCaptureStreamTextureNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> m ()
glBindVideoCaptureStreamTextureNV video_capture_slot stream frame_region target texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBindVideoCaptureStreamTextureNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum frame_region, LogV'GLenum target, LogV'GLuint texture]
#endif
    _result <- GL.glBindVideoCaptureStreamTextureNV video_capture_slot stream frame_region target (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBindVideoCaptureStreamTextureNV" (LogV'Void)
#endif
    return _result

glBinormal3bEXT :: MonadIO m => GL.GLbyte -> GL.GLbyte -> GL.GLbyte -> m ()
glBinormal3bEXT bx by bz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3bEXT" [LogV'GLbyte bx, LogV'GLbyte by, LogV'GLbyte bz]
#endif
    _result <- GL.glBinormal3bEXT bx by bz
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3bEXT" (LogV'Void)
#endif
    return _result

glBinormal3bvEXT :: MonadIO m => Ptr GL.GLbyte -> m ()
glBinormal3bvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3bvEXT" [LogV'Ptr]
#endif
    _result <- GL.glBinormal3bvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3bvEXT" (LogV'Void)
#endif
    return _result

glBinormal3dEXT :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glBinormal3dEXT bx by bz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3dEXT" [LogV'GLdouble bx, LogV'GLdouble by, LogV'GLdouble bz]
#endif
    _result <- GL.glBinormal3dEXT bx by bz
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3dEXT" (LogV'Void)
#endif
    return _result

glBinormal3dvEXT :: MonadIO m => Ptr GL.GLdouble -> m ()
glBinormal3dvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3dvEXT" [LogV'Ptr]
#endif
    _result <- GL.glBinormal3dvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3dvEXT" (LogV'Void)
#endif
    return _result

glBinormal3fEXT :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glBinormal3fEXT bx by bz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3fEXT" [LogV'GLfloat bx, LogV'GLfloat by, LogV'GLfloat bz]
#endif
    _result <- GL.glBinormal3fEXT bx by bz
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3fEXT" (LogV'Void)
#endif
    return _result

glBinormal3fvEXT :: MonadIO m => Ptr GL.GLfloat -> m ()
glBinormal3fvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3fvEXT" [LogV'Ptr]
#endif
    _result <- GL.glBinormal3fvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3fvEXT" (LogV'Void)
#endif
    return _result

glBinormal3iEXT :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> m ()
glBinormal3iEXT bx by bz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3iEXT" [LogV'GLint bx, LogV'GLint by, LogV'GLint bz]
#endif
    _result <- GL.glBinormal3iEXT bx by bz
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3iEXT" (LogV'Void)
#endif
    return _result

glBinormal3ivEXT :: MonadIO m => Ptr GL.GLint -> m ()
glBinormal3ivEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3ivEXT" [LogV'Ptr]
#endif
    _result <- GL.glBinormal3ivEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3ivEXT" (LogV'Void)
#endif
    return _result

glBinormal3sEXT :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glBinormal3sEXT bx by bz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3sEXT" [LogV'GLshort bx, LogV'GLshort by, LogV'GLshort bz]
#endif
    _result <- GL.glBinormal3sEXT bx by bz
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3sEXT" (LogV'Void)
#endif
    return _result

glBinormal3svEXT :: MonadIO m => Ptr GL.GLshort -> m ()
glBinormal3svEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormal3svEXT" [LogV'Ptr]
#endif
    _result <- GL.glBinormal3svEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormal3svEXT" (LogV'Void)
#endif
    return _result

glBinormalPointerEXT :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glBinormalPointerEXT type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBinormalPointerEXT" [LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glBinormalPointerEXT type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glBinormalPointerEXT" (LogV'Void)
#endif
    return _result

glBlendColor :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glBlendColor red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendColor" [LogV'GLfloat red, LogV'GLfloat green, LogV'GLfloat blue, LogV'GLfloat alpha]
#endif
    _result <- GL.glBlendColor red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendColor" (LogV'Void)
#endif
    return _result

glBlendColorEXT :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glBlendColorEXT red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendColorEXT" [LogV'GLfloat red, LogV'GLfloat green, LogV'GLfloat blue, LogV'GLfloat alpha]
#endif
    _result <- GL.glBlendColorEXT red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendColorEXT" (LogV'Void)
#endif
    return _result

glBlendEquation :: MonadIO m => GL.GLenum -> m ()
glBlendEquation mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquation" [LogV'GLenum mode]
#endif
    _result <- GL.glBlendEquation mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquation" (LogV'Void)
#endif
    return _result

glBlendEquationIndexedAMD :: MonadIO m => GL.GLuint -> GL.GLenum -> m ()
glBlendEquationIndexedAMD buf mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationIndexedAMD" [LogV'GLuint buf, LogV'GLenum mode]
#endif
    _result <- GL.glBlendEquationIndexedAMD buf mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationIndexedAMD" (LogV'Void)
#endif
    return _result

glBlendEquationSeparate :: MonadIO m => BlendEquationModeEXT -> BlendEquationModeEXT -> m ()
glBlendEquationSeparate modeRGB modeAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationSeparate" [LogV'GLenum modeRGB, LogV'GLenum modeAlpha]
#endif
    _result <- GL.glBlendEquationSeparate (coerce modeRGB) (coerce modeAlpha)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationSeparate" (LogV'Void)
#endif
    return _result

glBlendEquationSeparateEXT :: MonadIO m => BlendEquationModeEXT -> BlendEquationModeEXT -> m ()
glBlendEquationSeparateEXT modeRGB modeAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationSeparateEXT" [LogV'GLenum modeRGB, LogV'GLenum modeAlpha]
#endif
    _result <- GL.glBlendEquationSeparateEXT (coerce modeRGB) (coerce modeAlpha)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationSeparateEXT" (LogV'Void)
#endif
    return _result

glBlendEquationSeparateIndexedAMD :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> m ()
glBlendEquationSeparateIndexedAMD buf modeRGB modeAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationSeparateIndexedAMD" [LogV'GLuint buf, LogV'GLenum modeRGB, LogV'GLenum modeAlpha]
#endif
    _result <- GL.glBlendEquationSeparateIndexedAMD buf modeRGB modeAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationSeparateIndexedAMD" (LogV'Void)
#endif
    return _result

glBlendEquationSeparatei :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> m ()
glBlendEquationSeparatei buf modeRGB modeAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationSeparatei" [LogV'GLuint buf, LogV'GLenum modeRGB, LogV'GLenum modeAlpha]
#endif
    _result <- GL.glBlendEquationSeparatei buf modeRGB modeAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationSeparatei" (LogV'Void)
#endif
    return _result

glBlendEquationi :: MonadIO m => GL.GLuint -> GL.GLenum -> m ()
glBlendEquationi buf mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendEquationi" [LogV'GLuint buf, LogV'GLenum mode]
#endif
    _result <- GL.glBlendEquationi buf mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendEquationi" (LogV'Void)
#endif
    return _result

glBlendFunc :: MonadIO m => BlendingFactorSrc -> BlendingFactorDest -> m ()
glBlendFunc sfactor dfactor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFunc" [LogV'GLenum sfactor, LogV'GLenum dfactor]
#endif
    _result <- GL.glBlendFunc (coerce sfactor) (coerce dfactor)
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFunc" (LogV'Void)
#endif
    return _result

glBlendFuncIndexedAMD :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncIndexedAMD buf src dst = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncIndexedAMD" [LogV'GLuint buf, LogV'GLenum src, LogV'GLenum dst]
#endif
    _result <- GL.glBlendFuncIndexedAMD buf src dst
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncIndexedAMD" (LogV'Void)
#endif
    return _result

glBlendFuncSeparate :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncSeparate sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncSeparate" [LogV'GLenum sfactorRGB, LogV'GLenum dfactorRGB, LogV'GLenum sfactorAlpha, LogV'GLenum dfactorAlpha]
#endif
    _result <- GL.glBlendFuncSeparate sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncSeparate" (LogV'Void)
#endif
    return _result

glBlendFuncSeparateEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncSeparateEXT sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncSeparateEXT" [LogV'GLenum sfactorRGB, LogV'GLenum dfactorRGB, LogV'GLenum sfactorAlpha, LogV'GLenum dfactorAlpha]
#endif
    _result <- GL.glBlendFuncSeparateEXT sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncSeparateEXT" (LogV'Void)
#endif
    return _result

glBlendFuncSeparateINGR :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncSeparateINGR sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncSeparateINGR" [LogV'GLenum sfactorRGB, LogV'GLenum dfactorRGB, LogV'GLenum sfactorAlpha, LogV'GLenum dfactorAlpha]
#endif
    _result <- GL.glBlendFuncSeparateINGR sfactorRGB dfactorRGB sfactorAlpha dfactorAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncSeparateINGR" (LogV'Void)
#endif
    return _result

glBlendFuncSeparateIndexedAMD :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncSeparateIndexedAMD buf srcRGB dstRGB srcAlpha dstAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncSeparateIndexedAMD" [LogV'GLuint buf, LogV'GLenum srcRGB, LogV'GLenum dstRGB, LogV'GLenum srcAlpha, LogV'GLenum dstAlpha]
#endif
    _result <- GL.glBlendFuncSeparateIndexedAMD buf srcRGB dstRGB srcAlpha dstAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncSeparateIndexedAMD" (LogV'Void)
#endif
    return _result

glBlendFuncSeparatei :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glBlendFuncSeparatei buf srcRGB dstRGB srcAlpha dstAlpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFuncSeparatei" [LogV'GLuint buf, LogV'GLenum srcRGB, LogV'GLenum dstRGB, LogV'GLenum srcAlpha, LogV'GLenum dstAlpha]
#endif
    _result <- GL.glBlendFuncSeparatei buf srcRGB dstRGB srcAlpha dstAlpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFuncSeparatei" (LogV'Void)
#endif
    return _result

glBlendFunci :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLenum -> m ()
glBlendFunci buf src dst = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlendFunci" [LogV'GLuint buf, LogV'GLenum src, LogV'GLenum dst]
#endif
    _result <- GL.glBlendFunci buf src dst
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlendFunci" (LogV'Void)
#endif
    return _result

glBlitFramebuffer :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> ClearBufferMask -> GL.GLenum -> m ()
glBlitFramebuffer srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 mask filter = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlitFramebuffer" [LogV'GLint srcX0, LogV'GLint srcY0, LogV'GLint srcX1, LogV'GLint srcY1, LogV'GLint dstX0, LogV'GLint dstY0, LogV'GLint dstX1, LogV'GLint dstY1, LogV'GLbitfield mask, LogV'GLenum filter]
#endif
    _result <- GL.glBlitFramebuffer srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 (coerce mask) filter
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlitFramebuffer" (LogV'Void)
#endif
    return _result

glBlitFramebufferEXT :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> ClearBufferMask -> GL.GLenum -> m ()
glBlitFramebufferEXT srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 mask filter = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlitFramebufferEXT" [LogV'GLint srcX0, LogV'GLint srcY0, LogV'GLint srcX1, LogV'GLint srcY1, LogV'GLint dstX0, LogV'GLint dstY0, LogV'GLint dstX1, LogV'GLint dstY1, LogV'GLbitfield mask, LogV'GLenum filter]
#endif
    _result <- GL.glBlitFramebufferEXT srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 (coerce mask) filter
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlitFramebufferEXT" (LogV'Void)
#endif
    return _result

glBlitNamedFramebuffer :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLbitfield -> GL.GLenum -> m ()
glBlitNamedFramebuffer readFramebuffer drawFramebuffer srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 mask filter = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBlitNamedFramebuffer" [LogV'GLuint readFramebuffer, LogV'GLuint drawFramebuffer, LogV'GLint srcX0, LogV'GLint srcY0, LogV'GLint srcX1, LogV'GLint srcY1, LogV'GLint dstX0, LogV'GLint dstY0, LogV'GLint dstX1, LogV'GLint dstY1, LogV'GLbitfield mask, LogV'GLenum filter]
#endif
    _result <- GL.glBlitNamedFramebuffer readFramebuffer drawFramebuffer srcX0 srcY0 srcX1 srcY1 dstX0 dstY0 dstX1 dstY1 mask filter
#ifdef GLW_DEBUG
    logGLCommandEnd "glBlitNamedFramebuffer" (LogV'Void)
#endif
    return _result

glBufferAddressRangeNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint64EXT -> GL.GLsizeiptr -> m ()
glBufferAddressRangeNV pname index address length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferAddressRangeNV" [LogV'GLenum pname, LogV'GLuint index, LogV'GLuint64EXT address, LogV'GLsizeiptr length]
#endif
    _result <- GL.glBufferAddressRangeNV pname index address length
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferAddressRangeNV" (LogV'Void)
#endif
    return _result

glBufferData :: MonadIO m => GL.GLenum -> GL.GLsizeiptr -> Ptr () -> GL.GLenum -> m ()
glBufferData target size data' usage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferData" [LogV'GLenum target, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLenum usage]
#endif
    _result <- GL.glBufferData target size data' usage
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferData" (LogV'Void)
#endif
    return _result

glBufferDataARB :: MonadIO m => GL.GLenum -> GL.GLsizeiptrARB -> Ptr () -> GL.GLenum -> m ()
glBufferDataARB target size data' usage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferDataARB" [LogV'GLenum target, LogV'GLsizeiptrARB size, LogV'Ptr, LogV'GLenum usage]
#endif
    _result <- GL.glBufferDataARB target size data' usage
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferDataARB" (LogV'Void)
#endif
    return _result

glBufferParameteriAPPLE :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLint -> m ()
glBufferParameteriAPPLE target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferParameteriAPPLE" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glBufferParameteriAPPLE target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferParameteriAPPLE" (LogV'Void)
#endif
    return _result

glBufferStorage :: MonadIO m => GL.GLenum -> GL.GLsizeiptr -> Ptr () -> GL.GLbitfield -> m ()
glBufferStorage target size data' flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferStorage" [LogV'GLenum target, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLbitfield flags]
#endif
    _result <- GL.glBufferStorage target size data' flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferStorage" (LogV'Void)
#endif
    return _result

glBufferSubData :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glBufferSubData target offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferSubData" [LogV'GLenum target, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glBufferSubData target offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferSubData" (LogV'Void)
#endif
    return _result

glBufferSubDataARB :: MonadIO m => GL.GLenum -> GL.GLintptrARB -> GL.GLsizeiptrARB -> Ptr () -> m ()
glBufferSubDataARB target offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glBufferSubDataARB" [LogV'GLenum target, LogV'GLintptrARB offset, LogV'GLsizeiptrARB size, LogV'Ptr]
#endif
    _result <- GL.glBufferSubDataARB target offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glBufferSubDataARB" (LogV'Void)
#endif
    return _result

glCallCommandListNV :: MonadIO m => GL.GLuint -> m ()
glCallCommandListNV list = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCallCommandListNV" [LogV'GLuint list]
#endif
    _result <- GL.glCallCommandListNV list
#ifdef GLW_DEBUG
    logGLCommandEnd "glCallCommandListNV" (LogV'Void)
#endif
    return _result

glCheckFramebufferStatus :: MonadIO m => GL.GLenum -> m GL.GLenum
glCheckFramebufferStatus target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCheckFramebufferStatus" [LogV'GLenum target]
#endif
    _result <- GL.glCheckFramebufferStatus target
#ifdef GLW_DEBUG
    logGLCommandEnd "glCheckFramebufferStatus" (LogV'GLenum _result)
#endif
    return _result

glCheckFramebufferStatusEXT :: MonadIO m => GL.GLenum -> m GL.GLenum
glCheckFramebufferStatusEXT target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCheckFramebufferStatusEXT" [LogV'GLenum target]
#endif
    _result <- GL.glCheckFramebufferStatusEXT target
#ifdef GLW_DEBUG
    logGLCommandEnd "glCheckFramebufferStatusEXT" (LogV'GLenum _result)
#endif
    return _result

glCheckNamedFramebufferStatus :: MonadIO m => Framebuffer -> GL.GLenum -> m GL.GLenum
glCheckNamedFramebufferStatus framebuffer target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCheckNamedFramebufferStatus" [LogV'GLuint framebuffer, LogV'GLenum target]
#endif
    _result <- GL.glCheckNamedFramebufferStatus (coerce framebuffer) target
#ifdef GLW_DEBUG
    logGLCommandEnd "glCheckNamedFramebufferStatus" (LogV'GLenum _result)
#endif
    return _result

glCheckNamedFramebufferStatusEXT :: MonadIO m => Framebuffer -> GL.GLenum -> m GL.GLenum
glCheckNamedFramebufferStatusEXT framebuffer target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCheckNamedFramebufferStatusEXT" [LogV'GLuint framebuffer, LogV'GLenum target]
#endif
    _result <- GL.glCheckNamedFramebufferStatusEXT (coerce framebuffer) target
#ifdef GLW_DEBUG
    logGLCommandEnd "glCheckNamedFramebufferStatusEXT" (LogV'GLenum _result)
#endif
    return _result

glClampColor :: MonadIO m => GL.GLenum -> GL.GLenum -> m ()
glClampColor target clamp = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClampColor" [LogV'GLenum target, LogV'GLenum clamp]
#endif
    _result <- GL.glClampColor target clamp
#ifdef GLW_DEBUG
    logGLCommandEnd "glClampColor" (LogV'Void)
#endif
    return _result

glClampColorARB :: MonadIO m => GL.GLenum -> GL.GLenum -> m ()
glClampColorARB target clamp = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClampColorARB" [LogV'GLenum target, LogV'GLenum clamp]
#endif
    _result <- GL.glClampColorARB target clamp
#ifdef GLW_DEBUG
    logGLCommandEnd "glClampColorARB" (LogV'Void)
#endif
    return _result

glClear :: MonadIO m => ClearBufferMask -> m ()
glClear mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClear" [LogV'GLbitfield mask]
#endif
    _result <- GL.glClear (coerce mask)
#ifdef GLW_DEBUG
    logGLCommandEnd "glClear" (LogV'Void)
#endif
    return _result

glClearBufferData :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearBufferData target internalformat format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferData" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearBufferData target internalformat format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferData" (LogV'Void)
#endif
    return _result

glClearBufferSubData :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearBufferSubData target internalformat offset size format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferSubData" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearBufferSubData target internalformat offset size format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferSubData" (LogV'Void)
#endif
    return _result

glClearBufferfi :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLfloat -> GL.GLint -> m ()
glClearBufferfi buffer drawbuffer depth stencil = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferfi" [LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'GLfloat depth, LogV'GLint stencil]
#endif
    _result <- GL.glClearBufferfi buffer drawbuffer depth stencil
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferfi" (LogV'Void)
#endif
    return _result

glClearBufferfv :: MonadIO m => GL.GLenum -> GL.GLint -> Ptr GL.GLfloat -> m ()
glClearBufferfv buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferfv" [LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearBufferfv buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferfv" (LogV'Void)
#endif
    return _result

glClearBufferiv :: MonadIO m => GL.GLenum -> GL.GLint -> Ptr GL.GLint -> m ()
glClearBufferiv buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferiv" [LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearBufferiv buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferiv" (LogV'Void)
#endif
    return _result

glClearBufferuiv :: MonadIO m => GL.GLenum -> GL.GLint -> Ptr GL.GLuint -> m ()
glClearBufferuiv buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearBufferuiv" [LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearBufferuiv buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearBufferuiv" (LogV'Void)
#endif
    return _result

glClearColor :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glClearColor red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearColor" [LogV'GLfloat red, LogV'GLfloat green, LogV'GLfloat blue, LogV'GLfloat alpha]
#endif
    _result <- GL.glClearColor red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearColor" (LogV'Void)
#endif
    return _result

glClearColorIiEXT :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glClearColorIiEXT red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearColorIiEXT" [LogV'GLint red, LogV'GLint green, LogV'GLint blue, LogV'GLint alpha]
#endif
    _result <- GL.glClearColorIiEXT red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearColorIiEXT" (LogV'Void)
#endif
    return _result

glClearColorIuiEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glClearColorIuiEXT red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearColorIuiEXT" [LogV'GLuint red, LogV'GLuint green, LogV'GLuint blue, LogV'GLuint alpha]
#endif
    _result <- GL.glClearColorIuiEXT red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearColorIuiEXT" (LogV'Void)
#endif
    return _result

glClearDepth :: MonadIO m => GL.GLdouble -> m ()
glClearDepth depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearDepth" [LogV'GLdouble depth]
#endif
    _result <- GL.glClearDepth depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearDepth" (LogV'Void)
#endif
    return _result

glClearDepthdNV :: MonadIO m => GL.GLdouble -> m ()
glClearDepthdNV depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearDepthdNV" [LogV'GLdouble depth]
#endif
    _result <- GL.glClearDepthdNV depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearDepthdNV" (LogV'Void)
#endif
    return _result

glClearDepthf :: MonadIO m => GL.GLfloat -> m ()
glClearDepthf d = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearDepthf" [LogV'GLfloat d]
#endif
    _result <- GL.glClearDepthf d
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearDepthf" (LogV'Void)
#endif
    return _result

glClearNamedBufferData :: MonadIO m => Buffer -> GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearNamedBufferData buffer internalformat format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedBufferData" [LogV'GLuint buffer, LogV'GLenum internalformat, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearNamedBufferData (coerce buffer) internalformat format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedBufferData" (LogV'Void)
#endif
    return _result

glClearNamedBufferDataEXT :: MonadIO m => Buffer -> GL.GLenum -> PixelFormat -> PixelType -> Ptr () -> m ()
glClearNamedBufferDataEXT buffer internalformat format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedBufferDataEXT" [LogV'GLuint buffer, LogV'GLenum internalformat, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearNamedBufferDataEXT (coerce buffer) internalformat (coerce format) (coerce type') data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedBufferDataEXT" (LogV'Void)
#endif
    return _result

glClearNamedBufferSubData :: MonadIO m => Buffer -> GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearNamedBufferSubData buffer internalformat offset size format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedBufferSubData" [LogV'GLuint buffer, LogV'GLenum internalformat, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearNamedBufferSubData (coerce buffer) internalformat offset size format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedBufferSubData" (LogV'Void)
#endif
    return _result

glClearNamedBufferSubDataEXT :: MonadIO m => Buffer -> GL.GLenum -> GL.GLsizeiptr -> GL.GLsizeiptr -> PixelFormat -> PixelType -> Ptr () -> m ()
glClearNamedBufferSubDataEXT buffer internalformat offset size format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedBufferSubDataEXT" [LogV'GLuint buffer, LogV'GLenum internalformat, LogV'GLsizeiptr offset, LogV'GLsizeiptr size, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearNamedBufferSubDataEXT (coerce buffer) internalformat offset size (coerce format) (coerce type') data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedBufferSubDataEXT" (LogV'Void)
#endif
    return _result

glClearNamedFramebufferfi :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> GL.GLfloat -> GL.GLint -> m ()
glClearNamedFramebufferfi framebuffer buffer drawbuffer depth stencil = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedFramebufferfi" [LogV'GLuint framebuffer, LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'GLfloat depth, LogV'GLint stencil]
#endif
    _result <- GL.glClearNamedFramebufferfi (coerce framebuffer) buffer drawbuffer depth stencil
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedFramebufferfi" (LogV'Void)
#endif
    return _result

glClearNamedFramebufferfv :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> Ptr GL.GLfloat -> m ()
glClearNamedFramebufferfv framebuffer buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedFramebufferfv" [LogV'GLuint framebuffer, LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearNamedFramebufferfv (coerce framebuffer) buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedFramebufferfv" (LogV'Void)
#endif
    return _result

glClearNamedFramebufferiv :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> Ptr GL.GLint -> m ()
glClearNamedFramebufferiv framebuffer buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedFramebufferiv" [LogV'GLuint framebuffer, LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearNamedFramebufferiv (coerce framebuffer) buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedFramebufferiv" (LogV'Void)
#endif
    return _result

glClearNamedFramebufferuiv :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> Ptr GL.GLuint -> m ()
glClearNamedFramebufferuiv framebuffer buffer drawbuffer value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearNamedFramebufferuiv" [LogV'GLuint framebuffer, LogV'GLenum buffer, LogV'GLint drawbuffer, LogV'Ptr]
#endif
    _result <- GL.glClearNamedFramebufferuiv (coerce framebuffer) buffer drawbuffer value
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearNamedFramebufferuiv" (LogV'Void)
#endif
    return _result

glClearStencil :: MonadIO m => GL.GLint -> m ()
glClearStencil s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearStencil" [LogV'GLint s]
#endif
    _result <- GL.glClearStencil s
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearStencil" (LogV'Void)
#endif
    return _result

glClearTexImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearTexImage texture level format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearTexImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearTexImage (coerce texture) level format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearTexImage" (LogV'Void)
#endif
    return _result

glClearTexSubImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glClearTexSubImage texture level xoffset yoffset zoffset width height depth format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClearTexSubImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glClearTexSubImage (coerce texture) level xoffset yoffset zoffset width height depth format type' data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glClearTexSubImage" (LogV'Void)
#endif
    return _result

glClientActiveTextureARB :: MonadIO m => TextureUnit -> m ()
glClientActiveTextureARB texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClientActiveTextureARB" [LogV'GLenum texture]
#endif
    _result <- GL.glClientActiveTextureARB (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glClientActiveTextureARB" (LogV'Void)
#endif
    return _result

glClientActiveVertexStreamATI :: MonadIO m => GL.GLenum -> m ()
glClientActiveVertexStreamATI stream = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClientActiveVertexStreamATI" [LogV'GLenum stream]
#endif
    _result <- GL.glClientActiveVertexStreamATI stream
#ifdef GLW_DEBUG
    logGLCommandEnd "glClientActiveVertexStreamATI" (LogV'Void)
#endif
    return _result

glClientAttribDefaultEXT :: MonadIO m => ClientAttribMask -> m ()
glClientAttribDefaultEXT mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClientAttribDefaultEXT" [LogV'GLbitfield mask]
#endif
    _result <- GL.glClientAttribDefaultEXT (coerce mask)
#ifdef GLW_DEBUG
    logGLCommandEnd "glClientAttribDefaultEXT" (LogV'Void)
#endif
    return _result

glClientWaitSync :: MonadIO m => GL.GLsync -> GL.GLbitfield -> GL.GLuint64 -> m GL.GLenum
glClientWaitSync sync flags timeout = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClientWaitSync" [LogV'GLsync sync, LogV'GLbitfield flags, LogV'GLuint64 timeout]
#endif
    _result <- GL.glClientWaitSync sync flags timeout
#ifdef GLW_DEBUG
    logGLCommandEnd "glClientWaitSync" (LogV'GLenum _result)
#endif
    return _result

glClipControl :: MonadIO m => GL.GLenum -> GL.GLenum -> m ()
glClipControl origin depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glClipControl" [LogV'GLenum origin, LogV'GLenum depth]
#endif
    _result <- GL.glClipControl origin depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glClipControl" (LogV'Void)
#endif
    return _result

glColor3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glColor3fVertex3fSUN r g b x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor3fVertex3fSUN" [LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glColor3fVertex3fSUN r g b x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glColor3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glColor3fVertex3fvSUN c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glColor3fVertex3fvSUN c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glColor3hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glColor3hNV red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor3hNV" [LogV'GLhalfNV red, LogV'GLhalfNV green, LogV'GLhalfNV blue]
#endif
    _result <- GL.glColor3hNV red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor3hNV" (LogV'Void)
#endif
    return _result

glColor3hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glColor3hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor3hvNV" [LogV'Ptr]
#endif
    _result <- GL.glColor3hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor3hvNV" (LogV'Void)
#endif
    return _result

glColor4fNormal3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glColor4fNormal3fVertex3fSUN r g b a nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4fNormal3fVertex3fSUN" [LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat a, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glColor4fNormal3fVertex3fSUN r g b a nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glColor4fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glColor4fNormal3fVertex3fvSUN c n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glColor4fNormal3fVertex3fvSUN c n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glColor4hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glColor4hNV red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4hNV" [LogV'GLhalfNV red, LogV'GLhalfNV green, LogV'GLhalfNV blue, LogV'GLhalfNV alpha]
#endif
    _result <- GL.glColor4hNV red green blue alpha
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4hNV" (LogV'Void)
#endif
    return _result

glColor4hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glColor4hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4hvNV" [LogV'Ptr]
#endif
    _result <- GL.glColor4hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4hvNV" (LogV'Void)
#endif
    return _result

glColor4ubVertex2fSUN :: MonadIO m => GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLfloat -> GL.GLfloat -> m ()
glColor4ubVertex2fSUN r g b a x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4ubVertex2fSUN" [LogV'GLubyte r, LogV'GLubyte g, LogV'GLubyte b, LogV'GLubyte a, LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glColor4ubVertex2fSUN r g b a x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4ubVertex2fSUN" (LogV'Void)
#endif
    return _result

glColor4ubVertex2fvSUN :: MonadIO m => Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glColor4ubVertex2fvSUN c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4ubVertex2fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glColor4ubVertex2fvSUN c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4ubVertex2fvSUN" (LogV'Void)
#endif
    return _result

glColor4ubVertex3fSUN :: MonadIO m => GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glColor4ubVertex3fSUN r g b a x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4ubVertex3fSUN" [LogV'GLubyte r, LogV'GLubyte g, LogV'GLubyte b, LogV'GLubyte a, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glColor4ubVertex3fSUN r g b a x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4ubVertex3fSUN" (LogV'Void)
#endif
    return _result

glColor4ubVertex3fvSUN :: MonadIO m => Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glColor4ubVertex3fvSUN c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColor4ubVertex3fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glColor4ubVertex3fvSUN c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glColor4ubVertex3fvSUN" (LogV'Void)
#endif
    return _result

glColorFormatNV :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glColorFormatNV size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorFormatNV" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glColorFormatNV size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorFormatNV" (LogV'Void)
#endif
    return _result

glColorFragmentOp1ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glColorFragmentOp1ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorFragmentOp1ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMask, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod]
#endif
    _result <- GL.glColorFragmentOp1ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorFragmentOp1ATI" (LogV'Void)
#endif
    return _result

glColorFragmentOp2ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glColorFragmentOp2ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorFragmentOp2ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMask, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod, LogV'GLuint arg2, LogV'GLuint arg2Rep, LogV'GLuint arg2Mod]
#endif
    _result <- GL.glColorFragmentOp2ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorFragmentOp2ATI" (LogV'Void)
#endif
    return _result

glColorFragmentOp3ATI :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glColorFragmentOp3ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod arg3 arg3Rep arg3Mod = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorFragmentOp3ATI" [LogV'GLenum op, LogV'GLuint dst, LogV'GLuint dstMask, LogV'GLuint dstMod, LogV'GLuint arg1, LogV'GLuint arg1Rep, LogV'GLuint arg1Mod, LogV'GLuint arg2, LogV'GLuint arg2Rep, LogV'GLuint arg2Mod, LogV'GLuint arg3, LogV'GLuint arg3Rep, LogV'GLuint arg3Mod]
#endif
    _result <- GL.glColorFragmentOp3ATI op dst dstMask dstMod arg1 arg1Rep arg1Mod arg2 arg2Rep arg2Mod arg3 arg3Rep arg3Mod
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorFragmentOp3ATI" (LogV'Void)
#endif
    return _result

glColorMask :: MonadIO m => Boolean -> Boolean -> Boolean -> Boolean -> m ()
glColorMask red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorMask" [LogV'GLboolean red, LogV'GLboolean green, LogV'GLboolean blue, LogV'GLboolean alpha]
#endif
    _result <- GL.glColorMask (coerce red) (coerce green) (coerce blue) (coerce alpha)
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorMask" (LogV'Void)
#endif
    return _result

glColorMaskIndexedEXT :: MonadIO m => GL.GLuint -> Boolean -> Boolean -> Boolean -> Boolean -> m ()
glColorMaskIndexedEXT index r g b a = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorMaskIndexedEXT" [LogV'GLuint index, LogV'GLboolean r, LogV'GLboolean g, LogV'GLboolean b, LogV'GLboolean a]
#endif
    _result <- GL.glColorMaskIndexedEXT index (coerce r) (coerce g) (coerce b) (coerce a)
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorMaskIndexedEXT" (LogV'Void)
#endif
    return _result

glColorMaski :: MonadIO m => GL.GLuint -> Boolean -> Boolean -> Boolean -> Boolean -> m ()
glColorMaski index r g b a = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorMaski" [LogV'GLuint index, LogV'GLboolean r, LogV'GLboolean g, LogV'GLboolean b, LogV'GLboolean a]
#endif
    _result <- GL.glColorMaski index (coerce r) (coerce g) (coerce b) (coerce a)
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorMaski" (LogV'Void)
#endif
    return _result

glColorP3ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glColorP3ui type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorP3ui" [LogV'GLenum type', LogV'GLuint color]
#endif
    _result <- GL.glColorP3ui type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorP3ui" (LogV'Void)
#endif
    return _result

glColorP3uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glColorP3uiv type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorP3uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorP3uiv type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorP3uiv" (LogV'Void)
#endif
    return _result

glColorP4ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glColorP4ui type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorP4ui" [LogV'GLenum type', LogV'GLuint color]
#endif
    _result <- GL.glColorP4ui type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorP4ui" (LogV'Void)
#endif
    return _result

glColorP4uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glColorP4uiv type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorP4uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorP4uiv type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorP4uiv" (LogV'Void)
#endif
    return _result

glColorPointerEXT :: MonadIO m => GL.GLint -> ColorPointerType -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glColorPointerEXT size type' stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorPointerEXT" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glColorPointerEXT size (coerce type') stride count pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorPointerEXT" (LogV'Void)
#endif
    return _result

glColorPointerListIBM :: MonadIO m => GL.GLint -> ColorPointerType -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glColorPointerListIBM size type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorPointerListIBM" [LogV'GLint size, LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glColorPointerListIBM size (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorPointerListIBM" (LogV'Void)
#endif
    return _result

glColorPointervINTEL :: MonadIO m => GL.GLint -> VertexPointerType -> Ptr (Ptr ()) -> m ()
glColorPointervINTEL size type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorPointervINTEL" [LogV'GLint size, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorPointervINTEL size (coerce type') pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorPointervINTEL" (LogV'Void)
#endif
    return _result

glColorSubTableEXT :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glColorSubTableEXT target start count format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorSubTableEXT" [LogV'GLenum target, LogV'GLsizei start, LogV'GLsizei count, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorSubTableEXT target start count (coerce format) (coerce type') data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorSubTableEXT" (LogV'Void)
#endif
    return _result

glColorTableEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glColorTableEXT target internalFormat width format type' table = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorTableEXT" [LogV'GLenum target, LogV'GLenum internalFormat, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorTableEXT target internalFormat width (coerce format) (coerce type') table
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorTableEXT" (LogV'Void)
#endif
    return _result

glColorTableParameterfvSGI :: MonadIO m => ColorTableTargetSGI -> ColorTableParameterPNameSGI -> Ptr GL.GLfloat -> m ()
glColorTableParameterfvSGI target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorTableParameterfvSGI" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glColorTableParameterfvSGI (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorTableParameterfvSGI" (LogV'Void)
#endif
    return _result

glColorTableParameterivSGI :: MonadIO m => ColorTableTargetSGI -> ColorTableParameterPNameSGI -> Ptr GL.GLint -> m ()
glColorTableParameterivSGI target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorTableParameterivSGI" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glColorTableParameterivSGI (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorTableParameterivSGI" (LogV'Void)
#endif
    return _result

glColorTableSGI :: MonadIO m => ColorTableTargetSGI -> GL.GLenum -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glColorTableSGI target internalformat width format type' table = do
#ifdef GLW_DEBUG
    logGLCommandStart "glColorTableSGI" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glColorTableSGI (coerce target) internalformat width (coerce format) (coerce type') table
#ifdef GLW_DEBUG
    logGLCommandEnd "glColorTableSGI" (LogV'Void)
#endif
    return _result

glCombinerInputNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glCombinerInputNV stage portion variable input mapping componentUsage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerInputNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum variable, LogV'GLenum input, LogV'GLenum mapping, LogV'GLenum componentUsage]
#endif
    _result <- GL.glCombinerInputNV stage portion variable input mapping componentUsage
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerInputNV" (LogV'Void)
#endif
    return _result

glCombinerOutputNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> Boolean -> Boolean -> Boolean -> m ()
glCombinerOutputNV stage portion abOutput cdOutput sumOutput scale bias abDotProduct cdDotProduct muxSum = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerOutputNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum abOutput, LogV'GLenum cdOutput, LogV'GLenum sumOutput, LogV'GLenum scale, LogV'GLenum bias, LogV'GLboolean abDotProduct, LogV'GLboolean cdDotProduct, LogV'GLboolean muxSum]
#endif
    _result <- GL.glCombinerOutputNV stage portion abOutput cdOutput sumOutput scale bias (coerce abDotProduct) (coerce cdDotProduct) (coerce muxSum)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerOutputNV" (LogV'Void)
#endif
    return _result

glCombinerParameterfNV :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glCombinerParameterfNV pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerParameterfNV" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glCombinerParameterfNV pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerParameterfNV" (LogV'Void)
#endif
    return _result

glCombinerParameterfvNV :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glCombinerParameterfvNV pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerParameterfvNV" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glCombinerParameterfvNV pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerParameterfvNV" (LogV'Void)
#endif
    return _result

glCombinerParameteriNV :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glCombinerParameteriNV pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerParameteriNV" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glCombinerParameteriNV pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerParameteriNV" (LogV'Void)
#endif
    return _result

glCombinerParameterivNV :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glCombinerParameterivNV pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerParameterivNV" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glCombinerParameterivNV pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerParameterivNV" (LogV'Void)
#endif
    return _result

glCombinerStageParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glCombinerStageParameterfvNV stage pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCombinerStageParameterfvNV" [LogV'GLenum stage, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glCombinerStageParameterfvNV stage pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glCombinerStageParameterfvNV" (LogV'Void)
#endif
    return _result

glCommandListSegmentsNV :: MonadIO m => GL.GLuint -> GL.GLuint -> m ()
glCommandListSegmentsNV list segments = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCommandListSegmentsNV" [LogV'GLuint list, LogV'GLuint segments]
#endif
    _result <- GL.glCommandListSegmentsNV list segments
#ifdef GLW_DEBUG
    logGLCommandEnd "glCommandListSegmentsNV" (LogV'Void)
#endif
    return _result

glCompileCommandListNV :: MonadIO m => GL.GLuint -> m ()
glCompileCommandListNV list = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompileCommandListNV" [LogV'GLuint list]
#endif
    _result <- GL.glCompileCommandListNV list
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompileCommandListNV" (LogV'Void)
#endif
    return _result

glCompileShader :: MonadIO m => Shader (a :: ShaderType) -> m ()
glCompileShader shader = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompileShader" [LogV'GLuint shader]
#endif
    _result <- GL.glCompileShader (coerce shader)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompileShader" (LogV'Void)
#endif
    return _result

glCompileShaderARB :: MonadIO m => GL.GLhandleARB -> m ()
glCompileShaderARB shaderObj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompileShaderARB" [LogV'GLhandleARB shaderObj]
#endif
    _result <- GL.glCompileShaderARB shaderObj
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompileShaderARB" (LogV'Void)
#endif
    return _result

glCompressedMultiTexImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexImage1DEXT texunit target level internalformat width border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexImage1DEXT (coerce texunit) (coerce target) level internalformat width border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexImage1DEXT" (LogV'Void)
#endif
    return _result

glCompressedMultiTexImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexImage2DEXT texunit target level internalformat width height border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexImage2DEXT (coerce texunit) (coerce target) level internalformat width height border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexImage2DEXT" (LogV'Void)
#endif
    return _result

glCompressedMultiTexImage3DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexImage3DEXT texunit target level internalformat width height depth border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexImage3DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexImage3DEXT (coerce texunit) (coerce target) level internalformat width height depth border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexImage3DEXT" (LogV'Void)
#endif
    return _result

glCompressedMultiTexSubImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexSubImage1DEXT texunit target level xoffset width format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexSubImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexSubImage1DEXT (coerce texunit) (coerce target) level xoffset width (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexSubImage1DEXT" (LogV'Void)
#endif
    return _result

glCompressedMultiTexSubImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexSubImage2DEXT texunit target level xoffset yoffset width height format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexSubImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexSubImage2DEXT (coerce texunit) (coerce target) level xoffset yoffset width height (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexSubImage2DEXT" (LogV'Void)
#endif
    return _result

glCompressedMultiTexSubImage3DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedMultiTexSubImage3DEXT texunit target level xoffset yoffset zoffset width height depth format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedMultiTexSubImage3DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedMultiTexSubImage3DEXT (coerce texunit) (coerce target) level xoffset yoffset zoffset width height depth (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedMultiTexSubImage3DEXT" (LogV'Void)
#endif
    return _result

glCompressedTexImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage1D target level internalformat width border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage1D (coerce target) level internalformat width border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage1D" (LogV'Void)
#endif
    return _result

glCompressedTexImage1DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage1DARB target level internalformat width border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage1DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage1DARB (coerce target) level internalformat width border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage1DARB" (LogV'Void)
#endif
    return _result

glCompressedTexImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage2D target level internalformat width height border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage2D (coerce target) level internalformat width height border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage2D" (LogV'Void)
#endif
    return _result

glCompressedTexImage2DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage2DARB target level internalformat width height border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage2DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage2DARB (coerce target) level internalformat width height border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage2DARB" (LogV'Void)
#endif
    return _result

glCompressedTexImage3D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage3D target level internalformat width height depth border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage3D" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage3D (coerce target) level internalformat width height depth border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage3D" (LogV'Void)
#endif
    return _result

glCompressedTexImage3DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexImage3DARB target level internalformat width height depth border imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexImage3DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexImage3DARB (coerce target) level internalformat width height depth border imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexImage3DARB" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage1D target level xoffset width format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage1D (coerce target) level xoffset width (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage1D" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage1DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage1DARB target level xoffset width format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage1DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage1DARB (coerce target) level xoffset width (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage1DARB" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage2D target level xoffset yoffset width height format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage2D (coerce target) level xoffset yoffset width height (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage2D" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage2DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage2DARB target level xoffset yoffset width height format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage2DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage2DARB (coerce target) level xoffset yoffset width height (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage2DARB" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage3D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage3D target level xoffset yoffset zoffset width height depth format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage3D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage3D (coerce target) level xoffset yoffset zoffset width height depth (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage3D" (LogV'Void)
#endif
    return _result

glCompressedTexSubImage3DARB :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTexSubImage3DARB target level xoffset yoffset zoffset width height depth format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTexSubImage3DARB" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTexSubImage3DARB (coerce target) level xoffset yoffset zoffset width height depth (coerce format) imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTexSubImage3DARB" (LogV'Void)
#endif
    return _result

glCompressedTextureImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureImage1DEXT texture target level internalformat width border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureImage1DEXT (coerce texture) (coerce target) level internalformat width border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureImage1DEXT" (LogV'Void)
#endif
    return _result

glCompressedTextureImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureImage2DEXT texture target level internalformat width height border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureImage2DEXT (coerce texture) (coerce target) level internalformat width height border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureImage2DEXT" (LogV'Void)
#endif
    return _result

glCompressedTextureImage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureImage3DEXT texture target level internalformat width height depth border imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureImage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureImage3DEXT (coerce texture) (coerce target) level internalformat width height depth border imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureImage3DEXT" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage1D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage1D texture level xoffset width format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage1D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage1D (coerce texture) level xoffset width format imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage1D" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage1DEXT texture target level xoffset width format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage1DEXT (coerce texture) (coerce target) level xoffset width (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage1DEXT" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage2D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage2D texture level xoffset yoffset width height format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage2D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage2D (coerce texture) level xoffset yoffset width height format imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage2D" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage2DEXT texture target level xoffset yoffset width height format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage2DEXT (coerce texture) (coerce target) level xoffset yoffset width height (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage2DEXT" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage3D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage3D texture level xoffset yoffset zoffset width height depth format imageSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage3D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage3D (coerce texture) level xoffset yoffset zoffset width height depth format imageSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage3D" (LogV'Void)
#endif
    return _result

glCompressedTextureSubImage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> GL.GLsizei -> Ptr () -> m ()
glCompressedTextureSubImage3DEXT texture target level xoffset yoffset zoffset width height depth format imageSize bits = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCompressedTextureSubImage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLsizei imageSize, LogV'Ptr]
#endif
    _result <- GL.glCompressedTextureSubImage3DEXT (coerce texture) (coerce target) level xoffset yoffset zoffset width height depth (coerce format) imageSize bits
#ifdef GLW_DEBUG
    logGLCommandEnd "glCompressedTextureSubImage3DEXT" (LogV'Void)
#endif
    return _result

glConservativeRasterParameterfNV :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glConservativeRasterParameterfNV pname value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConservativeRasterParameterfNV" [LogV'GLenum pname, LogV'GLfloat value]
#endif
    _result <- GL.glConservativeRasterParameterfNV pname value
#ifdef GLW_DEBUG
    logGLCommandEnd "glConservativeRasterParameterfNV" (LogV'Void)
#endif
    return _result

glConvolutionFilter1DEXT :: MonadIO m => ConvolutionTargetEXT -> GL.GLenum -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glConvolutionFilter1DEXT target internalformat width format type' image = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionFilter1DEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glConvolutionFilter1DEXT (coerce target) internalformat width (coerce format) (coerce type') image
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionFilter1DEXT" (LogV'Void)
#endif
    return _result

glConvolutionFilter2DEXT :: MonadIO m => ConvolutionTargetEXT -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glConvolutionFilter2DEXT target internalformat width height format type' image = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionFilter2DEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glConvolutionFilter2DEXT (coerce target) internalformat width height (coerce format) (coerce type') image
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionFilter2DEXT" (LogV'Void)
#endif
    return _result

glConvolutionParameterfEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> GL.GLfloat -> m ()
glConvolutionParameterfEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionParameterfEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat params]
#endif
    _result <- GL.glConvolutionParameterfEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionParameterfEXT" (LogV'Void)
#endif
    return _result

glConvolutionParameterfvEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> Ptr GL.GLfloat -> m ()
glConvolutionParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glConvolutionParameterfvEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionParameterfvEXT" (LogV'Void)
#endif
    return _result

glConvolutionParameteriEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> GL.GLint -> m ()
glConvolutionParameteriEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionParameteriEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint params]
#endif
    _result <- GL.glConvolutionParameteriEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionParameteriEXT" (LogV'Void)
#endif
    return _result

glConvolutionParameterivEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> Ptr GL.GLint -> m ()
glConvolutionParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glConvolutionParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glConvolutionParameterivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glConvolutionParameterivEXT" (LogV'Void)
#endif
    return _result

glCopyBufferSubData :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLintptr -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glCopyBufferSubData readTarget writeTarget readOffset writeOffset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyBufferSubData" [LogV'GLenum readTarget, LogV'GLenum writeTarget, LogV'GLintptr readOffset, LogV'GLintptr writeOffset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glCopyBufferSubData readTarget writeTarget readOffset writeOffset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyBufferSubData" (LogV'Void)
#endif
    return _result

glCopyColorSubTableEXT :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyColorSubTableEXT target start x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyColorSubTableEXT" [LogV'GLenum target, LogV'GLsizei start, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyColorSubTableEXT target start x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyColorSubTableEXT" (LogV'Void)
#endif
    return _result

glCopyColorTableSGI :: MonadIO m => ColorTableTargetSGI -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyColorTableSGI target internalformat x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyColorTableSGI" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyColorTableSGI (coerce target) internalformat x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyColorTableSGI" (LogV'Void)
#endif
    return _result

glCopyConvolutionFilter1DEXT :: MonadIO m => ConvolutionTargetEXT -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyConvolutionFilter1DEXT target internalformat x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyConvolutionFilter1DEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyConvolutionFilter1DEXT (coerce target) internalformat x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyConvolutionFilter1DEXT" (LogV'Void)
#endif
    return _result

glCopyConvolutionFilter2DEXT :: MonadIO m => ConvolutionTargetEXT -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyConvolutionFilter2DEXT target internalformat x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyConvolutionFilter2DEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyConvolutionFilter2DEXT (coerce target) internalformat x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyConvolutionFilter2DEXT" (LogV'Void)
#endif
    return _result

glCopyImageSubData :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLuint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyImageSubData srcName srcTarget srcLevel srcX srcY srcZ dstName dstTarget dstLevel dstX dstY dstZ srcWidth srcHeight srcDepth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyImageSubData" [LogV'GLuint srcName, LogV'GLenum srcTarget, LogV'GLint srcLevel, LogV'GLint srcX, LogV'GLint srcY, LogV'GLint srcZ, LogV'GLuint dstName, LogV'GLenum dstTarget, LogV'GLint dstLevel, LogV'GLint dstX, LogV'GLint dstY, LogV'GLint dstZ, LogV'GLsizei srcWidth, LogV'GLsizei srcHeight, LogV'GLsizei srcDepth]
#endif
    _result <- GL.glCopyImageSubData srcName srcTarget srcLevel srcX srcY srcZ dstName dstTarget dstLevel dstX dstY dstZ srcWidth srcHeight srcDepth
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyImageSubData" (LogV'Void)
#endif
    return _result

glCopyImageSubDataNV :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLuint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyImageSubDataNV srcName srcTarget srcLevel srcX srcY srcZ dstName dstTarget dstLevel dstX dstY dstZ width height depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyImageSubDataNV" [LogV'GLuint srcName, LogV'GLenum srcTarget, LogV'GLint srcLevel, LogV'GLint srcX, LogV'GLint srcY, LogV'GLint srcZ, LogV'GLuint dstName, LogV'GLenum dstTarget, LogV'GLint dstLevel, LogV'GLint dstX, LogV'GLint dstY, LogV'GLint dstZ, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth]
#endif
    _result <- GL.glCopyImageSubDataNV srcName srcTarget srcLevel srcX srcY srcZ dstName dstTarget dstLevel dstX dstY dstZ width height depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyImageSubDataNV" (LogV'Void)
#endif
    return _result

glCopyMultiTexImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> m ()
glCopyMultiTexImage1DEXT texunit target level internalformat x y width border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyMultiTexImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLint border]
#endif
    _result <- GL.glCopyMultiTexImage1DEXT (coerce texunit) (coerce target) level internalformat x y width border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyMultiTexImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyMultiTexImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glCopyMultiTexImage2DEXT texunit target level internalformat x y width height border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyMultiTexImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border]
#endif
    _result <- GL.glCopyMultiTexImage2DEXT (coerce texunit) (coerce target) level internalformat x y width height border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyMultiTexImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyMultiTexSubImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyMultiTexSubImage1DEXT texunit target level xoffset x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyMultiTexSubImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyMultiTexSubImage1DEXT (coerce texunit) (coerce target) level xoffset x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyMultiTexSubImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyMultiTexSubImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyMultiTexSubImage2DEXT texunit target level xoffset yoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyMultiTexSubImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyMultiTexSubImage2DEXT (coerce texunit) (coerce target) level xoffset yoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyMultiTexSubImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyMultiTexSubImage3DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyMultiTexSubImage3DEXT texunit target level xoffset yoffset zoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyMultiTexSubImage3DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyMultiTexSubImage3DEXT (coerce texunit) (coerce target) level xoffset yoffset zoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyMultiTexSubImage3DEXT" (LogV'Void)
#endif
    return _result

glCopyNamedBufferSubData :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLintptr -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glCopyNamedBufferSubData readBuffer writeBuffer readOffset writeOffset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyNamedBufferSubData" [LogV'GLuint readBuffer, LogV'GLuint writeBuffer, LogV'GLintptr readOffset, LogV'GLintptr writeOffset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glCopyNamedBufferSubData readBuffer writeBuffer readOffset writeOffset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyNamedBufferSubData" (LogV'Void)
#endif
    return _result

glCopyTexImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> m ()
glCopyTexImage1D target level internalformat x y width border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLint border]
#endif
    _result <- GL.glCopyTexImage1D (coerce target) level internalformat x y width border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexImage1D" (LogV'Void)
#endif
    return _result

glCopyTexImage1DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> m ()
glCopyTexImage1DEXT target level internalformat x y width border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexImage1DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLint border]
#endif
    _result <- GL.glCopyTexImage1DEXT (coerce target) level internalformat x y width border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyTexImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glCopyTexImage2D target level internalformat x y width height border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border]
#endif
    _result <- GL.glCopyTexImage2D (coerce target) level internalformat x y width height border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexImage2D" (LogV'Void)
#endif
    return _result

glCopyTexImage2DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glCopyTexImage2DEXT target level internalformat x y width height border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexImage2DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border]
#endif
    _result <- GL.glCopyTexImage2DEXT (coerce target) level internalformat x y width height border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyTexSubImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyTexSubImage1D target level xoffset x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyTexSubImage1D (coerce target) level xoffset x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage1D" (LogV'Void)
#endif
    return _result

glCopyTexSubImage1DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyTexSubImage1DEXT target level xoffset x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage1DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyTexSubImage1DEXT (coerce target) level xoffset x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyTexSubImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTexSubImage2D target level xoffset yoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTexSubImage2D (coerce target) level xoffset yoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage2D" (LogV'Void)
#endif
    return _result

glCopyTexSubImage2DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTexSubImage2DEXT target level xoffset yoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage2DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTexSubImage2DEXT (coerce target) level xoffset yoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyTexSubImage3D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTexSubImage3D target level xoffset yoffset zoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage3D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTexSubImage3D (coerce target) level xoffset yoffset zoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage3D" (LogV'Void)
#endif
    return _result

glCopyTexSubImage3DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTexSubImage3DEXT target level xoffset yoffset zoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTexSubImage3DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTexSubImage3DEXT (coerce target) level xoffset yoffset zoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTexSubImage3DEXT" (LogV'Void)
#endif
    return _result

glCopyTextureImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> m ()
glCopyTextureImage1DEXT texture target level internalformat x y width border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLint border]
#endif
    _result <- GL.glCopyTextureImage1DEXT (coerce texture) (coerce target) level internalformat x y width border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyTextureImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glCopyTextureImage2DEXT texture target level internalformat x y width height border = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border]
#endif
    _result <- GL.glCopyTextureImage2DEXT (coerce texture) (coerce target) level internalformat x y width height border
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage1D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyTextureSubImage1D texture level xoffset x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage1D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyTextureSubImage1D (coerce texture) level xoffset x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage1D" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> m ()
glCopyTextureSubImage1DEXT texture target level xoffset x y width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width]
#endif
    _result <- GL.glCopyTextureSubImage1DEXT (coerce texture) (coerce target) level xoffset x y width
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage1DEXT" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage2D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTextureSubImage2D texture level xoffset yoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage2D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTextureSubImage2D (coerce texture) level xoffset yoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage2D" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTextureSubImage2DEXT texture target level xoffset yoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTextureSubImage2DEXT (coerce texture) (coerce target) level xoffset yoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage2DEXT" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage3D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTextureSubImage3D texture level xoffset yoffset zoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage3D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTextureSubImage3D (coerce texture) level xoffset yoffset zoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage3D" (LogV'Void)
#endif
    return _result

glCopyTextureSubImage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glCopyTextureSubImage3DEXT texture target level xoffset yoffset zoffset x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCopyTextureSubImage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glCopyTextureSubImage3DEXT (coerce texture) (coerce target) level xoffset yoffset zoffset x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glCopyTextureSubImage3DEXT" (LogV'Void)
#endif
    return _result

glCreateBuffers :: MonadIO m => GL.GLsizei -> Ptr Buffer -> m ()
glCreateBuffers n buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateBuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateBuffers n (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateBuffers" (LogV'Void)
#endif
    return _result

glCreateCommandListsNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glCreateCommandListsNV n lists = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateCommandListsNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateCommandListsNV n lists
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateCommandListsNV" (LogV'Void)
#endif
    return _result

glCreateFramebuffers :: MonadIO m => GL.GLsizei -> Ptr Framebuffer -> m ()
glCreateFramebuffers n framebuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateFramebuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateFramebuffers n (coerce framebuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateFramebuffers" (LogV'Void)
#endif
    return _result

glCreateProgram :: MonadIO m => m Program
glCreateProgram  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateProgram" []
#endif
    _result <- coerce <$> GL.glCreateProgram 
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateProgram" (LogV'GLuint _result)
#endif
    return _result

glCreateProgramObjectARB :: MonadIO m => m GL.GLhandleARB
glCreateProgramObjectARB  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateProgramObjectARB" []
#endif
    _result <- GL.glCreateProgramObjectARB 
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateProgramObjectARB" (LogV'GLhandleARB _result)
#endif
    return _result

glCreateProgramPipelines :: MonadIO m => GL.GLsizei -> Ptr ProgramPipeline -> m ()
glCreateProgramPipelines n pipelines = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateProgramPipelines" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateProgramPipelines n (coerce pipelines)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateProgramPipelines" (LogV'Void)
#endif
    return _result

glCreateQueries :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr (Query (a :: QueryTarget)) -> m ()
glCreateQueries target n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateQueries" [LogV'GLenum target, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateQueries target n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateQueries" (LogV'Void)
#endif
    return _result

glCreateRenderbuffers :: MonadIO m => GL.GLsizei -> Ptr Renderbuffer -> m ()
glCreateRenderbuffers n renderbuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateRenderbuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateRenderbuffers n (coerce renderbuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateRenderbuffers" (LogV'Void)
#endif
    return _result

glCreateSamplers :: MonadIO m => GL.GLsizei -> Ptr Sampler -> m ()
glCreateSamplers n samplers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateSamplers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateSamplers n (coerce samplers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateSamplers" (LogV'Void)
#endif
    return _result

glCreateShader :: MonadIO m => GL.GLenum -> m (Shader (a :: ShaderType))
glCreateShader type' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateShader" [LogV'GLenum type']
#endif
    _result <- coerce <$> GL.glCreateShader type'
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateShader" (LogV'GLuint _result)
#endif
    return _result

glCreateShaderObjectARB :: MonadIO m => GL.GLenum -> m GL.GLhandleARB
glCreateShaderObjectARB shaderType = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateShaderObjectARB" [LogV'GLenum shaderType]
#endif
    _result <- GL.glCreateShaderObjectARB shaderType
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateShaderObjectARB" (LogV'GLhandleARB _result)
#endif
    return _result

glCreateShaderProgramv :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr (Ptr GL.GLchar) -> m GL.GLuint
glCreateShaderProgramv type' count strings = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateShaderProgramv" [LogV'GLenum type', LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glCreateShaderProgramv type' count strings
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateShaderProgramv" (LogV'GLuint _result)
#endif
    return _result

glCreateStatesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glCreateStatesNV n states = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateStatesNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateStatesNV n states
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateStatesNV" (LogV'Void)
#endif
    return _result

glCreateTextures :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glCreateTextures target n textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateTextures" [LogV'GLenum target, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateTextures target n (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateTextures" (LogV'Void)
#endif
    return _result

glCreateTransformFeedbacks :: MonadIO m => GL.GLsizei -> Ptr TransformFeedback -> m ()
glCreateTransformFeedbacks n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateTransformFeedbacks" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateTransformFeedbacks n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateTransformFeedbacks" (LogV'Void)
#endif
    return _result

glCreateVertexArrays :: MonadIO m => GL.GLsizei -> Ptr VertexArray -> m ()
glCreateVertexArrays n arrays = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCreateVertexArrays" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glCreateVertexArrays n (coerce arrays)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCreateVertexArrays" (LogV'Void)
#endif
    return _result

glCullFace :: MonadIO m => CullFaceMode -> m ()
glCullFace mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCullFace" [LogV'GLenum mode]
#endif
    _result <- GL.glCullFace (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glCullFace" (LogV'Void)
#endif
    return _result

glCullParameterdvEXT :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glCullParameterdvEXT pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCullParameterdvEXT" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glCullParameterdvEXT pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glCullParameterdvEXT" (LogV'Void)
#endif
    return _result

glCullParameterfvEXT :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glCullParameterfvEXT pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCullParameterfvEXT" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glCullParameterfvEXT pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glCullParameterfvEXT" (LogV'Void)
#endif
    return _result

glCurrentPaletteMatrixARB :: MonadIO m => GL.GLint -> m ()
glCurrentPaletteMatrixARB index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glCurrentPaletteMatrixARB" [LogV'GLint index]
#endif
    _result <- GL.glCurrentPaletteMatrixARB index
#ifdef GLW_DEBUG
    logGLCommandEnd "glCurrentPaletteMatrixARB" (LogV'Void)
#endif
    return _result

glDebugMessageCallback :: MonadIO m => GL.GLDEBUGPROC -> Ptr () -> m ()
glDebugMessageCallback callback userParam = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageCallback" [LogV'GLDEBUGPROC callback, LogV'Ptr]
#endif
    _result <- GL.glDebugMessageCallback callback userParam
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageCallback" (LogV'Void)
#endif
    return _result

glDebugMessageCallbackAMD :: MonadIO m => GL.GLDEBUGPROCAMD -> Ptr () -> m ()
glDebugMessageCallbackAMD callback userParam = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageCallbackAMD" [LogV'GLDEBUGPROCAMD callback, LogV'Ptr]
#endif
    _result <- GL.glDebugMessageCallbackAMD callback userParam
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageCallbackAMD" (LogV'Void)
#endif
    return _result

glDebugMessageControl :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> Boolean -> m ()
glDebugMessageControl source type' severity count ids enabled = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageControl" [LogV'GLenum source, LogV'GLenum type', LogV'GLenum severity, LogV'GLsizei count, LogV'Ptr, LogV'GLboolean enabled]
#endif
    _result <- GL.glDebugMessageControl source type' severity count ids (coerce enabled)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageControl" (LogV'Void)
#endif
    return _result

glDebugMessageEnableAMD :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> Boolean -> m ()
glDebugMessageEnableAMD category severity count ids enabled = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageEnableAMD" [LogV'GLenum category, LogV'GLenum severity, LogV'GLsizei count, LogV'Ptr, LogV'GLboolean enabled]
#endif
    _result <- GL.glDebugMessageEnableAMD category severity count ids (coerce enabled)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageEnableAMD" (LogV'Void)
#endif
    return _result

glDebugMessageInsert :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLchar -> m ()
glDebugMessageInsert source type' id severity length buf = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageInsert" [LogV'GLenum source, LogV'GLenum type', LogV'GLuint id, LogV'GLenum severity, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glDebugMessageInsert source type' id severity length buf
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageInsert" (LogV'Void)
#endif
    return _result

glDebugMessageInsertAMD :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLchar -> m ()
glDebugMessageInsertAMD category severity id length buf = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDebugMessageInsertAMD" [LogV'GLenum category, LogV'GLenum severity, LogV'GLuint id, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glDebugMessageInsertAMD category severity id length buf
#ifdef GLW_DEBUG
    logGLCommandEnd "glDebugMessageInsertAMD" (LogV'Void)
#endif
    return _result

glDeformSGIX :: MonadIO m => GL.GLbitfield -> m ()
glDeformSGIX mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeformSGIX" [LogV'GLbitfield mask]
#endif
    _result <- GL.glDeformSGIX mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeformSGIX" (LogV'Void)
#endif
    return _result

glDeformationMap3dSGIX :: MonadIO m => FfdTargetSGIX -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> Ptr GL.GLdouble -> m ()
glDeformationMap3dSGIX target u1 u2 ustride uorder v1 v2 vstride vorder w1 w2 wstride worder points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeformationMap3dSGIX" [LogV'GLenum target, LogV'GLdouble u1, LogV'GLdouble u2, LogV'GLint ustride, LogV'GLint uorder, LogV'GLdouble v1, LogV'GLdouble v2, LogV'GLint vstride, LogV'GLint vorder, LogV'GLdouble w1, LogV'GLdouble w2, LogV'GLint wstride, LogV'GLint worder, LogV'Ptr]
#endif
    _result <- GL.glDeformationMap3dSGIX (coerce target) u1 u2 ustride uorder v1 v2 vstride vorder w1 w2 wstride worder points
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeformationMap3dSGIX" (LogV'Void)
#endif
    return _result

glDeformationMap3fSGIX :: MonadIO m => FfdTargetSGIX -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> Ptr GL.GLfloat -> m ()
glDeformationMap3fSGIX target u1 u2 ustride uorder v1 v2 vstride vorder w1 w2 wstride worder points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeformationMap3fSGIX" [LogV'GLenum target, LogV'GLfloat u1, LogV'GLfloat u2, LogV'GLint ustride, LogV'GLint uorder, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLint vstride, LogV'GLint vorder, LogV'GLfloat w1, LogV'GLfloat w2, LogV'GLint wstride, LogV'GLint worder, LogV'Ptr]
#endif
    _result <- GL.glDeformationMap3fSGIX (coerce target) u1 u2 ustride uorder v1 v2 vstride vorder w1 w2 wstride worder points
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeformationMap3fSGIX" (LogV'Void)
#endif
    return _result

glDeleteAsyncMarkersSGIX :: MonadIO m => GL.GLuint -> GL.GLsizei -> m ()
glDeleteAsyncMarkersSGIX marker range = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteAsyncMarkersSGIX" [LogV'GLuint marker, LogV'GLsizei range]
#endif
    _result <- GL.glDeleteAsyncMarkersSGIX marker range
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteAsyncMarkersSGIX" (LogV'Void)
#endif
    return _result

glDeleteBuffers :: MonadIO m => GL.GLsizei -> Ptr Buffer -> m ()
glDeleteBuffers n buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteBuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteBuffers n (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteBuffers" (LogV'Void)
#endif
    return _result

glDeleteBuffersARB :: MonadIO m => GL.GLsizei -> Ptr Buffer -> m ()
glDeleteBuffersARB n buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteBuffersARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteBuffersARB n (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteBuffersARB" (LogV'Void)
#endif
    return _result

glDeleteCommandListsNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glDeleteCommandListsNV n lists = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteCommandListsNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteCommandListsNV n lists
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteCommandListsNV" (LogV'Void)
#endif
    return _result

glDeleteFencesAPPLE :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glDeleteFencesAPPLE n fences = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteFencesAPPLE" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteFencesAPPLE n fences
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteFencesAPPLE" (LogV'Void)
#endif
    return _result

glDeleteFragmentShaderATI :: MonadIO m => GL.GLuint -> m ()
glDeleteFragmentShaderATI id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteFragmentShaderATI" [LogV'GLuint id]
#endif
    _result <- GL.glDeleteFragmentShaderATI id
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteFragmentShaderATI" (LogV'Void)
#endif
    return _result

glDeleteFramebuffers :: MonadIO m => GL.GLsizei -> Ptr Framebuffer -> m ()
glDeleteFramebuffers n framebuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteFramebuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteFramebuffers n (coerce framebuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteFramebuffers" (LogV'Void)
#endif
    return _result

glDeleteFramebuffersEXT :: MonadIO m => GL.GLsizei -> Ptr Framebuffer -> m ()
glDeleteFramebuffersEXT n framebuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteFramebuffersEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteFramebuffersEXT n (coerce framebuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteFramebuffersEXT" (LogV'Void)
#endif
    return _result

glDeleteNamesAMD :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glDeleteNamesAMD identifier num names = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteNamesAMD" [LogV'GLenum identifier, LogV'GLuint num, LogV'Ptr]
#endif
    _result <- GL.glDeleteNamesAMD identifier num names
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteNamesAMD" (LogV'Void)
#endif
    return _result

glDeleteObjectARB :: MonadIO m => GL.GLhandleARB -> m ()
glDeleteObjectARB obj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteObjectARB" [LogV'GLhandleARB obj]
#endif
    _result <- GL.glDeleteObjectARB obj
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteObjectARB" (LogV'Void)
#endif
    return _result

glDeleteOcclusionQueriesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glDeleteOcclusionQueriesNV n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteOcclusionQueriesNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteOcclusionQueriesNV n ids
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteOcclusionQueriesNV" (LogV'Void)
#endif
    return _result

glDeleteProgram :: MonadIO m => Program -> m ()
glDeleteProgram program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteProgram" [LogV'GLuint program]
#endif
    _result <- GL.glDeleteProgram (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteProgram" (LogV'Void)
#endif
    return _result

glDeleteProgramPipelines :: MonadIO m => GL.GLsizei -> Ptr ProgramPipeline -> m ()
glDeleteProgramPipelines n pipelines = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteProgramPipelines" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteProgramPipelines n (coerce pipelines)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteProgramPipelines" (LogV'Void)
#endif
    return _result

glDeleteProgramsARB :: MonadIO m => GL.GLsizei -> Ptr Program -> m ()
glDeleteProgramsARB n programs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteProgramsARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteProgramsARB n (coerce programs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteProgramsARB" (LogV'Void)
#endif
    return _result

glDeleteProgramsNV :: MonadIO m => GL.GLsizei -> Ptr Program -> m ()
glDeleteProgramsNV n programs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteProgramsNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteProgramsNV n (coerce programs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteProgramsNV" (LogV'Void)
#endif
    return _result

glDeleteQueries :: MonadIO m => GL.GLsizei -> Ptr (Query (a :: QueryTarget)) -> m ()
glDeleteQueries n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteQueries" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteQueries n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteQueries" (LogV'Void)
#endif
    return _result

glDeleteQueriesARB :: MonadIO m => GL.GLsizei -> Ptr (Query (a :: QueryTarget)) -> m ()
glDeleteQueriesARB n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteQueriesARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteQueriesARB n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteQueriesARB" (LogV'Void)
#endif
    return _result

glDeleteRenderbuffers :: MonadIO m => GL.GLsizei -> Ptr Renderbuffer -> m ()
glDeleteRenderbuffers n renderbuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteRenderbuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteRenderbuffers n (coerce renderbuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteRenderbuffers" (LogV'Void)
#endif
    return _result

glDeleteRenderbuffersEXT :: MonadIO m => GL.GLsizei -> Ptr Renderbuffer -> m ()
glDeleteRenderbuffersEXT n renderbuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteRenderbuffersEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteRenderbuffersEXT n (coerce renderbuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteRenderbuffersEXT" (LogV'Void)
#endif
    return _result

glDeleteSamplers :: MonadIO m => GL.GLsizei -> Ptr Sampler -> m ()
glDeleteSamplers count samplers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteSamplers" [LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glDeleteSamplers count (coerce samplers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteSamplers" (LogV'Void)
#endif
    return _result

glDeleteShader :: MonadIO m => Shader (a :: ShaderType) -> m ()
glDeleteShader shader = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteShader" [LogV'GLuint shader]
#endif
    _result <- GL.glDeleteShader (coerce shader)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteShader" (LogV'Void)
#endif
    return _result

glDeleteStatesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glDeleteStatesNV n states = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteStatesNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteStatesNV n states
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteStatesNV" (LogV'Void)
#endif
    return _result

glDeleteSync :: MonadIO m => GL.GLsync -> m ()
glDeleteSync sync = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteSync" [LogV'GLsync sync]
#endif
    _result <- GL.glDeleteSync sync
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteSync" (LogV'Void)
#endif
    return _result

glDeleteTextures :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glDeleteTextures n textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteTextures" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteTextures n (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteTextures" (LogV'Void)
#endif
    return _result

glDeleteTexturesEXT :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glDeleteTexturesEXT n textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteTexturesEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteTexturesEXT n (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteTexturesEXT" (LogV'Void)
#endif
    return _result

glDeleteTransformFeedbacks :: MonadIO m => GL.GLsizei -> Ptr TransformFeedback -> m ()
glDeleteTransformFeedbacks n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteTransformFeedbacks" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteTransformFeedbacks n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteTransformFeedbacks" (LogV'Void)
#endif
    return _result

glDeleteTransformFeedbacksNV :: MonadIO m => GL.GLsizei -> Ptr TransformFeedback -> m ()
glDeleteTransformFeedbacksNV n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteTransformFeedbacksNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteTransformFeedbacksNV n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteTransformFeedbacksNV" (LogV'Void)
#endif
    return _result

glDeleteVertexArrays :: MonadIO m => GL.GLsizei -> Ptr VertexArray -> m ()
glDeleteVertexArrays n arrays = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteVertexArrays" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteVertexArrays n (coerce arrays)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteVertexArrays" (LogV'Void)
#endif
    return _result

glDeleteVertexArraysAPPLE :: MonadIO m => GL.GLsizei -> Ptr VertexArray -> m ()
glDeleteVertexArraysAPPLE n arrays = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteVertexArraysAPPLE" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDeleteVertexArraysAPPLE n (coerce arrays)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteVertexArraysAPPLE" (LogV'Void)
#endif
    return _result

glDeleteVertexShaderEXT :: MonadIO m => GL.GLuint -> m ()
glDeleteVertexShaderEXT id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDeleteVertexShaderEXT" [LogV'GLuint id]
#endif
    _result <- GL.glDeleteVertexShaderEXT id
#ifdef GLW_DEBUG
    logGLCommandEnd "glDeleteVertexShaderEXT" (LogV'Void)
#endif
    return _result

glDepthBoundsEXT :: MonadIO m => GL.GLclampd -> GL.GLclampd -> m ()
glDepthBoundsEXT zmin zmax = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthBoundsEXT" [LogV'GLclampd zmin, LogV'GLclampd zmax]
#endif
    _result <- GL.glDepthBoundsEXT zmin zmax
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthBoundsEXT" (LogV'Void)
#endif
    return _result

glDepthBoundsdNV :: MonadIO m => GL.GLdouble -> GL.GLdouble -> m ()
glDepthBoundsdNV zmin zmax = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthBoundsdNV" [LogV'GLdouble zmin, LogV'GLdouble zmax]
#endif
    _result <- GL.glDepthBoundsdNV zmin zmax
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthBoundsdNV" (LogV'Void)
#endif
    return _result

glDepthFunc :: MonadIO m => DepthFunction -> m ()
glDepthFunc func = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthFunc" [LogV'GLenum func]
#endif
    _result <- GL.glDepthFunc (coerce func)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthFunc" (LogV'Void)
#endif
    return _result

glDepthMask :: MonadIO m => Boolean -> m ()
glDepthMask flag = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthMask" [LogV'GLboolean flag]
#endif
    _result <- GL.glDepthMask (coerce flag)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthMask" (LogV'Void)
#endif
    return _result

glDepthRange :: MonadIO m => GL.GLdouble -> GL.GLdouble -> m ()
glDepthRange near far = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthRange" [LogV'GLdouble near, LogV'GLdouble far]
#endif
    _result <- GL.glDepthRange near far
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthRange" (LogV'Void)
#endif
    return _result

glDepthRangeArrayv :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glDepthRangeArrayv first count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthRangeArrayv" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glDepthRangeArrayv first count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthRangeArrayv" (LogV'Void)
#endif
    return _result

glDepthRangeIndexed :: MonadIO m => GL.GLuint -> GL.GLdouble -> GL.GLdouble -> m ()
glDepthRangeIndexed index n f = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthRangeIndexed" [LogV'GLuint index, LogV'GLdouble n, LogV'GLdouble f]
#endif
    _result <- GL.glDepthRangeIndexed index n f
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthRangeIndexed" (LogV'Void)
#endif
    return _result

glDepthRangedNV :: MonadIO m => GL.GLdouble -> GL.GLdouble -> m ()
glDepthRangedNV zNear zFar = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthRangedNV" [LogV'GLdouble zNear, LogV'GLdouble zFar]
#endif
    _result <- GL.glDepthRangedNV zNear zFar
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthRangedNV" (LogV'Void)
#endif
    return _result

glDepthRangef :: MonadIO m => GL.GLfloat -> GL.GLfloat -> m ()
glDepthRangef n f = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDepthRangef" [LogV'GLfloat n, LogV'GLfloat f]
#endif
    _result <- GL.glDepthRangef n f
#ifdef GLW_DEBUG
    logGLCommandEnd "glDepthRangef" (LogV'Void)
#endif
    return _result

glDetachObjectARB :: MonadIO m => GL.GLhandleARB -> GL.GLhandleARB -> m ()
glDetachObjectARB containerObj attachedObj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDetachObjectARB" [LogV'GLhandleARB containerObj, LogV'GLhandleARB attachedObj]
#endif
    _result <- GL.glDetachObjectARB containerObj attachedObj
#ifdef GLW_DEBUG
    logGLCommandEnd "glDetachObjectARB" (LogV'Void)
#endif
    return _result

glDetachShader :: MonadIO m => Program -> Shader (a :: ShaderType) -> m ()
glDetachShader program shader = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDetachShader" [LogV'GLuint program, LogV'GLuint shader]
#endif
    _result <- GL.glDetachShader (coerce program) (coerce shader)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDetachShader" (LogV'Void)
#endif
    return _result

glDetailTexFuncSGIS :: MonadIO m => TextureTarget -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glDetailTexFuncSGIS target n points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDetailTexFuncSGIS" [LogV'GLenum target, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDetailTexFuncSGIS (coerce target) n points
#ifdef GLW_DEBUG
    logGLCommandEnd "glDetailTexFuncSGIS" (LogV'Void)
#endif
    return _result

glDisable :: MonadIO m => EnableCap -> m ()
glDisable cap = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisable" [LogV'GLenum cap]
#endif
    _result <- GL.glDisable (coerce cap)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisable" (LogV'Void)
#endif
    return _result

glDisableClientStateIndexedEXT :: MonadIO m => EnableCap -> GL.GLuint -> m ()
glDisableClientStateIndexedEXT array index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableClientStateIndexedEXT" [LogV'GLenum array, LogV'GLuint index]
#endif
    _result <- GL.glDisableClientStateIndexedEXT (coerce array) index
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableClientStateIndexedEXT" (LogV'Void)
#endif
    return _result

glDisableClientStateiEXT :: MonadIO m => EnableCap -> GL.GLuint -> m ()
glDisableClientStateiEXT array index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableClientStateiEXT" [LogV'GLenum array, LogV'GLuint index]
#endif
    _result <- GL.glDisableClientStateiEXT (coerce array) index
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableClientStateiEXT" (LogV'Void)
#endif
    return _result

glDisableIndexedEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glDisableIndexedEXT target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableIndexedEXT" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- GL.glDisableIndexedEXT target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableIndexedEXT" (LogV'Void)
#endif
    return _result

glDisableVariantClientStateEXT :: MonadIO m => GL.GLuint -> m ()
glDisableVariantClientStateEXT id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVariantClientStateEXT" [LogV'GLuint id]
#endif
    _result <- GL.glDisableVariantClientStateEXT id
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVariantClientStateEXT" (LogV'Void)
#endif
    return _result

glDisableVertexArrayAttrib :: MonadIO m => VertexArray -> AttribLocation -> m ()
glDisableVertexArrayAttrib vaobj index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexArrayAttrib" [LogV'GLuint vaobj, LogV'GLuint index]
#endif
    _result <- GL.glDisableVertexArrayAttrib (coerce vaobj) (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexArrayAttrib" (LogV'Void)
#endif
    return _result

glDisableVertexArrayAttribEXT :: MonadIO m => VertexArray -> AttribLocation -> m ()
glDisableVertexArrayAttribEXT vaobj index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexArrayAttribEXT" [LogV'GLuint vaobj, LogV'GLuint index]
#endif
    _result <- GL.glDisableVertexArrayAttribEXT (coerce vaobj) (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexArrayAttribEXT" (LogV'Void)
#endif
    return _result

glDisableVertexArrayEXT :: MonadIO m => VertexArray -> EnableCap -> m ()
glDisableVertexArrayEXT vaobj array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexArrayEXT" [LogV'GLuint vaobj, LogV'GLenum array]
#endif
    _result <- GL.glDisableVertexArrayEXT (coerce vaobj) (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexArrayEXT" (LogV'Void)
#endif
    return _result

glDisableVertexAttribAPPLE :: MonadIO m => AttribLocation -> GL.GLenum -> m ()
glDisableVertexAttribAPPLE index pname = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexAttribAPPLE" [LogV'GLuint index, LogV'GLenum pname]
#endif
    _result <- GL.glDisableVertexAttribAPPLE (coerce index) pname
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexAttribAPPLE" (LogV'Void)
#endif
    return _result

glDisableVertexAttribArray :: MonadIO m => AttribLocation -> m ()
glDisableVertexAttribArray index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexAttribArray" [LogV'GLuint index]
#endif
    _result <- GL.glDisableVertexAttribArray (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexAttribArray" (LogV'Void)
#endif
    return _result

glDisableVertexAttribArrayARB :: MonadIO m => AttribLocation -> m ()
glDisableVertexAttribArrayARB index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisableVertexAttribArrayARB" [LogV'GLuint index]
#endif
    _result <- GL.glDisableVertexAttribArrayARB (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisableVertexAttribArrayARB" (LogV'Void)
#endif
    return _result

glDisablei :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glDisablei target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDisablei" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- GL.glDisablei target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glDisablei" (LogV'Void)
#endif
    return _result

glDispatchCompute :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glDispatchCompute num_groups_x num_groups_y num_groups_z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDispatchCompute" [LogV'GLuint num_groups_x, LogV'GLuint num_groups_y, LogV'GLuint num_groups_z]
#endif
    _result <- GL.glDispatchCompute num_groups_x num_groups_y num_groups_z
#ifdef GLW_DEBUG
    logGLCommandEnd "glDispatchCompute" (LogV'Void)
#endif
    return _result

glDispatchComputeIndirect :: MonadIO m => GL.GLintptr -> m ()
glDispatchComputeIndirect indirect = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDispatchComputeIndirect" [LogV'GLintptr indirect]
#endif
    _result <- GL.glDispatchComputeIndirect indirect
#ifdef GLW_DEBUG
    logGLCommandEnd "glDispatchComputeIndirect" (LogV'Void)
#endif
    return _result

glDrawArrays :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> m ()
glDrawArrays mode first count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArrays" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count]
#endif
    _result <- GL.glDrawArrays (coerce mode) first count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArrays" (LogV'Void)
#endif
    return _result

glDrawArraysEXT :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> m ()
glDrawArraysEXT mode first count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArraysEXT" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count]
#endif
    _result <- GL.glDrawArraysEXT (coerce mode) first count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArraysEXT" (LogV'Void)
#endif
    return _result

glDrawArraysIndirect :: MonadIO m => PrimitiveType -> Ptr () -> m ()
glDrawArraysIndirect mode indirect = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArraysIndirect" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glDrawArraysIndirect (coerce mode) indirect
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArraysIndirect" (LogV'Void)
#endif
    return _result

glDrawArraysInstanced :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glDrawArraysInstanced mode first count instancecount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArraysInstanced" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count, LogV'GLsizei instancecount]
#endif
    _result <- GL.glDrawArraysInstanced (coerce mode) first count instancecount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArraysInstanced" (LogV'Void)
#endif
    return _result

glDrawArraysInstancedARB :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glDrawArraysInstancedARB mode first count primcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArraysInstancedARB" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count, LogV'GLsizei primcount]
#endif
    _result <- GL.glDrawArraysInstancedARB (coerce mode) first count primcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArraysInstancedARB" (LogV'Void)
#endif
    return _result

glDrawArraysInstancedBaseInstance :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLuint -> m ()
glDrawArraysInstancedBaseInstance mode first count instancecount baseinstance = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawArraysInstancedBaseInstance" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count, LogV'GLsizei instancecount, LogV'GLuint baseinstance]
#endif
    _result <- GL.glDrawArraysInstancedBaseInstance (coerce mode) first count instancecount baseinstance
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawArraysInstancedBaseInstance" (LogV'Void)
#endif
    return _result

glDrawBuffer :: MonadIO m => DrawBufferMode -> m ()
glDrawBuffer buf = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawBuffer" [LogV'GLenum buf]
#endif
    _result <- GL.glDrawBuffer (coerce buf)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawBuffer" (LogV'Void)
#endif
    return _result

glDrawBuffers :: MonadIO m => GL.GLsizei -> Ptr GL.GLenum -> m ()
glDrawBuffers n bufs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawBuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDrawBuffers n bufs
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawBuffers" (LogV'Void)
#endif
    return _result

glDrawBuffersARB :: MonadIO m => GL.GLsizei -> Ptr GL.GLenum -> m ()
glDrawBuffersARB n bufs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawBuffersARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDrawBuffersARB n bufs
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawBuffersARB" (LogV'Void)
#endif
    return _result

glDrawBuffersATI :: MonadIO m => GL.GLsizei -> Ptr GL.GLenum -> m ()
glDrawBuffersATI n bufs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawBuffersATI" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glDrawBuffersATI n bufs
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawBuffersATI" (LogV'Void)
#endif
    return _result

glDrawCommandsAddressNV :: MonadIO m => GL.GLenum -> Ptr GL.GLuint64 -> Ptr GL.GLsizei -> GL.GLuint -> m ()
glDrawCommandsAddressNV primitiveMode indirects sizes count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawCommandsAddressNV" [LogV'GLenum primitiveMode, LogV'Ptr, LogV'Ptr, LogV'GLuint count]
#endif
    _result <- GL.glDrawCommandsAddressNV primitiveMode indirects sizes count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawCommandsAddressNV" (LogV'Void)
#endif
    return _result

glDrawCommandsNV :: MonadIO m => GL.GLenum -> Buffer -> Ptr GL.GLintptr -> Ptr GL.GLsizei -> GL.GLuint -> m ()
glDrawCommandsNV primitiveMode buffer indirects sizes count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawCommandsNV" [LogV'GLenum primitiveMode, LogV'GLuint buffer, LogV'Ptr, LogV'Ptr, LogV'GLuint count]
#endif
    _result <- GL.glDrawCommandsNV primitiveMode (coerce buffer) indirects sizes count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawCommandsNV" (LogV'Void)
#endif
    return _result

glDrawCommandsStatesAddressNV :: MonadIO m => Ptr GL.GLuint64 -> Ptr GL.GLsizei -> Ptr GL.GLuint -> Ptr GL.GLuint -> GL.GLuint -> m ()
glDrawCommandsStatesAddressNV indirects sizes states fbos count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawCommandsStatesAddressNV" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'GLuint count]
#endif
    _result <- GL.glDrawCommandsStatesAddressNV indirects sizes states fbos count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawCommandsStatesAddressNV" (LogV'Void)
#endif
    return _result

glDrawCommandsStatesNV :: MonadIO m => Buffer -> Ptr GL.GLintptr -> Ptr GL.GLsizei -> Ptr GL.GLuint -> Ptr GL.GLuint -> GL.GLuint -> m ()
glDrawCommandsStatesNV buffer indirects sizes states fbos count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawCommandsStatesNV" [LogV'GLuint buffer, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'GLuint count]
#endif
    _result <- GL.glDrawCommandsStatesNV (coerce buffer) indirects sizes states fbos count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawCommandsStatesNV" (LogV'Void)
#endif
    return _result

glDrawElementArrayAPPLE :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> m ()
glDrawElementArrayAPPLE mode first count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementArrayAPPLE" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count]
#endif
    _result <- GL.glDrawElementArrayAPPLE (coerce mode) first count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementArrayAPPLE" (LogV'Void)
#endif
    return _result

glDrawElementArrayATI :: MonadIO m => PrimitiveType -> GL.GLsizei -> m ()
glDrawElementArrayATI mode count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementArrayATI" [LogV'GLenum mode, LogV'GLsizei count]
#endif
    _result <- GL.glDrawElementArrayATI (coerce mode) count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementArrayATI" (LogV'Void)
#endif
    return _result

glDrawElements :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> m ()
glDrawElements mode count type' indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElements" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glDrawElements (coerce mode) count type' indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElements" (LogV'Void)
#endif
    return _result

glDrawElementsBaseVertex :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLint -> m ()
glDrawElementsBaseVertex mode count type' indices basevertex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsBaseVertex" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLint basevertex]
#endif
    _result <- GL.glDrawElementsBaseVertex (coerce mode) count type' indices basevertex
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsBaseVertex" (LogV'Void)
#endif
    return _result

glDrawElementsIndirect :: MonadIO m => PrimitiveType -> GL.GLenum -> Ptr () -> m ()
glDrawElementsIndirect mode type' indirect = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsIndirect" [LogV'GLenum mode, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glDrawElementsIndirect (coerce mode) type' indirect
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsIndirect" (LogV'Void)
#endif
    return _result

glDrawElementsInstanced :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLsizei -> m ()
glDrawElementsInstanced mode count type' indices instancecount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsInstanced" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLsizei instancecount]
#endif
    _result <- GL.glDrawElementsInstanced (coerce mode) count type' indices instancecount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsInstanced" (LogV'Void)
#endif
    return _result

glDrawElementsInstancedARB :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLsizei -> m ()
glDrawElementsInstancedARB mode count type' indices primcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsInstancedARB" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLsizei primcount]
#endif
    _result <- GL.glDrawElementsInstancedARB (coerce mode) count type' indices primcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsInstancedARB" (LogV'Void)
#endif
    return _result

glDrawElementsInstancedBaseInstance :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLuint -> m ()
glDrawElementsInstancedBaseInstance mode count type' indices instancecount baseinstance = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsInstancedBaseInstance" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLsizei instancecount, LogV'GLuint baseinstance]
#endif
    _result <- GL.glDrawElementsInstancedBaseInstance (coerce mode) count type' indices instancecount baseinstance
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsInstancedBaseInstance" (LogV'Void)
#endif
    return _result

glDrawElementsInstancedBaseVertex :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLint -> m ()
glDrawElementsInstancedBaseVertex mode count type' indices instancecount basevertex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsInstancedBaseVertex" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLsizei instancecount, LogV'GLint basevertex]
#endif
    _result <- GL.glDrawElementsInstancedBaseVertex (coerce mode) count type' indices instancecount basevertex
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsInstancedBaseVertex" (LogV'Void)
#endif
    return _result

glDrawElementsInstancedBaseVertexBaseInstance :: MonadIO m => PrimitiveType -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLint -> GL.GLuint -> m ()
glDrawElementsInstancedBaseVertexBaseInstance mode count type' indices instancecount basevertex baseinstance = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawElementsInstancedBaseVertexBaseInstance" [LogV'GLenum mode, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLsizei instancecount, LogV'GLint basevertex, LogV'GLuint baseinstance]
#endif
    _result <- GL.glDrawElementsInstancedBaseVertexBaseInstance (coerce mode) count type' indices instancecount basevertex baseinstance
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawElementsInstancedBaseVertexBaseInstance" (LogV'Void)
#endif
    return _result

glDrawMeshArraysSUN :: MonadIO m => PrimitiveType -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glDrawMeshArraysSUN mode first count width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawMeshArraysSUN" [LogV'GLenum mode, LogV'GLint first, LogV'GLsizei count, LogV'GLsizei width]
#endif
    _result <- GL.glDrawMeshArraysSUN (coerce mode) first count width
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawMeshArraysSUN" (LogV'Void)
#endif
    return _result

glDrawRangeElementArrayAPPLE :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> GL.GLint -> GL.GLsizei -> m ()
glDrawRangeElementArrayAPPLE mode start end first count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawRangeElementArrayAPPLE" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'GLint first, LogV'GLsizei count]
#endif
    _result <- GL.glDrawRangeElementArrayAPPLE (coerce mode) start end first count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawRangeElementArrayAPPLE" (LogV'Void)
#endif
    return _result

glDrawRangeElementArrayATI :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> m ()
glDrawRangeElementArrayATI mode start end count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawRangeElementArrayATI" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'GLsizei count]
#endif
    _result <- GL.glDrawRangeElementArrayATI (coerce mode) start end count
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawRangeElementArrayATI" (LogV'Void)
#endif
    return _result

glDrawRangeElements :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> GL.GLenum -> Ptr () -> m ()
glDrawRangeElements mode start end count type' indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawRangeElements" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glDrawRangeElements (coerce mode) start end count type' indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawRangeElements" (LogV'Void)
#endif
    return _result

glDrawRangeElementsBaseVertex :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> GL.GLenum -> Ptr () -> GL.GLint -> m ()
glDrawRangeElementsBaseVertex mode start end count type' indices basevertex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawRangeElementsBaseVertex" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr, LogV'GLint basevertex]
#endif
    _result <- GL.glDrawRangeElementsBaseVertex (coerce mode) start end count type' indices basevertex
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawRangeElementsBaseVertex" (LogV'Void)
#endif
    return _result

glDrawRangeElementsEXT :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> GL.GLenum -> Ptr () -> m ()
glDrawRangeElementsEXT mode start end count type' indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawRangeElementsEXT" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'GLsizei count, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glDrawRangeElementsEXT (coerce mode) start end count type' indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawRangeElementsEXT" (LogV'Void)
#endif
    return _result

glDrawTextureNV :: MonadIO m => Texture (a :: TextureTarget') -> Sampler -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glDrawTextureNV texture sampler x0 y0 x1 y1 z s0 t0 s1 t1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTextureNV" [LogV'GLuint texture, LogV'GLuint sampler, LogV'GLfloat x0, LogV'GLfloat y0, LogV'GLfloat x1, LogV'GLfloat y1, LogV'GLfloat z, LogV'GLfloat s0, LogV'GLfloat t0, LogV'GLfloat s1, LogV'GLfloat t1]
#endif
    _result <- GL.glDrawTextureNV (coerce texture) (coerce sampler) x0 y0 x1 y1 z s0 t0 s1 t1
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTextureNV" (LogV'Void)
#endif
    return _result

glDrawTransformFeedback :: MonadIO m => PrimitiveType -> TransformFeedback -> m ()
glDrawTransformFeedback mode id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTransformFeedback" [LogV'GLenum mode, LogV'GLuint id]
#endif
    _result <- GL.glDrawTransformFeedback (coerce mode) (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTransformFeedback" (LogV'Void)
#endif
    return _result

glDrawTransformFeedbackInstanced :: MonadIO m => PrimitiveType -> TransformFeedback -> GL.GLsizei -> m ()
glDrawTransformFeedbackInstanced mode id instancecount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTransformFeedbackInstanced" [LogV'GLenum mode, LogV'GLuint id, LogV'GLsizei instancecount]
#endif
    _result <- GL.glDrawTransformFeedbackInstanced (coerce mode) (coerce id) instancecount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTransformFeedbackInstanced" (LogV'Void)
#endif
    return _result

glDrawTransformFeedbackNV :: MonadIO m => PrimitiveType -> TransformFeedback -> m ()
glDrawTransformFeedbackNV mode id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTransformFeedbackNV" [LogV'GLenum mode, LogV'GLuint id]
#endif
    _result <- GL.glDrawTransformFeedbackNV (coerce mode) (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glDrawTransformFeedbackStream :: MonadIO m => PrimitiveType -> TransformFeedback -> GL.GLuint -> m ()
glDrawTransformFeedbackStream mode id stream = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTransformFeedbackStream" [LogV'GLenum mode, LogV'GLuint id, LogV'GLuint stream]
#endif
    _result <- GL.glDrawTransformFeedbackStream (coerce mode) (coerce id) stream
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTransformFeedbackStream" (LogV'Void)
#endif
    return _result

glDrawTransformFeedbackStreamInstanced :: MonadIO m => PrimitiveType -> TransformFeedback -> GL.GLuint -> GL.GLsizei -> m ()
glDrawTransformFeedbackStreamInstanced mode id stream instancecount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glDrawTransformFeedbackStreamInstanced" [LogV'GLenum mode, LogV'GLuint id, LogV'GLuint stream, LogV'GLsizei instancecount]
#endif
    _result <- GL.glDrawTransformFeedbackStreamInstanced (coerce mode) (coerce id) stream instancecount
#ifdef GLW_DEBUG
    logGLCommandEnd "glDrawTransformFeedbackStreamInstanced" (LogV'Void)
#endif
    return _result

glEdgeFlagFormatNV :: MonadIO m => GL.GLsizei -> m ()
glEdgeFlagFormatNV stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEdgeFlagFormatNV" [LogV'GLsizei stride]
#endif
    _result <- GL.glEdgeFlagFormatNV stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glEdgeFlagFormatNV" (LogV'Void)
#endif
    return _result

glEdgeFlagPointerEXT :: MonadIO m => GL.GLsizei -> GL.GLsizei -> Ptr Boolean -> m ()
glEdgeFlagPointerEXT stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEdgeFlagPointerEXT" [LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glEdgeFlagPointerEXT stride count (coerce pointer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEdgeFlagPointerEXT" (LogV'Void)
#endif
    return _result

glEdgeFlagPointerListIBM :: MonadIO m => GL.GLint -> Ptr (Ptr GL.GLboolean) -> GL.GLint -> m ()
glEdgeFlagPointerListIBM stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEdgeFlagPointerListIBM" [LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glEdgeFlagPointerListIBM stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glEdgeFlagPointerListIBM" (LogV'Void)
#endif
    return _result

glElementPointerAPPLE :: MonadIO m => GL.GLenum -> Ptr () -> m ()
glElementPointerAPPLE type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glElementPointerAPPLE" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glElementPointerAPPLE type' pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glElementPointerAPPLE" (LogV'Void)
#endif
    return _result

glElementPointerATI :: MonadIO m => GL.GLenum -> Ptr () -> m ()
glElementPointerATI type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glElementPointerATI" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glElementPointerATI type' pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glElementPointerATI" (LogV'Void)
#endif
    return _result

glEnable :: MonadIO m => EnableCap -> m ()
glEnable cap = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnable" [LogV'GLenum cap]
#endif
    _result <- GL.glEnable (coerce cap)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnable" (LogV'Void)
#endif
    return _result

glEnableClientStateIndexedEXT :: MonadIO m => EnableCap -> GL.GLuint -> m ()
glEnableClientStateIndexedEXT array index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableClientStateIndexedEXT" [LogV'GLenum array, LogV'GLuint index]
#endif
    _result <- GL.glEnableClientStateIndexedEXT (coerce array) index
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableClientStateIndexedEXT" (LogV'Void)
#endif
    return _result

glEnableClientStateiEXT :: MonadIO m => EnableCap -> GL.GLuint -> m ()
glEnableClientStateiEXT array index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableClientStateiEXT" [LogV'GLenum array, LogV'GLuint index]
#endif
    _result <- GL.glEnableClientStateiEXT (coerce array) index
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableClientStateiEXT" (LogV'Void)
#endif
    return _result

glEnableIndexedEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glEnableIndexedEXT target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableIndexedEXT" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- GL.glEnableIndexedEXT target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableIndexedEXT" (LogV'Void)
#endif
    return _result

glEnableVariantClientStateEXT :: MonadIO m => GL.GLuint -> m ()
glEnableVariantClientStateEXT id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVariantClientStateEXT" [LogV'GLuint id]
#endif
    _result <- GL.glEnableVariantClientStateEXT id
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVariantClientStateEXT" (LogV'Void)
#endif
    return _result

glEnableVertexArrayAttrib :: MonadIO m => VertexArray -> AttribLocation -> m ()
glEnableVertexArrayAttrib vaobj index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexArrayAttrib" [LogV'GLuint vaobj, LogV'GLuint index]
#endif
    _result <- GL.glEnableVertexArrayAttrib (coerce vaobj) (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexArrayAttrib" (LogV'Void)
#endif
    return _result

glEnableVertexArrayAttribEXT :: MonadIO m => VertexArray -> AttribLocation -> m ()
glEnableVertexArrayAttribEXT vaobj index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexArrayAttribEXT" [LogV'GLuint vaobj, LogV'GLuint index]
#endif
    _result <- GL.glEnableVertexArrayAttribEXT (coerce vaobj) (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexArrayAttribEXT" (LogV'Void)
#endif
    return _result

glEnableVertexArrayEXT :: MonadIO m => VertexArray -> EnableCap -> m ()
glEnableVertexArrayEXT vaobj array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexArrayEXT" [LogV'GLuint vaobj, LogV'GLenum array]
#endif
    _result <- GL.glEnableVertexArrayEXT (coerce vaobj) (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexArrayEXT" (LogV'Void)
#endif
    return _result

glEnableVertexAttribAPPLE :: MonadIO m => AttribLocation -> GL.GLenum -> m ()
glEnableVertexAttribAPPLE index pname = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexAttribAPPLE" [LogV'GLuint index, LogV'GLenum pname]
#endif
    _result <- GL.glEnableVertexAttribAPPLE (coerce index) pname
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexAttribAPPLE" (LogV'Void)
#endif
    return _result

glEnableVertexAttribArray :: MonadIO m => AttribLocation -> m ()
glEnableVertexAttribArray index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexAttribArray" [LogV'GLuint index]
#endif
    _result <- GL.glEnableVertexAttribArray (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexAttribArray" (LogV'Void)
#endif
    return _result

glEnableVertexAttribArrayARB :: MonadIO m => AttribLocation -> m ()
glEnableVertexAttribArrayARB index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnableVertexAttribArrayARB" [LogV'GLuint index]
#endif
    _result <- GL.glEnableVertexAttribArrayARB (coerce index)
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnableVertexAttribArrayARB" (LogV'Void)
#endif
    return _result

glEnablei :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glEnablei target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEnablei" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- GL.glEnablei target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glEnablei" (LogV'Void)
#endif
    return _result

glEndConditionalRender :: MonadIO m => m ()
glEndConditionalRender  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndConditionalRender" []
#endif
    _result <- GL.glEndConditionalRender 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndConditionalRender" (LogV'Void)
#endif
    return _result

glEndConditionalRenderNVX :: MonadIO m => m ()
glEndConditionalRenderNVX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndConditionalRenderNVX" []
#endif
    _result <- GL.glEndConditionalRenderNVX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndConditionalRenderNVX" (LogV'Void)
#endif
    return _result

glEndFragmentShaderATI :: MonadIO m => m ()
glEndFragmentShaderATI  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndFragmentShaderATI" []
#endif
    _result <- GL.glEndFragmentShaderATI 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndFragmentShaderATI" (LogV'Void)
#endif
    return _result

glEndOcclusionQueryNV :: MonadIO m => m ()
glEndOcclusionQueryNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndOcclusionQueryNV" []
#endif
    _result <- GL.glEndOcclusionQueryNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndOcclusionQueryNV" (LogV'Void)
#endif
    return _result

glEndQuery :: MonadIO m => GL.GLenum -> m ()
glEndQuery target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndQuery" [LogV'GLenum target]
#endif
    _result <- GL.glEndQuery target
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndQuery" (LogV'Void)
#endif
    return _result

glEndQueryARB :: MonadIO m => GL.GLenum -> m ()
glEndQueryARB target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndQueryARB" [LogV'GLenum target]
#endif
    _result <- GL.glEndQueryARB target
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndQueryARB" (LogV'Void)
#endif
    return _result

glEndQueryIndexed :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glEndQueryIndexed target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndQueryIndexed" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- GL.glEndQueryIndexed target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndQueryIndexed" (LogV'Void)
#endif
    return _result

glEndTransformFeedback :: MonadIO m => m ()
glEndTransformFeedback  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndTransformFeedback" []
#endif
    _result <- GL.glEndTransformFeedback 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndTransformFeedback" (LogV'Void)
#endif
    return _result

glEndTransformFeedbackEXT :: MonadIO m => m ()
glEndTransformFeedbackEXT  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndTransformFeedbackEXT" []
#endif
    _result <- GL.glEndTransformFeedbackEXT 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndTransformFeedbackEXT" (LogV'Void)
#endif
    return _result

glEndTransformFeedbackNV :: MonadIO m => m ()
glEndTransformFeedbackNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndTransformFeedbackNV" []
#endif
    _result <- GL.glEndTransformFeedbackNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glEndVertexShaderEXT :: MonadIO m => m ()
glEndVertexShaderEXT  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndVertexShaderEXT" []
#endif
    _result <- GL.glEndVertexShaderEXT 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndVertexShaderEXT" (LogV'Void)
#endif
    return _result

glEndVideoCaptureNV :: MonadIO m => GL.GLuint -> m ()
glEndVideoCaptureNV video_capture_slot = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEndVideoCaptureNV" [LogV'GLuint video_capture_slot]
#endif
    _result <- GL.glEndVideoCaptureNV video_capture_slot
#ifdef GLW_DEBUG
    logGLCommandEnd "glEndVideoCaptureNV" (LogV'Void)
#endif
    return _result

glEvalMapsNV :: MonadIO m => GL.GLenum -> GL.GLenum -> m ()
glEvalMapsNV target mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEvalMapsNV" [LogV'GLenum target, LogV'GLenum mode]
#endif
    _result <- GL.glEvalMapsNV target mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glEvalMapsNV" (LogV'Void)
#endif
    return _result

glEvaluateDepthValuesARB :: MonadIO m => m ()
glEvaluateDepthValuesARB  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glEvaluateDepthValuesARB" []
#endif
    _result <- GL.glEvaluateDepthValuesARB 
#ifdef GLW_DEBUG
    logGLCommandEnd "glEvaluateDepthValuesARB" (LogV'Void)
#endif
    return _result

glExecuteProgramNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glExecuteProgramNV target id params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glExecuteProgramNV" [LogV'GLenum target, LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glExecuteProgramNV target id params
#ifdef GLW_DEBUG
    logGLCommandEnd "glExecuteProgramNV" (LogV'Void)
#endif
    return _result

glExtractComponentEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glExtractComponentEXT res src num = do
#ifdef GLW_DEBUG
    logGLCommandStart "glExtractComponentEXT" [LogV'GLuint res, LogV'GLuint src, LogV'GLuint num]
#endif
    _result <- GL.glExtractComponentEXT res src num
#ifdef GLW_DEBUG
    logGLCommandEnd "glExtractComponentEXT" (LogV'Void)
#endif
    return _result

glFenceSync :: MonadIO m => GL.GLenum -> GL.GLbitfield -> m GL.GLsync
glFenceSync condition flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFenceSync" [LogV'GLenum condition, LogV'GLbitfield flags]
#endif
    _result <- GL.glFenceSync condition flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glFenceSync" (LogV'GLsync _result)
#endif
    return _result

glFinalCombinerInputNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glFinalCombinerInputNV variable input mapping componentUsage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinalCombinerInputNV" [LogV'GLenum variable, LogV'GLenum input, LogV'GLenum mapping, LogV'GLenum componentUsage]
#endif
    _result <- GL.glFinalCombinerInputNV variable input mapping componentUsage
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinalCombinerInputNV" (LogV'Void)
#endif
    return _result

glFinish :: MonadIO m => m ()
glFinish  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinish" []
#endif
    _result <- GL.glFinish 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinish" (LogV'Void)
#endif
    return _result

glFinishAsyncSGIX :: MonadIO m => Ptr GL.GLuint -> m GL.GLint
glFinishAsyncSGIX markerp = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinishAsyncSGIX" [LogV'Ptr]
#endif
    _result <- GL.glFinishAsyncSGIX markerp
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinishAsyncSGIX" (LogV'GLint _result)
#endif
    return _result

glFinishFenceAPPLE :: MonadIO m => GL.GLuint -> m ()
glFinishFenceAPPLE fence = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinishFenceAPPLE" [LogV'GLuint fence]
#endif
    _result <- GL.glFinishFenceAPPLE fence
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinishFenceAPPLE" (LogV'Void)
#endif
    return _result

glFinishObjectAPPLE :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glFinishObjectAPPLE object name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinishObjectAPPLE" [LogV'GLenum object, LogV'GLint name]
#endif
    _result <- GL.glFinishObjectAPPLE object name
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinishObjectAPPLE" (LogV'Void)
#endif
    return _result

glFinishTextureSUNX :: MonadIO m => m ()
glFinishTextureSUNX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFinishTextureSUNX" []
#endif
    _result <- GL.glFinishTextureSUNX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFinishTextureSUNX" (LogV'Void)
#endif
    return _result

glFlush :: MonadIO m => m ()
glFlush  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlush" []
#endif
    _result <- GL.glFlush 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlush" (LogV'Void)
#endif
    return _result

glFlushMappedBufferRange :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glFlushMappedBufferRange target offset length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushMappedBufferRange" [LogV'GLenum target, LogV'GLintptr offset, LogV'GLsizeiptr length]
#endif
    _result <- GL.glFlushMappedBufferRange target offset length
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushMappedBufferRange" (LogV'Void)
#endif
    return _result

glFlushMappedBufferRangeAPPLE :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glFlushMappedBufferRangeAPPLE target offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushMappedBufferRangeAPPLE" [LogV'GLenum target, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glFlushMappedBufferRangeAPPLE target offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushMappedBufferRangeAPPLE" (LogV'Void)
#endif
    return _result

glFlushMappedNamedBufferRange :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glFlushMappedNamedBufferRange buffer offset length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushMappedNamedBufferRange" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr length]
#endif
    _result <- GL.glFlushMappedNamedBufferRange (coerce buffer) offset length
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushMappedNamedBufferRange" (LogV'Void)
#endif
    return _result

glFlushMappedNamedBufferRangeEXT :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glFlushMappedNamedBufferRangeEXT buffer offset length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushMappedNamedBufferRangeEXT" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr length]
#endif
    _result <- GL.glFlushMappedNamedBufferRangeEXT (coerce buffer) offset length
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushMappedNamedBufferRangeEXT" (LogV'Void)
#endif
    return _result

glFlushPixelDataRangeNV :: MonadIO m => GL.GLenum -> m ()
glFlushPixelDataRangeNV target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushPixelDataRangeNV" [LogV'GLenum target]
#endif
    _result <- GL.glFlushPixelDataRangeNV target
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushPixelDataRangeNV" (LogV'Void)
#endif
    return _result

glFlushRasterSGIX :: MonadIO m => m ()
glFlushRasterSGIX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushRasterSGIX" []
#endif
    _result <- GL.glFlushRasterSGIX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushRasterSGIX" (LogV'Void)
#endif
    return _result

glFlushStaticDataIBM :: MonadIO m => GL.GLenum -> m ()
glFlushStaticDataIBM target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushStaticDataIBM" [LogV'GLenum target]
#endif
    _result <- GL.glFlushStaticDataIBM target
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushStaticDataIBM" (LogV'Void)
#endif
    return _result

glFlushVertexArrayRangeAPPLE :: MonadIO m => GL.GLsizei -> Ptr () -> m ()
glFlushVertexArrayRangeAPPLE length pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushVertexArrayRangeAPPLE" [LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glFlushVertexArrayRangeAPPLE length pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushVertexArrayRangeAPPLE" (LogV'Void)
#endif
    return _result

glFlushVertexArrayRangeNV :: MonadIO m => m ()
glFlushVertexArrayRangeNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFlushVertexArrayRangeNV" []
#endif
    _result <- GL.glFlushVertexArrayRangeNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFlushVertexArrayRangeNV" (LogV'Void)
#endif
    return _result

glFogCoordFormatNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> m ()
glFogCoordFormatNV type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordFormatNV" [LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glFogCoordFormatNV type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordFormatNV" (LogV'Void)
#endif
    return _result

glFogCoordPointerEXT :: MonadIO m => FogPointerTypeEXT -> GL.GLsizei -> Ptr () -> m ()
glFogCoordPointerEXT type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordPointerEXT" [LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glFogCoordPointerEXT (coerce type') stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordPointerEXT" (LogV'Void)
#endif
    return _result

glFogCoordPointerListIBM :: MonadIO m => FogPointerTypeIBM -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glFogCoordPointerListIBM type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordPointerListIBM" [LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glFogCoordPointerListIBM (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordPointerListIBM" (LogV'Void)
#endif
    return _result

glFogCoorddEXT :: MonadIO m => GL.GLdouble -> m ()
glFogCoorddEXT coord = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoorddEXT" [LogV'GLdouble coord]
#endif
    _result <- GL.glFogCoorddEXT coord
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoorddEXT" (LogV'Void)
#endif
    return _result

glFogCoorddvEXT :: MonadIO m => Ptr GL.GLdouble -> m ()
glFogCoorddvEXT coord = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoorddvEXT" [LogV'Ptr]
#endif
    _result <- GL.glFogCoorddvEXT coord
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoorddvEXT" (LogV'Void)
#endif
    return _result

glFogCoordfEXT :: MonadIO m => GL.GLfloat -> m ()
glFogCoordfEXT coord = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordfEXT" [LogV'GLfloat coord]
#endif
    _result <- GL.glFogCoordfEXT coord
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordfEXT" (LogV'Void)
#endif
    return _result

glFogCoordfvEXT :: MonadIO m => Ptr GL.GLfloat -> m ()
glFogCoordfvEXT coord = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordfvEXT" [LogV'Ptr]
#endif
    _result <- GL.glFogCoordfvEXT coord
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordfvEXT" (LogV'Void)
#endif
    return _result

glFogCoordhNV :: MonadIO m => GL.GLhalfNV -> m ()
glFogCoordhNV fog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordhNV" [LogV'GLhalfNV fog]
#endif
    _result <- GL.glFogCoordhNV fog
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordhNV" (LogV'Void)
#endif
    return _result

glFogCoordhvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glFogCoordhvNV fog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogCoordhvNV" [LogV'Ptr]
#endif
    _result <- GL.glFogCoordhvNV fog
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogCoordhvNV" (LogV'Void)
#endif
    return _result

glFogFuncSGIS :: MonadIO m => GL.GLsizei -> Ptr GL.GLfloat -> m ()
glFogFuncSGIS n points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFogFuncSGIS" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glFogFuncSGIS n points
#ifdef GLW_DEBUG
    logGLCommandEnd "glFogFuncSGIS" (LogV'Void)
#endif
    return _result

glFragmentColorMaterialSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> m ()
glFragmentColorMaterialSGIX face mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentColorMaterialSGIX" [LogV'GLenum face, LogV'GLenum mode]
#endif
    _result <- GL.glFragmentColorMaterialSGIX (coerce face) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentColorMaterialSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightModelfSGIX :: MonadIO m => FragmentLightModelParameterSGIX -> GL.GLfloat -> m ()
glFragmentLightModelfSGIX pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightModelfSGIX" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glFragmentLightModelfSGIX (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightModelfSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightModelfvSGIX :: MonadIO m => FragmentLightModelParameterSGIX -> Ptr GL.GLfloat -> m ()
glFragmentLightModelfvSGIX pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightModelfvSGIX" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentLightModelfvSGIX (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightModelfvSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightModeliSGIX :: MonadIO m => FragmentLightModelParameterSGIX -> GL.GLint -> m ()
glFragmentLightModeliSGIX pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightModeliSGIX" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glFragmentLightModeliSGIX (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightModeliSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightModelivSGIX :: MonadIO m => FragmentLightModelParameterSGIX -> Ptr GL.GLint -> m ()
glFragmentLightModelivSGIX pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightModelivSGIX" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentLightModelivSGIX (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightModelivSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightfSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLfloat -> m ()
glFragmentLightfSGIX light pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightfSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glFragmentLightfSGIX light pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightfSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightfvSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glFragmentLightfvSGIX light pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightfvSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentLightfvSGIX light pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightfvSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightiSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLint -> m ()
glFragmentLightiSGIX light pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightiSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glFragmentLightiSGIX light pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightiSGIX" (LogV'Void)
#endif
    return _result

glFragmentLightivSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glFragmentLightivSGIX light pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentLightivSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentLightivSGIX light pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentLightivSGIX" (LogV'Void)
#endif
    return _result

glFragmentMaterialfSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> GL.GLfloat -> m ()
glFragmentMaterialfSGIX face pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentMaterialfSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glFragmentMaterialfSGIX (coerce face) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentMaterialfSGIX" (LogV'Void)
#endif
    return _result

glFragmentMaterialfvSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> Ptr GL.GLfloat -> m ()
glFragmentMaterialfvSGIX face pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentMaterialfvSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentMaterialfvSGIX (coerce face) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentMaterialfvSGIX" (LogV'Void)
#endif
    return _result

glFragmentMaterialiSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> GL.GLint -> m ()
glFragmentMaterialiSGIX face pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentMaterialiSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glFragmentMaterialiSGIX (coerce face) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentMaterialiSGIX" (LogV'Void)
#endif
    return _result

glFragmentMaterialivSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> Ptr GL.GLint -> m ()
glFragmentMaterialivSGIX face pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFragmentMaterialivSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glFragmentMaterialivSGIX (coerce face) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glFragmentMaterialivSGIX" (LogV'Void)
#endif
    return _result

glFrameTerminatorGREMEDY :: MonadIO m => m ()
glFrameTerminatorGREMEDY  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFrameTerminatorGREMEDY" []
#endif
    _result <- GL.glFrameTerminatorGREMEDY 
#ifdef GLW_DEBUG
    logGLCommandEnd "glFrameTerminatorGREMEDY" (LogV'Void)
#endif
    return _result

glFrameZoomSGIX :: MonadIO m => GL.GLint -> m ()
glFrameZoomSGIX factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFrameZoomSGIX" [LogV'GLint factor]
#endif
    _result <- GL.glFrameZoomSGIX factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glFrameZoomSGIX" (LogV'Void)
#endif
    return _result

glFramebufferDrawBufferEXT :: MonadIO m => Framebuffer -> DrawBufferMode -> m ()
glFramebufferDrawBufferEXT framebuffer mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferDrawBufferEXT" [LogV'GLuint framebuffer, LogV'GLenum mode]
#endif
    _result <- GL.glFramebufferDrawBufferEXT (coerce framebuffer) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferDrawBufferEXT" (LogV'Void)
#endif
    return _result

glFramebufferDrawBuffersEXT :: MonadIO m => Framebuffer -> GL.GLsizei -> Ptr DrawBufferMode -> m ()
glFramebufferDrawBuffersEXT framebuffer n bufs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferDrawBuffersEXT" [LogV'GLuint framebuffer, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glFramebufferDrawBuffersEXT (coerce framebuffer) n (coerce bufs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferDrawBuffersEXT" (LogV'Void)
#endif
    return _result

glFramebufferParameteri :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLint -> m ()
glFramebufferParameteri target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferParameteri" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glFramebufferParameteri target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferParameteri" (LogV'Void)
#endif
    return _result

glFramebufferReadBufferEXT :: MonadIO m => Framebuffer -> ReadBufferMode -> m ()
glFramebufferReadBufferEXT framebuffer mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferReadBufferEXT" [LogV'GLuint framebuffer, LogV'GLenum mode]
#endif
    _result <- GL.glFramebufferReadBufferEXT (coerce framebuffer) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferReadBufferEXT" (LogV'Void)
#endif
    return _result

glFramebufferRenderbuffer :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Renderbuffer -> m ()
glFramebufferRenderbuffer target attachment renderbuffertarget renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferRenderbuffer" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum renderbuffertarget, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glFramebufferRenderbuffer target attachment renderbuffertarget (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferRenderbuffer" (LogV'Void)
#endif
    return _result

glFramebufferRenderbufferEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Renderbuffer -> m ()
glFramebufferRenderbufferEXT target attachment renderbuffertarget renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferRenderbufferEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum renderbuffertarget, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glFramebufferRenderbufferEXT target attachment renderbuffertarget (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferRenderbufferEXT" (LogV'Void)
#endif
    return _result

glFramebufferSampleLocationsfvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glFramebufferSampleLocationsfvARB target start count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferSampleLocationsfvARB" [LogV'GLenum target, LogV'GLuint start, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glFramebufferSampleLocationsfvARB target start count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferSampleLocationsfvARB" (LogV'Void)
#endif
    return _result

glFramebufferTexture :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTexture target attachment texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTexture target attachment (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture" (LogV'Void)
#endif
    return _result

glFramebufferTexture1D :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTexture1D target attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture1D" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTexture1D target attachment textarget (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture1D" (LogV'Void)
#endif
    return _result

glFramebufferTexture1DEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTexture1DEXT target attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture1DEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTexture1DEXT target attachment textarget (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture1DEXT" (LogV'Void)
#endif
    return _result

glFramebufferTexture2D :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTexture2D target attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture2D" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTexture2D target attachment textarget (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture2D" (LogV'Void)
#endif
    return _result

glFramebufferTexture2DEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTexture2DEXT target attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture2DEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTexture2DEXT target attachment textarget (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture2DEXT" (LogV'Void)
#endif
    return _result

glFramebufferTexture3D :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glFramebufferTexture3D target attachment textarget texture level zoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture3D" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level, LogV'GLint zoffset]
#endif
    _result <- GL.glFramebufferTexture3D target attachment textarget (coerce texture) level zoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture3D" (LogV'Void)
#endif
    return _result

glFramebufferTexture3DEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glFramebufferTexture3DEXT target attachment textarget texture level zoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTexture3DEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level, LogV'GLint zoffset]
#endif
    _result <- GL.glFramebufferTexture3DEXT target attachment textarget (coerce texture) level zoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTexture3DEXT" (LogV'Void)
#endif
    return _result

glFramebufferTextureARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTextureARB target attachment texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureARB" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTextureARB target attachment (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureARB" (LogV'Void)
#endif
    return _result

glFramebufferTextureEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glFramebufferTextureEXT target attachment texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glFramebufferTextureEXT target attachment (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureEXT" (LogV'Void)
#endif
    return _result

glFramebufferTextureFaceARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> TextureTarget -> m ()
glFramebufferTextureFaceARB target attachment texture level face = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureFaceARB" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLenum face]
#endif
    _result <- GL.glFramebufferTextureFaceARB target attachment (coerce texture) level (coerce face)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureFaceARB" (LogV'Void)
#endif
    return _result

glFramebufferTextureFaceEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> TextureTarget -> m ()
glFramebufferTextureFaceEXT target attachment texture level face = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureFaceEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLenum face]
#endif
    _result <- GL.glFramebufferTextureFaceEXT target attachment (coerce texture) level (coerce face)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureFaceEXT" (LogV'Void)
#endif
    return _result

glFramebufferTextureLayer :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glFramebufferTextureLayer target attachment texture level layer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureLayer" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLint layer]
#endif
    _result <- GL.glFramebufferTextureLayer target attachment (coerce texture) level layer
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureLayer" (LogV'Void)
#endif
    return _result

glFramebufferTextureLayerARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glFramebufferTextureLayerARB target attachment texture level layer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureLayerARB" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLint layer]
#endif
    _result <- GL.glFramebufferTextureLayerARB target attachment (coerce texture) level layer
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureLayerARB" (LogV'Void)
#endif
    return _result

glFramebufferTextureLayerEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glFramebufferTextureLayerEXT target attachment texture level layer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFramebufferTextureLayerEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLint layer]
#endif
    _result <- GL.glFramebufferTextureLayerEXT target attachment (coerce texture) level layer
#ifdef GLW_DEBUG
    logGLCommandEnd "glFramebufferTextureLayerEXT" (LogV'Void)
#endif
    return _result

glFreeObjectBufferATI :: MonadIO m => Buffer -> m ()
glFreeObjectBufferATI buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFreeObjectBufferATI" [LogV'GLuint buffer]
#endif
    _result <- GL.glFreeObjectBufferATI (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFreeObjectBufferATI" (LogV'Void)
#endif
    return _result

glFrontFace :: MonadIO m => FrontFaceDirection -> m ()
glFrontFace mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glFrontFace" [LogV'GLenum mode]
#endif
    _result <- GL.glFrontFace (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glFrontFace" (LogV'Void)
#endif
    return _result

glGenAsyncMarkersSGIX :: MonadIO m => GL.GLsizei -> m GL.GLuint
glGenAsyncMarkersSGIX range = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenAsyncMarkersSGIX" [LogV'GLsizei range]
#endif
    _result <- GL.glGenAsyncMarkersSGIX range
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenAsyncMarkersSGIX" (LogV'GLuint _result)
#endif
    return _result

glGenBuffers :: MonadIO m => GL.GLsizei -> Ptr Buffer -> m ()
glGenBuffers n buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenBuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenBuffers n (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenBuffers" (LogV'Void)
#endif
    return _result

glGenBuffersARB :: MonadIO m => GL.GLsizei -> Ptr Buffer -> m ()
glGenBuffersARB n buffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenBuffersARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenBuffersARB n (coerce buffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenBuffersARB" (LogV'Void)
#endif
    return _result

glGenFencesAPPLE :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glGenFencesAPPLE n fences = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenFencesAPPLE" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenFencesAPPLE n fences
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenFencesAPPLE" (LogV'Void)
#endif
    return _result

glGenFragmentShadersATI :: MonadIO m => GL.GLuint -> m GL.GLuint
glGenFragmentShadersATI range = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenFragmentShadersATI" [LogV'GLuint range]
#endif
    _result <- GL.glGenFragmentShadersATI range
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenFragmentShadersATI" (LogV'GLuint _result)
#endif
    return _result

glGenFramebuffers :: MonadIO m => GL.GLsizei -> Ptr Framebuffer -> m ()
glGenFramebuffers n framebuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenFramebuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenFramebuffers n (coerce framebuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenFramebuffers" (LogV'Void)
#endif
    return _result

glGenFramebuffersEXT :: MonadIO m => GL.GLsizei -> Ptr Framebuffer -> m ()
glGenFramebuffersEXT n framebuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenFramebuffersEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenFramebuffersEXT n (coerce framebuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenFramebuffersEXT" (LogV'Void)
#endif
    return _result

glGenNamesAMD :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glGenNamesAMD identifier num names = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenNamesAMD" [LogV'GLenum identifier, LogV'GLuint num, LogV'Ptr]
#endif
    _result <- GL.glGenNamesAMD identifier num names
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenNamesAMD" (LogV'Void)
#endif
    return _result

glGenOcclusionQueriesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLuint -> m ()
glGenOcclusionQueriesNV n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenOcclusionQueriesNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenOcclusionQueriesNV n ids
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenOcclusionQueriesNV" (LogV'Void)
#endif
    return _result

glGenProgramPipelines :: MonadIO m => GL.GLsizei -> Ptr ProgramPipeline -> m ()
glGenProgramPipelines n pipelines = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenProgramPipelines" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenProgramPipelines n (coerce pipelines)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenProgramPipelines" (LogV'Void)
#endif
    return _result

glGenProgramsARB :: MonadIO m => GL.GLsizei -> Ptr Program -> m ()
glGenProgramsARB n programs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenProgramsARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenProgramsARB n (coerce programs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenProgramsARB" (LogV'Void)
#endif
    return _result

glGenProgramsNV :: MonadIO m => GL.GLsizei -> Ptr Program -> m ()
glGenProgramsNV n programs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenProgramsNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenProgramsNV n (coerce programs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenProgramsNV" (LogV'Void)
#endif
    return _result

glGenQueries :: MonadIO m => GL.GLsizei -> Ptr (Query (a :: QueryTarget)) -> m ()
glGenQueries n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenQueries" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenQueries n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenQueries" (LogV'Void)
#endif
    return _result

glGenQueriesARB :: MonadIO m => GL.GLsizei -> Ptr (Query (a :: QueryTarget)) -> m ()
glGenQueriesARB n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenQueriesARB" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenQueriesARB n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenQueriesARB" (LogV'Void)
#endif
    return _result

glGenRenderbuffers :: MonadIO m => GL.GLsizei -> Ptr Renderbuffer -> m ()
glGenRenderbuffers n renderbuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenRenderbuffers" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenRenderbuffers n (coerce renderbuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenRenderbuffers" (LogV'Void)
#endif
    return _result

glGenRenderbuffersEXT :: MonadIO m => GL.GLsizei -> Ptr Renderbuffer -> m ()
glGenRenderbuffersEXT n renderbuffers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenRenderbuffersEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenRenderbuffersEXT n (coerce renderbuffers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenRenderbuffersEXT" (LogV'Void)
#endif
    return _result

glGenSamplers :: MonadIO m => GL.GLsizei -> Ptr Sampler -> m ()
glGenSamplers count samplers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenSamplers" [LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glGenSamplers count (coerce samplers)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenSamplers" (LogV'Void)
#endif
    return _result

glGenSymbolsEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLuint -> m GL.GLuint
glGenSymbolsEXT datatype storagetype range components = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenSymbolsEXT" [LogV'GLenum datatype, LogV'GLenum storagetype, LogV'GLenum range, LogV'GLuint components]
#endif
    _result <- GL.glGenSymbolsEXT datatype storagetype range components
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenSymbolsEXT" (LogV'GLuint _result)
#endif
    return _result

glGenTextures :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glGenTextures n textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenTextures" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenTextures n (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenTextures" (LogV'Void)
#endif
    return _result

glGenTexturesEXT :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> m ()
glGenTexturesEXT n textures = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenTexturesEXT" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenTexturesEXT n (coerce textures)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenTexturesEXT" (LogV'Void)
#endif
    return _result

glGenTransformFeedbacks :: MonadIO m => GL.GLsizei -> Ptr TransformFeedback -> m ()
glGenTransformFeedbacks n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenTransformFeedbacks" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenTransformFeedbacks n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenTransformFeedbacks" (LogV'Void)
#endif
    return _result

glGenTransformFeedbacksNV :: MonadIO m => GL.GLsizei -> Ptr TransformFeedback -> m ()
glGenTransformFeedbacksNV n ids = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenTransformFeedbacksNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenTransformFeedbacksNV n (coerce ids)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenTransformFeedbacksNV" (LogV'Void)
#endif
    return _result

glGenVertexArrays :: MonadIO m => GL.GLsizei -> Ptr VertexArray -> m ()
glGenVertexArrays n arrays = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenVertexArrays" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenVertexArrays n (coerce arrays)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenVertexArrays" (LogV'Void)
#endif
    return _result

glGenVertexArraysAPPLE :: MonadIO m => GL.GLsizei -> Ptr VertexArray -> m ()
glGenVertexArraysAPPLE n arrays = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenVertexArraysAPPLE" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glGenVertexArraysAPPLE n (coerce arrays)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenVertexArraysAPPLE" (LogV'Void)
#endif
    return _result

glGenVertexShadersEXT :: MonadIO m => GL.GLuint -> m GL.GLuint
glGenVertexShadersEXT range = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenVertexShadersEXT" [LogV'GLuint range]
#endif
    _result <- GL.glGenVertexShadersEXT range
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenVertexShadersEXT" (LogV'GLuint _result)
#endif
    return _result

glGenerateMipmap :: MonadIO m => GL.GLenum -> m ()
glGenerateMipmap target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenerateMipmap" [LogV'GLenum target]
#endif
    _result <- GL.glGenerateMipmap target
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenerateMipmap" (LogV'Void)
#endif
    return _result

glGenerateMipmapEXT :: MonadIO m => GL.GLenum -> m ()
glGenerateMipmapEXT target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenerateMipmapEXT" [LogV'GLenum target]
#endif
    _result <- GL.glGenerateMipmapEXT target
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenerateMipmapEXT" (LogV'Void)
#endif
    return _result

glGenerateMultiTexMipmapEXT :: MonadIO m => TextureUnit -> TextureTarget -> m ()
glGenerateMultiTexMipmapEXT texunit target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenerateMultiTexMipmapEXT" [LogV'GLenum texunit, LogV'GLenum target]
#endif
    _result <- GL.glGenerateMultiTexMipmapEXT (coerce texunit) (coerce target)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenerateMultiTexMipmapEXT" (LogV'Void)
#endif
    return _result

glGenerateTextureMipmap :: MonadIO m => Texture (a :: TextureTarget') -> m ()
glGenerateTextureMipmap texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenerateTextureMipmap" [LogV'GLuint texture]
#endif
    _result <- GL.glGenerateTextureMipmap (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenerateTextureMipmap" (LogV'Void)
#endif
    return _result

glGenerateTextureMipmapEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> m ()
glGenerateTextureMipmapEXT texture target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGenerateTextureMipmapEXT" [LogV'GLuint texture, LogV'GLenum target]
#endif
    _result <- GL.glGenerateTextureMipmapEXT (coerce texture) (coerce target)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGenerateTextureMipmapEXT" (LogV'Void)
#endif
    return _result

glGetActiveAtomicCounterBufferiv :: MonadIO m => Program -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetActiveAtomicCounterBufferiv program bufferIndex pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveAtomicCounterBufferiv" [LogV'GLuint program, LogV'GLuint bufferIndex, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetActiveAtomicCounterBufferiv (coerce program) bufferIndex pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveAtomicCounterBufferiv" (LogV'Void)
#endif
    return _result

glGetActiveAttrib :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> Ptr GL.GLenum -> Ptr GL.GLchar -> m ()
glGetActiveAttrib program index bufSize length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveAttrib" [LogV'GLuint program, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveAttrib (coerce program) index bufSize length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveAttrib" (LogV'Void)
#endif
    return _result

glGetActiveAttribARB :: MonadIO m => GL.GLhandleARB -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> Ptr GL.GLenum -> Ptr GL.GLcharARB -> m ()
glGetActiveAttribARB programObj index maxLength length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveAttribARB" [LogV'GLhandleARB programObj, LogV'GLuint index, LogV'GLsizei maxLength, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveAttribARB programObj index maxLength length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveAttribARB" (LogV'Void)
#endif
    return _result

glGetActiveSubroutineName :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetActiveSubroutineName program shadertype index bufsize length name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveSubroutineName" [LogV'GLuint program, LogV'GLenum shadertype, LogV'GLuint index, LogV'GLsizei bufsize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveSubroutineName (coerce program) shadertype index bufsize length name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveSubroutineName" (LogV'Void)
#endif
    return _result

glGetActiveSubroutineUniformName :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetActiveSubroutineUniformName program shadertype index bufsize length name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveSubroutineUniformName" [LogV'GLuint program, LogV'GLenum shadertype, LogV'GLuint index, LogV'GLsizei bufsize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveSubroutineUniformName (coerce program) shadertype index bufsize length name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveSubroutineUniformName" (LogV'Void)
#endif
    return _result

glGetActiveSubroutineUniformiv :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetActiveSubroutineUniformiv program shadertype index pname values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveSubroutineUniformiv" [LogV'GLuint program, LogV'GLenum shadertype, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetActiveSubroutineUniformiv (coerce program) shadertype index pname values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveSubroutineUniformiv" (LogV'Void)
#endif
    return _result

glGetActiveUniform :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> Ptr GL.GLenum -> Ptr GL.GLchar -> m ()
glGetActiveUniform program index bufSize length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniform" [LogV'GLuint program, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniform (coerce program) index bufSize length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniform" (LogV'Void)
#endif
    return _result

glGetActiveUniformARB :: MonadIO m => GL.GLhandleARB -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> Ptr GL.GLenum -> Ptr GL.GLcharARB -> m ()
glGetActiveUniformARB programObj index maxLength length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniformARB" [LogV'GLhandleARB programObj, LogV'GLuint index, LogV'GLsizei maxLength, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniformARB programObj index maxLength length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniformARB" (LogV'Void)
#endif
    return _result

glGetActiveUniformBlockName :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetActiveUniformBlockName program uniformBlockIndex bufSize length uniformBlockName = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniformBlockName" [LogV'GLuint program, LogV'GLuint uniformBlockIndex, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniformBlockName (coerce program) uniformBlockIndex bufSize length uniformBlockName
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniformBlockName" (LogV'Void)
#endif
    return _result

glGetActiveUniformBlockiv :: MonadIO m => Program -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetActiveUniformBlockiv program uniformBlockIndex pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniformBlockiv" [LogV'GLuint program, LogV'GLuint uniformBlockIndex, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniformBlockiv (coerce program) uniformBlockIndex pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniformBlockiv" (LogV'Void)
#endif
    return _result

glGetActiveUniformName :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetActiveUniformName program uniformIndex bufSize length uniformName = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniformName" [LogV'GLuint program, LogV'GLuint uniformIndex, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniformName (coerce program) uniformIndex bufSize length uniformName
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniformName" (LogV'Void)
#endif
    return _result

glGetActiveUniformsiv :: MonadIO m => Program -> GL.GLsizei -> Ptr GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetActiveUniformsiv program uniformCount uniformIndices pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveUniformsiv" [LogV'GLuint program, LogV'GLsizei uniformCount, LogV'Ptr, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetActiveUniformsiv (coerce program) uniformCount uniformIndices pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveUniformsiv" (LogV'Void)
#endif
    return _result

glGetActiveVaryingNV :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLenum -> Ptr GL.GLchar -> m ()
glGetActiveVaryingNV program index bufSize length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetActiveVaryingNV" [LogV'GLuint program, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetActiveVaryingNV (coerce program) index bufSize length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetActiveVaryingNV" (LogV'Void)
#endif
    return _result

glGetArrayObjectfvATI :: MonadIO m => EnableCap -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetArrayObjectfvATI array pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetArrayObjectfvATI" [LogV'GLenum array, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetArrayObjectfvATI (coerce array) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetArrayObjectfvATI" (LogV'Void)
#endif
    return _result

glGetArrayObjectivATI :: MonadIO m => EnableCap -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetArrayObjectivATI array pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetArrayObjectivATI" [LogV'GLenum array, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetArrayObjectivATI (coerce array) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetArrayObjectivATI" (LogV'Void)
#endif
    return _result

glGetAttachedObjectsARB :: MonadIO m => GL.GLhandleARB -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLhandleARB -> m ()
glGetAttachedObjectsARB containerObj maxCount count obj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetAttachedObjectsARB" [LogV'GLhandleARB containerObj, LogV'GLsizei maxCount, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetAttachedObjectsARB containerObj maxCount count obj
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetAttachedObjectsARB" (LogV'Void)
#endif
    return _result

glGetAttachedShaders :: MonadIO m => Program -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr (Shader (a :: ShaderType)) -> m ()
glGetAttachedShaders program maxCount count shaders = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetAttachedShaders" [LogV'GLuint program, LogV'GLsizei maxCount, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetAttachedShaders (coerce program) maxCount count (coerce shaders)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetAttachedShaders" (LogV'Void)
#endif
    return _result

glGetAttribLocation :: MonadIO m => Program -> Ptr GL.GLchar -> m (Maybe AttribLocation)
glGetAttribLocation program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetAttribLocation" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- fmap (AttribLocation . fromIntegral) . validate (>= 0) <$> GL.glGetAttribLocation (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetAttribLocation" (LogV'GLint _result)
#endif
    return _result

glGetAttribLocationARB :: MonadIO m => GL.GLhandleARB -> Ptr GL.GLcharARB -> m (Maybe AttribLocation)
glGetAttribLocationARB programObj name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetAttribLocationARB" [LogV'GLhandleARB programObj, LogV'Ptr]
#endif
    _result <- fmap (AttribLocation . fromIntegral) . validate (>= 0) <$> GL.glGetAttribLocationARB programObj name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetAttribLocationARB" (LogV'GLint _result)
#endif
    return _result

glGetBooleanIndexedvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr Boolean -> m ()
glGetBooleanIndexedvEXT target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBooleanIndexedvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetBooleanIndexedvEXT target index (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBooleanIndexedvEXT" (LogV'Void)
#endif
    return _result

glGetBooleani_v :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr Boolean -> m ()
glGetBooleani_v target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBooleani_v" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetBooleani_v target index (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBooleani_v" (LogV'Void)
#endif
    return _result

glGetBooleanv :: MonadIO m => GetPName -> Ptr Boolean -> m ()
glGetBooleanv pname data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBooleanv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBooleanv (coerce pname) (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBooleanv" (LogV'Void)
#endif
    return _result

glGetBufferParameteri64v :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetBufferParameteri64v target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferParameteri64v" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferParameteri64v target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferParameteri64v" (LogV'Void)
#endif
    return _result

glGetBufferParameteriv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetBufferParameteriv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferParameteriv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferParameteriv target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferParameteriv" (LogV'Void)
#endif
    return _result

glGetBufferParameterivARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetBufferParameterivARB target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferParameterivARB" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferParameterivARB target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferParameterivARB" (LogV'Void)
#endif
    return _result

glGetBufferParameterui64vNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLuint64EXT -> m ()
glGetBufferParameterui64vNV target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferParameterui64vNV" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferParameterui64vNV target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferParameterui64vNV" (LogV'Void)
#endif
    return _result

glGetBufferPointerv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetBufferPointerv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferPointerv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferPointerv target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferPointerv" (LogV'Void)
#endif
    return _result

glGetBufferPointervARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetBufferPointervARB target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferPointervARB" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetBufferPointervARB target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferPointervARB" (LogV'Void)
#endif
    return _result

glGetBufferSubData :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glGetBufferSubData target offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferSubData" [LogV'GLenum target, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glGetBufferSubData target offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferSubData" (LogV'Void)
#endif
    return _result

glGetBufferSubDataARB :: MonadIO m => GL.GLenum -> GL.GLintptrARB -> GL.GLsizeiptrARB -> Ptr () -> m ()
glGetBufferSubDataARB target offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetBufferSubDataARB" [LogV'GLenum target, LogV'GLintptrARB offset, LogV'GLsizeiptrARB size, LogV'Ptr]
#endif
    _result <- GL.glGetBufferSubDataARB target offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetBufferSubDataARB" (LogV'Void)
#endif
    return _result

glGetColorTableEXT :: MonadIO m => GL.GLenum -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetColorTableEXT target format type' data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableEXT" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetColorTableEXT target (coerce format) (coerce type') data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableEXT" (LogV'Void)
#endif
    return _result

glGetColorTableParameterfvEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetColorTableParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetColorTableParameterfvEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetColorTableParameterfvSGI :: MonadIO m => ColorTableTargetSGI -> GetColorTableParameterPNameSGI -> Ptr GL.GLfloat -> m ()
glGetColorTableParameterfvSGI target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableParameterfvSGI" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetColorTableParameterfvSGI (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableParameterfvSGI" (LogV'Void)
#endif
    return _result

glGetColorTableParameterivEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetColorTableParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetColorTableParameterivEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableParameterivEXT" (LogV'Void)
#endif
    return _result

glGetColorTableParameterivSGI :: MonadIO m => ColorTableTargetSGI -> GetColorTableParameterPNameSGI -> Ptr GL.GLint -> m ()
glGetColorTableParameterivSGI target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableParameterivSGI" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetColorTableParameterivSGI (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableParameterivSGI" (LogV'Void)
#endif
    return _result

glGetColorTableSGI :: MonadIO m => ColorTableTargetSGI -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetColorTableSGI target format type' table = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetColorTableSGI" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetColorTableSGI (coerce target) (coerce format) (coerce type') table
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetColorTableSGI" (LogV'Void)
#endif
    return _result

glGetCombinerInputParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetCombinerInputParameterfvNV stage portion variable pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCombinerInputParameterfvNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum variable, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetCombinerInputParameterfvNV stage portion variable pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCombinerInputParameterfvNV" (LogV'Void)
#endif
    return _result

glGetCombinerInputParameterivNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetCombinerInputParameterivNV stage portion variable pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCombinerInputParameterivNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum variable, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetCombinerInputParameterivNV stage portion variable pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCombinerInputParameterivNV" (LogV'Void)
#endif
    return _result

glGetCombinerOutputParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetCombinerOutputParameterfvNV stage portion pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCombinerOutputParameterfvNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetCombinerOutputParameterfvNV stage portion pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCombinerOutputParameterfvNV" (LogV'Void)
#endif
    return _result

glGetCombinerOutputParameterivNV :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetCombinerOutputParameterivNV stage portion pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCombinerOutputParameterivNV" [LogV'GLenum stage, LogV'GLenum portion, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetCombinerOutputParameterivNV stage portion pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCombinerOutputParameterivNV" (LogV'Void)
#endif
    return _result

glGetCombinerStageParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetCombinerStageParameterfvNV stage pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCombinerStageParameterfvNV" [LogV'GLenum stage, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetCombinerStageParameterfvNV stage pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCombinerStageParameterfvNV" (LogV'Void)
#endif
    return _result

glGetCommandHeaderNV :: MonadIO m => GL.GLenum -> GL.GLuint -> m GL.GLuint
glGetCommandHeaderNV tokenID size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCommandHeaderNV" [LogV'GLenum tokenID, LogV'GLuint size]
#endif
    _result <- GL.glGetCommandHeaderNV tokenID size
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCommandHeaderNV" (LogV'GLuint _result)
#endif
    return _result

glGetCompressedMultiTexImageEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> Ptr () -> m ()
glGetCompressedMultiTexImageEXT texunit target lod img = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedMultiTexImageEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint lod, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedMultiTexImageEXT (coerce texunit) (coerce target) lod img
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedMultiTexImageEXT" (LogV'Void)
#endif
    return _result

glGetCompressedTexImage :: MonadIO m => TextureTarget -> GL.GLint -> Ptr () -> m ()
glGetCompressedTexImage target level img = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedTexImage" [LogV'GLenum target, LogV'GLint level, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedTexImage (coerce target) level img
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedTexImage" (LogV'Void)
#endif
    return _result

glGetCompressedTexImageARB :: MonadIO m => TextureTarget -> GL.GLint -> Ptr () -> m ()
glGetCompressedTexImageARB target level img = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedTexImageARB" [LogV'GLenum target, LogV'GLint level, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedTexImageARB (coerce target) level img
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedTexImageARB" (LogV'Void)
#endif
    return _result

glGetCompressedTextureImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glGetCompressedTextureImage texture level bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedTextureImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedTextureImage (coerce texture) level bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedTextureImage" (LogV'Void)
#endif
    return _result

glGetCompressedTextureImageEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> Ptr () -> m ()
glGetCompressedTextureImageEXT texture target lod img = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedTextureImageEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint lod, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedTextureImageEXT (coerce texture) (coerce target) lod img
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedTextureImageEXT" (LogV'Void)
#endif
    return _result

glGetCompressedTextureSubImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glGetCompressedTextureSubImage texture level xoffset yoffset zoffset width height depth bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetCompressedTextureSubImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetCompressedTextureSubImage (coerce texture) level xoffset yoffset zoffset width height depth bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetCompressedTextureSubImage" (LogV'Void)
#endif
    return _result

glGetConvolutionFilterEXT :: MonadIO m => ConvolutionTargetEXT -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetConvolutionFilterEXT target format type' image = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetConvolutionFilterEXT" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetConvolutionFilterEXT (coerce target) (coerce format) (coerce type') image
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetConvolutionFilterEXT" (LogV'Void)
#endif
    return _result

glGetConvolutionParameterfvEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> Ptr GL.GLfloat -> m ()
glGetConvolutionParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetConvolutionParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetConvolutionParameterfvEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetConvolutionParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetConvolutionParameterivEXT :: MonadIO m => ConvolutionTargetEXT -> ConvolutionParameterEXT -> Ptr GL.GLint -> m ()
glGetConvolutionParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetConvolutionParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetConvolutionParameterivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetConvolutionParameterivEXT" (LogV'Void)
#endif
    return _result

glGetDebugMessageLog :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLenum -> Ptr GL.GLenum -> Ptr GL.GLuint -> Ptr GL.GLenum -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m GL.GLuint
glGetDebugMessageLog count bufSize sources types ids severities lengths messageLog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDebugMessageLog" [LogV'GLuint count, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetDebugMessageLog count bufSize sources types ids severities lengths messageLog
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDebugMessageLog" (LogV'GLuint _result)
#endif
    return _result

glGetDebugMessageLogAMD :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLenum -> Ptr GL.GLuint -> Ptr GL.GLuint -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m GL.GLuint
glGetDebugMessageLogAMD count bufsize categories severities ids lengths message = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDebugMessageLogAMD" [LogV'GLuint count, LogV'GLsizei bufsize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetDebugMessageLogAMD count bufsize categories severities ids lengths message
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDebugMessageLogAMD" (LogV'GLuint _result)
#endif
    return _result

glGetDetailTexFuncSGIS :: MonadIO m => TextureTarget -> Ptr GL.GLfloat -> m ()
glGetDetailTexFuncSGIS target points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDetailTexFuncSGIS" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glGetDetailTexFuncSGIS (coerce target) points
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDetailTexFuncSGIS" (LogV'Void)
#endif
    return _result

glGetDoubleIndexedvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetDoubleIndexedvEXT target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDoubleIndexedvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetDoubleIndexedvEXT target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDoubleIndexedvEXT" (LogV'Void)
#endif
    return _result

glGetDoublei_v :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetDoublei_v target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDoublei_v" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetDoublei_v target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDoublei_v" (LogV'Void)
#endif
    return _result

glGetDoublei_vEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetDoublei_vEXT pname index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDoublei_vEXT" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetDoublei_vEXT pname index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDoublei_vEXT" (LogV'Void)
#endif
    return _result

glGetDoublev :: MonadIO m => GetPName -> Ptr GL.GLdouble -> m ()
glGetDoublev pname data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetDoublev" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetDoublev (coerce pname) data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetDoublev" (LogV'Void)
#endif
    return _result

glGetError :: MonadIO m => m ErrorCode
glGetError  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetError" []
#endif
    _result <- coerce <$> GL.glGetError 
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetError" (LogV'GLenum _result)
#endif
    return _result

glGetFinalCombinerInputParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetFinalCombinerInputParameterfvNV variable pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFinalCombinerInputParameterfvNV" [LogV'GLenum variable, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFinalCombinerInputParameterfvNV variable pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFinalCombinerInputParameterfvNV" (LogV'Void)
#endif
    return _result

glGetFinalCombinerInputParameterivNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFinalCombinerInputParameterivNV variable pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFinalCombinerInputParameterivNV" [LogV'GLenum variable, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFinalCombinerInputParameterivNV variable pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFinalCombinerInputParameterivNV" (LogV'Void)
#endif
    return _result

glGetFloatIndexedvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetFloatIndexedvEXT target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFloatIndexedvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetFloatIndexedvEXT target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFloatIndexedvEXT" (LogV'Void)
#endif
    return _result

glGetFloati_v :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetFloati_v target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFloati_v" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetFloati_v target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFloati_v" (LogV'Void)
#endif
    return _result

glGetFloati_vEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetFloati_vEXT pname index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFloati_vEXT" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetFloati_vEXT pname index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFloati_vEXT" (LogV'Void)
#endif
    return _result

glGetFloatv :: MonadIO m => GetPName -> Ptr GL.GLfloat -> m ()
glGetFloatv pname data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFloatv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFloatv (coerce pname) data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFloatv" (LogV'Void)
#endif
    return _result

glGetFogFuncSGIS :: MonadIO m => Ptr GL.GLfloat -> m ()
glGetFogFuncSGIS points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFogFuncSGIS" [LogV'Ptr]
#endif
    _result <- GL.glGetFogFuncSGIS points
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFogFuncSGIS" (LogV'Void)
#endif
    return _result

glGetFragDataIndex :: MonadIO m => Program -> Ptr GL.GLchar -> m GL.GLint
glGetFragDataIndex program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragDataIndex" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glGetFragDataIndex (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragDataIndex" (LogV'GLint _result)
#endif
    return _result

glGetFragDataLocation :: MonadIO m => Program -> Ptr GL.GLchar -> m GL.GLint
glGetFragDataLocation program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragDataLocation" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glGetFragDataLocation (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragDataLocation" (LogV'GLint _result)
#endif
    return _result

glGetFragDataLocationEXT :: MonadIO m => Program -> Ptr GL.GLchar -> m GL.GLint
glGetFragDataLocationEXT program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragDataLocationEXT" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glGetFragDataLocationEXT (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragDataLocationEXT" (LogV'GLint _result)
#endif
    return _result

glGetFragmentLightfvSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetFragmentLightfvSGIX light pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragmentLightfvSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFragmentLightfvSGIX light pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragmentLightfvSGIX" (LogV'Void)
#endif
    return _result

glGetFragmentLightivSGIX :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFragmentLightivSGIX light pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragmentLightivSGIX" [LogV'GLenum light, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFragmentLightivSGIX light pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragmentLightivSGIX" (LogV'Void)
#endif
    return _result

glGetFragmentMaterialfvSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> Ptr GL.GLfloat -> m ()
glGetFragmentMaterialfvSGIX face pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragmentMaterialfvSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFragmentMaterialfvSGIX (coerce face) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragmentMaterialfvSGIX" (LogV'Void)
#endif
    return _result

glGetFragmentMaterialivSGIX :: MonadIO m => MaterialFace -> MaterialParameter -> Ptr GL.GLint -> m ()
glGetFragmentMaterialivSGIX face pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFragmentMaterialivSGIX" [LogV'GLenum face, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFragmentMaterialivSGIX (coerce face) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFragmentMaterialivSGIX" (LogV'Void)
#endif
    return _result

glGetFramebufferAttachmentParameteriv :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFramebufferAttachmentParameteriv target attachment pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFramebufferAttachmentParameteriv" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFramebufferAttachmentParameteriv target attachment pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFramebufferAttachmentParameteriv" (LogV'Void)
#endif
    return _result

glGetFramebufferAttachmentParameterivEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFramebufferAttachmentParameterivEXT target attachment pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFramebufferAttachmentParameterivEXT" [LogV'GLenum target, LogV'GLenum attachment, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFramebufferAttachmentParameterivEXT target attachment pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFramebufferAttachmentParameterivEXT" (LogV'Void)
#endif
    return _result

glGetFramebufferParameteriv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFramebufferParameteriv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFramebufferParameteriv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFramebufferParameteriv target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFramebufferParameteriv" (LogV'Void)
#endif
    return _result

glGetFramebufferParameterivEXT :: MonadIO m => Framebuffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetFramebufferParameterivEXT framebuffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetFramebufferParameterivEXT" [LogV'GLuint framebuffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetFramebufferParameterivEXT (coerce framebuffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetFramebufferParameterivEXT" (LogV'Void)
#endif
    return _result

glGetGraphicsResetStatus :: MonadIO m => m GL.GLenum
glGetGraphicsResetStatus  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetGraphicsResetStatus" []
#endif
    _result <- GL.glGetGraphicsResetStatus 
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetGraphicsResetStatus" (LogV'GLenum _result)
#endif
    return _result

glGetHandleARB :: MonadIO m => GL.GLenum -> m GL.GLhandleARB
glGetHandleARB pname = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetHandleARB" [LogV'GLenum pname]
#endif
    _result <- GL.glGetHandleARB pname
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetHandleARB" (LogV'GLhandleARB _result)
#endif
    return _result

glGetHistogramEXT :: MonadIO m => HistogramTargetEXT -> Boolean -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetHistogramEXT target reset format type' values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetHistogramEXT" [LogV'GLenum target, LogV'GLboolean reset, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetHistogramEXT (coerce target) (coerce reset) (coerce format) (coerce type') values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetHistogramEXT" (LogV'Void)
#endif
    return _result

glGetHistogramParameterfvEXT :: MonadIO m => HistogramTargetEXT -> GetHistogramParameterPNameEXT -> Ptr GL.GLfloat -> m ()
glGetHistogramParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetHistogramParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetHistogramParameterfvEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetHistogramParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetHistogramParameterivEXT :: MonadIO m => HistogramTargetEXT -> GetHistogramParameterPNameEXT -> Ptr GL.GLint -> m ()
glGetHistogramParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetHistogramParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetHistogramParameterivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetHistogramParameterivEXT" (LogV'Void)
#endif
    return _result

glGetImageTransformParameterfvHP :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetImageTransformParameterfvHP target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetImageTransformParameterfvHP" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetImageTransformParameterfvHP target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetImageTransformParameterfvHP" (LogV'Void)
#endif
    return _result

glGetImageTransformParameterivHP :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetImageTransformParameterivHP target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetImageTransformParameterivHP" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetImageTransformParameterivHP target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetImageTransformParameterivHP" (LogV'Void)
#endif
    return _result

glGetInfoLogARB :: MonadIO m => GL.GLhandleARB -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLcharARB -> m ()
glGetInfoLogARB obj maxLength length infoLog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInfoLogARB" [LogV'GLhandleARB obj, LogV'GLsizei maxLength, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetInfoLogARB obj maxLength length infoLog
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInfoLogARB" (LogV'Void)
#endif
    return _result

glGetInstrumentsSGIX :: MonadIO m => m GL.GLint
glGetInstrumentsSGIX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInstrumentsSGIX" []
#endif
    _result <- GL.glGetInstrumentsSGIX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInstrumentsSGIX" (LogV'GLint _result)
#endif
    return _result

glGetInteger64i_v :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint64 -> m ()
glGetInteger64i_v target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInteger64i_v" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetInteger64i_v target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInteger64i_v" (LogV'Void)
#endif
    return _result

glGetInteger64v :: MonadIO m => GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetInteger64v pname data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInteger64v" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetInteger64v pname data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInteger64v" (LogV'Void)
#endif
    return _result

glGetIntegerIndexedvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetIntegerIndexedvEXT target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetIntegerIndexedvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetIntegerIndexedvEXT target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetIntegerIndexedvEXT" (LogV'Void)
#endif
    return _result

glGetIntegeri_v :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetIntegeri_v target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetIntegeri_v" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetIntegeri_v target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetIntegeri_v" (LogV'Void)
#endif
    return _result

glGetIntegerui64i_vNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint64EXT -> m ()
glGetIntegerui64i_vNV value index result = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetIntegerui64i_vNV" [LogV'GLenum value, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetIntegerui64i_vNV value index result
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetIntegerui64i_vNV" (LogV'Void)
#endif
    return _result

glGetIntegerui64vNV :: MonadIO m => GL.GLenum -> Ptr GL.GLuint64EXT -> m ()
glGetIntegerui64vNV value result = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetIntegerui64vNV" [LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetIntegerui64vNV value result
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetIntegerui64vNV" (LogV'Void)
#endif
    return _result

glGetIntegerv :: MonadIO m => GetPName -> Ptr GL.GLint -> m ()
glGetIntegerv pname data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetIntegerv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetIntegerv (coerce pname) data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetIntegerv" (LogV'Void)
#endif
    return _result

glGetInternalformati64v :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glGetInternalformati64v target internalformat pname bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInternalformati64v" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLenum pname, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetInternalformati64v target internalformat pname bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInternalformati64v" (LogV'Void)
#endif
    return _result

glGetInternalformativ :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLint -> m ()
glGetInternalformativ target internalformat pname bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInternalformativ" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLenum pname, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetInternalformativ target internalformat pname bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInternalformativ" (LogV'Void)
#endif
    return _result

glGetInvariantBooleanvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr Boolean -> m ()
glGetInvariantBooleanvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInvariantBooleanvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetInvariantBooleanvEXT id value (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInvariantBooleanvEXT" (LogV'Void)
#endif
    return _result

glGetInvariantFloatvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetInvariantFloatvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInvariantFloatvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetInvariantFloatvEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInvariantFloatvEXT" (LogV'Void)
#endif
    return _result

glGetInvariantIntegervEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetInvariantIntegervEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetInvariantIntegervEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetInvariantIntegervEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetInvariantIntegervEXT" (LogV'Void)
#endif
    return _result

glGetListParameterfvSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> Ptr GL.GLfloat -> m ()
glGetListParameterfvSGIX list pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetListParameterfvSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetListParameterfvSGIX list (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetListParameterfvSGIX" (LogV'Void)
#endif
    return _result

glGetListParameterivSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> Ptr GL.GLint -> m ()
glGetListParameterivSGIX list pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetListParameterivSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetListParameterivSGIX list (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetListParameterivSGIX" (LogV'Void)
#endif
    return _result

glGetLocalConstantBooleanvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr Boolean -> m ()
glGetLocalConstantBooleanvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetLocalConstantBooleanvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetLocalConstantBooleanvEXT id value (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetLocalConstantBooleanvEXT" (LogV'Void)
#endif
    return _result

glGetLocalConstantFloatvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetLocalConstantFloatvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetLocalConstantFloatvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetLocalConstantFloatvEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetLocalConstantFloatvEXT" (LogV'Void)
#endif
    return _result

glGetLocalConstantIntegervEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetLocalConstantIntegervEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetLocalConstantIntegervEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetLocalConstantIntegervEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetLocalConstantIntegervEXT" (LogV'Void)
#endif
    return _result

glGetMapAttribParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetMapAttribParameterfvNV target index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMapAttribParameterfvNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMapAttribParameterfvNV target index pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMapAttribParameterfvNV" (LogV'Void)
#endif
    return _result

glGetMapAttribParameterivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetMapAttribParameterivNV target index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMapAttribParameterivNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMapAttribParameterivNV target index pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMapAttribParameterivNV" (LogV'Void)
#endif
    return _result

glGetMapControlPointsNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> Boolean -> Ptr () -> m ()
glGetMapControlPointsNV target index type' ustride vstride packed points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMapControlPointsNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum type', LogV'GLsizei ustride, LogV'GLsizei vstride, LogV'GLboolean packed, LogV'Ptr]
#endif
    _result <- GL.glGetMapControlPointsNV target index type' ustride vstride (coerce packed) points
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMapControlPointsNV" (LogV'Void)
#endif
    return _result

glGetMapParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetMapParameterfvNV target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMapParameterfvNV" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMapParameterfvNV target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMapParameterfvNV" (LogV'Void)
#endif
    return _result

glGetMapParameterivNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetMapParameterivNV target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMapParameterivNV" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMapParameterivNV target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMapParameterivNV" (LogV'Void)
#endif
    return _result

glGetMinmaxEXT :: MonadIO m => MinmaxTargetEXT -> Boolean -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetMinmaxEXT target reset format type' values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMinmaxEXT" [LogV'GLenum target, LogV'GLboolean reset, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetMinmaxEXT (coerce target) (coerce reset) (coerce format) (coerce type') values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMinmaxEXT" (LogV'Void)
#endif
    return _result

glGetMinmaxParameterfvEXT :: MonadIO m => MinmaxTargetEXT -> GetMinmaxParameterPNameEXT -> Ptr GL.GLfloat -> m ()
glGetMinmaxParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMinmaxParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMinmaxParameterfvEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMinmaxParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetMinmaxParameterivEXT :: MonadIO m => MinmaxTargetEXT -> GetMinmaxParameterPNameEXT -> Ptr GL.GLint -> m ()
glGetMinmaxParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMinmaxParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMinmaxParameterivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMinmaxParameterivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexEnvfvEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> Ptr GL.GLfloat -> m ()
glGetMultiTexEnvfvEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexEnvfvEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexEnvfvEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexEnvfvEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexEnvivEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> Ptr GL.GLint -> m ()
glGetMultiTexEnvivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexEnvivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexEnvivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexEnvivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexGendvEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLdouble -> m ()
glGetMultiTexGendvEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexGendvEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexGendvEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexGendvEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexGenfvEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLfloat -> m ()
glGetMultiTexGenfvEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexGenfvEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexGenfvEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexGenfvEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexGenivEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLint -> m ()
glGetMultiTexGenivEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexGenivEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexGenivEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexGenivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexImageEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetMultiTexImageEXT texunit target level format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexImageEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexImageEXT (coerce texunit) (coerce target) level (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexImageEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexLevelParameterfvEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetMultiTexLevelParameterfvEXT texunit target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexLevelParameterfvEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexLevelParameterfvEXT (coerce texunit) (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexLevelParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexLevelParameterivEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetMultiTexLevelParameterivEXT texunit target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexLevelParameterivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexLevelParameterivEXT (coerce texunit) (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexLevelParameterivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexParameterIivEXT :: MonadIO m => TextureUnit -> TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetMultiTexParameterIivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexParameterIivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexParameterIivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexParameterIivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexParameterIuivEXT :: MonadIO m => TextureUnit -> TextureTarget -> GetTextureParameter -> Ptr GL.GLuint -> m ()
glGetMultiTexParameterIuivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexParameterIuivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexParameterIuivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexParameterIuivEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexParameterfvEXT :: MonadIO m => TextureUnit -> TextureTarget -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetMultiTexParameterfvEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexParameterfvEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexParameterfvEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetMultiTexParameterivEXT :: MonadIO m => TextureUnit -> TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetMultiTexParameterivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultiTexParameterivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetMultiTexParameterivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultiTexParameterivEXT" (LogV'Void)
#endif
    return _result

glGetMultisamplefv :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetMultisamplefv pname index val = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultisamplefv" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetMultisamplefv pname index val
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultisamplefv" (LogV'Void)
#endif
    return _result

glGetMultisamplefvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetMultisamplefvNV pname index val = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetMultisamplefvNV" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetMultisamplefvNV pname index val
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetMultisamplefvNV" (LogV'Void)
#endif
    return _result

glGetNamedBufferParameteri64v :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetNamedBufferParameteri64v buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferParameteri64v" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferParameteri64v (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferParameteri64v" (LogV'Void)
#endif
    return _result

glGetNamedBufferParameteriv :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedBufferParameteriv buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferParameteriv" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferParameteriv (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferParameteriv" (LogV'Void)
#endif
    return _result

glGetNamedBufferParameterivEXT :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedBufferParameterivEXT buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferParameterivEXT" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferParameterivEXT (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferParameterivEXT" (LogV'Void)
#endif
    return _result

glGetNamedBufferParameterui64vNV :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLuint64EXT -> m ()
glGetNamedBufferParameterui64vNV buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferParameterui64vNV" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferParameterui64vNV (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferParameterui64vNV" (LogV'Void)
#endif
    return _result

glGetNamedBufferPointerv :: MonadIO m => Buffer -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetNamedBufferPointerv buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferPointerv" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferPointerv (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferPointerv" (LogV'Void)
#endif
    return _result

glGetNamedBufferPointervEXT :: MonadIO m => Buffer -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetNamedBufferPointervEXT buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferPointervEXT" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferPointervEXT (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferPointervEXT" (LogV'Void)
#endif
    return _result

glGetNamedBufferSubData :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glGetNamedBufferSubData buffer offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferSubData" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferSubData (coerce buffer) offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferSubData" (LogV'Void)
#endif
    return _result

glGetNamedBufferSubDataEXT :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glGetNamedBufferSubDataEXT buffer offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedBufferSubDataEXT" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glGetNamedBufferSubDataEXT (coerce buffer) offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedBufferSubDataEXT" (LogV'Void)
#endif
    return _result

glGetNamedFramebufferAttachmentParameteriv :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedFramebufferAttachmentParameteriv framebuffer attachment pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedFramebufferAttachmentParameteriv" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedFramebufferAttachmentParameteriv (coerce framebuffer) attachment pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedFramebufferAttachmentParameteriv" (LogV'Void)
#endif
    return _result

glGetNamedFramebufferAttachmentParameterivEXT :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedFramebufferAttachmentParameterivEXT framebuffer attachment pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedFramebufferAttachmentParameterivEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedFramebufferAttachmentParameterivEXT (coerce framebuffer) attachment pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedFramebufferAttachmentParameterivEXT" (LogV'Void)
#endif
    return _result

glGetNamedFramebufferParameteriv :: MonadIO m => Framebuffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedFramebufferParameteriv framebuffer pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedFramebufferParameteriv" [LogV'GLuint framebuffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedFramebufferParameteriv (coerce framebuffer) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedFramebufferParameteriv" (LogV'Void)
#endif
    return _result

glGetNamedFramebufferParameterivEXT :: MonadIO m => Framebuffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedFramebufferParameterivEXT framebuffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedFramebufferParameterivEXT" [LogV'GLuint framebuffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedFramebufferParameterivEXT (coerce framebuffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedFramebufferParameterivEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramLocalParameterIivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetNamedProgramLocalParameterIivEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramLocalParameterIivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramLocalParameterIivEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramLocalParameterIivEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramLocalParameterIuivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glGetNamedProgramLocalParameterIuivEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramLocalParameterIuivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramLocalParameterIuivEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramLocalParameterIuivEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramLocalParameterdvEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetNamedProgramLocalParameterdvEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramLocalParameterdvEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramLocalParameterdvEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramLocalParameterdvEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramLocalParameterfvEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetNamedProgramLocalParameterfvEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramLocalParameterfvEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramLocalParameterfvEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramLocalParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramStringEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glGetNamedProgramStringEXT program target pname string = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramStringEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramStringEXT (coerce program) target pname string
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramStringEXT" (LogV'Void)
#endif
    return _result

glGetNamedProgramivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedProgramivEXT program target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedProgramivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedProgramivEXT (coerce program) target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedProgramivEXT" (LogV'Void)
#endif
    return _result

glGetNamedRenderbufferParameteriv :: MonadIO m => Renderbuffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedRenderbufferParameteriv renderbuffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedRenderbufferParameteriv" [LogV'GLuint renderbuffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedRenderbufferParameteriv (coerce renderbuffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedRenderbufferParameteriv" (LogV'Void)
#endif
    return _result

glGetNamedRenderbufferParameterivEXT :: MonadIO m => Renderbuffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetNamedRenderbufferParameterivEXT renderbuffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetNamedRenderbufferParameterivEXT" [LogV'GLuint renderbuffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetNamedRenderbufferParameterivEXT (coerce renderbuffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetNamedRenderbufferParameterivEXT" (LogV'Void)
#endif
    return _result

glGetObjectBufferfvATI :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetObjectBufferfvATI buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectBufferfvATI" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetObjectBufferfvATI (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectBufferfvATI" (LogV'Void)
#endif
    return _result

glGetObjectBufferivATI :: MonadIO m => Buffer -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetObjectBufferivATI buffer pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectBufferivATI" [LogV'GLuint buffer, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetObjectBufferivATI (coerce buffer) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectBufferivATI" (LogV'Void)
#endif
    return _result

glGetObjectLabel :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetObjectLabel identifier name bufSize length label = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectLabel" [LogV'GLenum identifier, LogV'GLuint name, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetObjectLabel identifier name bufSize length label
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectLabel" (LogV'Void)
#endif
    return _result

glGetObjectParameterfvARB :: MonadIO m => GL.GLhandleARB -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetObjectParameterfvARB obj pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectParameterfvARB" [LogV'GLhandleARB obj, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetObjectParameterfvARB obj pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectParameterfvARB" (LogV'Void)
#endif
    return _result

glGetObjectParameterivAPPLE :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetObjectParameterivAPPLE objectType name pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectParameterivAPPLE" [LogV'GLenum objectType, LogV'GLuint name, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetObjectParameterivAPPLE objectType name pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectParameterivAPPLE" (LogV'Void)
#endif
    return _result

glGetObjectParameterivARB :: MonadIO m => GL.GLhandleARB -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetObjectParameterivARB obj pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectParameterivARB" [LogV'GLhandleARB obj, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetObjectParameterivARB obj pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectParameterivARB" (LogV'Void)
#endif
    return _result

glGetObjectPtrLabel :: MonadIO m => Ptr () -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetObjectPtrLabel ptr bufSize length label = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetObjectPtrLabel" [LogV'Ptr, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetObjectPtrLabel ptr bufSize length label
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetObjectPtrLabel" (LogV'Void)
#endif
    return _result

glGetOcclusionQueryivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetOcclusionQueryivNV id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetOcclusionQueryivNV" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetOcclusionQueryivNV id pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetOcclusionQueryivNV" (LogV'Void)
#endif
    return _result

glGetOcclusionQueryuivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetOcclusionQueryuivNV id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetOcclusionQueryuivNV" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetOcclusionQueryuivNV id pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetOcclusionQueryuivNV" (LogV'Void)
#endif
    return _result

glGetPixelTexGenParameterfvSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> Ptr GL.GLfloat -> m ()
glGetPixelTexGenParameterfvSGIS pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPixelTexGenParameterfvSGIS" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetPixelTexGenParameterfvSGIS (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPixelTexGenParameterfvSGIS" (LogV'Void)
#endif
    return _result

glGetPixelTexGenParameterivSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> Ptr GL.GLint -> m ()
glGetPixelTexGenParameterivSGIS pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPixelTexGenParameterivSGIS" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetPixelTexGenParameterivSGIS (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPixelTexGenParameterivSGIS" (LogV'Void)
#endif
    return _result

glGetPixelTransformParameterfvEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetPixelTransformParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPixelTransformParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetPixelTransformParameterfvEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPixelTransformParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetPixelTransformParameterivEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetPixelTransformParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPixelTransformParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetPixelTransformParameterivEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPixelTransformParameterivEXT" (LogV'Void)
#endif
    return _result

glGetPointerIndexedvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr (Ptr ()) -> m ()
glGetPointerIndexedvEXT target index data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPointerIndexedvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetPointerIndexedvEXT target index data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPointerIndexedvEXT" (LogV'Void)
#endif
    return _result

glGetPointeri_vEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr (Ptr ()) -> m ()
glGetPointeri_vEXT pname index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPointeri_vEXT" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetPointeri_vEXT pname index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPointeri_vEXT" (LogV'Void)
#endif
    return _result

glGetPointervEXT :: MonadIO m => GetPointervPName -> Ptr (Ptr ()) -> m ()
glGetPointervEXT pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetPointervEXT" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetPointervEXT (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetPointervEXT" (LogV'Void)
#endif
    return _result

glGetProgramBinary :: MonadIO m => Program -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLenum -> Ptr () -> m ()
glGetProgramBinary program bufSize length binaryFormat binary = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramBinary" [LogV'GLuint program, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramBinary (coerce program) bufSize length binaryFormat binary
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramBinary" (LogV'Void)
#endif
    return _result

glGetProgramEnvParameterIivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetProgramEnvParameterIivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramEnvParameterIivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramEnvParameterIivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramEnvParameterIivNV" (LogV'Void)
#endif
    return _result

glGetProgramEnvParameterIuivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glGetProgramEnvParameterIuivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramEnvParameterIuivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramEnvParameterIuivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramEnvParameterIuivNV" (LogV'Void)
#endif
    return _result

glGetProgramEnvParameterdvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetProgramEnvParameterdvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramEnvParameterdvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramEnvParameterdvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramEnvParameterdvARB" (LogV'Void)
#endif
    return _result

glGetProgramEnvParameterfvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetProgramEnvParameterfvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramEnvParameterfvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramEnvParameterfvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramEnvParameterfvARB" (LogV'Void)
#endif
    return _result

glGetProgramInfoLog :: MonadIO m => Program -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetProgramInfoLog program bufSize length infoLog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramInfoLog" [LogV'GLuint program, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramInfoLog (coerce program) bufSize length infoLog
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramInfoLog" (LogV'Void)
#endif
    return _result

glGetProgramInterfaceiv :: MonadIO m => Program -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramInterfaceiv program programInterface pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramInterfaceiv" [LogV'GLuint program, LogV'GLenum programInterface, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramInterfaceiv (coerce program) programInterface pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramInterfaceiv" (LogV'Void)
#endif
    return _result

glGetProgramLocalParameterIivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetProgramLocalParameterIivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramLocalParameterIivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramLocalParameterIivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramLocalParameterIivNV" (LogV'Void)
#endif
    return _result

glGetProgramLocalParameterIuivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glGetProgramLocalParameterIuivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramLocalParameterIuivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramLocalParameterIuivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramLocalParameterIuivNV" (LogV'Void)
#endif
    return _result

glGetProgramLocalParameterdvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glGetProgramLocalParameterdvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramLocalParameterdvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramLocalParameterdvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramLocalParameterdvARB" (LogV'Void)
#endif
    return _result

glGetProgramLocalParameterfvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glGetProgramLocalParameterfvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramLocalParameterfvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramLocalParameterfvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramLocalParameterfvARB" (LogV'Void)
#endif
    return _result

glGetProgramNamedParameterdvNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> Ptr GL.GLdouble -> m ()
glGetProgramNamedParameterdvNV id len name params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramNamedParameterdvNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramNamedParameterdvNV id len name params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramNamedParameterdvNV" (LogV'Void)
#endif
    return _result

glGetProgramNamedParameterfvNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glGetProgramNamedParameterfvNV id len name params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramNamedParameterfvNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramNamedParameterfvNV id len name params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramNamedParameterfvNV" (LogV'Void)
#endif
    return _result

glGetProgramParameterdvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetProgramParameterdvNV target index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramParameterdvNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramParameterdvNV target index pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramParameterdvNV" (LogV'Void)
#endif
    return _result

glGetProgramParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetProgramParameterfvNV target index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramParameterfvNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramParameterfvNV target index pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramParameterfvNV" (LogV'Void)
#endif
    return _result

glGetProgramPipelineInfoLog :: MonadIO m => ProgramPipeline -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetProgramPipelineInfoLog pipeline bufSize length infoLog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramPipelineInfoLog" [LogV'GLuint pipeline, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramPipelineInfoLog (coerce pipeline) bufSize length infoLog
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramPipelineInfoLog" (LogV'Void)
#endif
    return _result

glGetProgramPipelineiv :: MonadIO m => ProgramPipeline -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramPipelineiv pipeline pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramPipelineiv" [LogV'GLuint pipeline, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramPipelineiv (coerce pipeline) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramPipelineiv" (LogV'Void)
#endif
    return _result

glGetProgramResourceIndex :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLchar -> m GL.GLuint
glGetProgramResourceIndex program programInterface name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramResourceIndex" [LogV'GLuint program, LogV'GLenum programInterface, LogV'Ptr]
#endif
    _result <- GL.glGetProgramResourceIndex (coerce program) programInterface name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramResourceIndex" (LogV'GLuint _result)
#endif
    return _result

glGetProgramResourceLocation :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLchar -> m GL.GLint
glGetProgramResourceLocation program programInterface name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramResourceLocation" [LogV'GLuint program, LogV'GLenum programInterface, LogV'Ptr]
#endif
    _result <- GL.glGetProgramResourceLocation (coerce program) programInterface name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramResourceLocation" (LogV'GLint _result)
#endif
    return _result

glGetProgramResourceLocationIndex :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLchar -> m GL.GLint
glGetProgramResourceLocationIndex program programInterface name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramResourceLocationIndex" [LogV'GLuint program, LogV'GLenum programInterface, LogV'Ptr]
#endif
    _result <- GL.glGetProgramResourceLocationIndex (coerce program) programInterface name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramResourceLocationIndex" (LogV'GLint _result)
#endif
    return _result

glGetProgramResourceName :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetProgramResourceName program programInterface index bufSize length name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramResourceName" [LogV'GLuint program, LogV'GLenum programInterface, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramResourceName (coerce program) programInterface index bufSize length name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramResourceName" (LogV'Void)
#endif
    return _result

glGetProgramResourceiv :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLenum -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> m ()
glGetProgramResourceiv program programInterface index propCount props bufSize length params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramResourceiv" [LogV'GLuint program, LogV'GLenum programInterface, LogV'GLuint index, LogV'GLsizei propCount, LogV'Ptr, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetProgramResourceiv (coerce program) programInterface index propCount props bufSize length params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramResourceiv" (LogV'Void)
#endif
    return _result

glGetProgramStageiv :: MonadIO m => Program -> GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramStageiv program shadertype pname values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramStageiv" [LogV'GLuint program, LogV'GLenum shadertype, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramStageiv (coerce program) shadertype pname values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramStageiv" (LogV'Void)
#endif
    return _result

glGetProgramStringARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glGetProgramStringARB target pname string = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramStringARB" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramStringARB target pname string
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramStringARB" (LogV'Void)
#endif
    return _result

glGetProgramStringNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLubyte -> m ()
glGetProgramStringNV id pname program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramStringNV" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramStringNV id pname program
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramStringNV" (LogV'Void)
#endif
    return _result

glGetProgramSubroutineParameteruivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glGetProgramSubroutineParameteruivNV target index param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramSubroutineParameteruivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetProgramSubroutineParameteruivNV target index param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramSubroutineParameteruivNV" (LogV'Void)
#endif
    return _result

glGetProgramiv :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramiv program pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramiv" [LogV'GLuint program, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramiv (coerce program) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramiv" (LogV'Void)
#endif
    return _result

glGetProgramivARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramivARB target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramivARB" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramivARB target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramivARB" (LogV'Void)
#endif
    return _result

glGetProgramivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetProgramivNV id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetProgramivNV" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetProgramivNV id pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetProgramivNV" (LogV'Void)
#endif
    return _result

glGetQueryBufferObjecti64v :: MonadIO m => Query (a :: QueryTarget) -> Buffer -> GL.GLenum -> GL.GLintptr -> m ()
glGetQueryBufferObjecti64v id buffer pname offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryBufferObjecti64v" [LogV'GLuint id, LogV'GLuint buffer, LogV'GLenum pname, LogV'GLintptr offset]
#endif
    _result <- GL.glGetQueryBufferObjecti64v (coerce id) (coerce buffer) pname offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryBufferObjecti64v" (LogV'Void)
#endif
    return _result

glGetQueryBufferObjectiv :: MonadIO m => Query (a :: QueryTarget) -> Buffer -> GL.GLenum -> GL.GLintptr -> m ()
glGetQueryBufferObjectiv id buffer pname offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryBufferObjectiv" [LogV'GLuint id, LogV'GLuint buffer, LogV'GLenum pname, LogV'GLintptr offset]
#endif
    _result <- GL.glGetQueryBufferObjectiv (coerce id) (coerce buffer) pname offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryBufferObjectiv" (LogV'Void)
#endif
    return _result

glGetQueryBufferObjectui64v :: MonadIO m => Query (a :: QueryTarget) -> Buffer -> GL.GLenum -> GL.GLintptr -> m ()
glGetQueryBufferObjectui64v id buffer pname offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryBufferObjectui64v" [LogV'GLuint id, LogV'GLuint buffer, LogV'GLenum pname, LogV'GLintptr offset]
#endif
    _result <- GL.glGetQueryBufferObjectui64v (coerce id) (coerce buffer) pname offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryBufferObjectui64v" (LogV'Void)
#endif
    return _result

glGetQueryBufferObjectuiv :: MonadIO m => Query (a :: QueryTarget) -> Buffer -> GL.GLenum -> GL.GLintptr -> m ()
glGetQueryBufferObjectuiv id buffer pname offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryBufferObjectuiv" [LogV'GLuint id, LogV'GLuint buffer, LogV'GLenum pname, LogV'GLintptr offset]
#endif
    _result <- GL.glGetQueryBufferObjectuiv (coerce id) (coerce buffer) pname offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryBufferObjectuiv" (LogV'Void)
#endif
    return _result

glGetQueryIndexediv :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetQueryIndexediv target index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryIndexediv" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryIndexediv target index pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryIndexediv" (LogV'Void)
#endif
    return _result

glGetQueryObjecti64v :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetQueryObjecti64v id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjecti64v" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjecti64v (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjecti64v" (LogV'Void)
#endif
    return _result

glGetQueryObjecti64vEXT :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetQueryObjecti64vEXT id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjecti64vEXT" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjecti64vEXT (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjecti64vEXT" (LogV'Void)
#endif
    return _result

glGetQueryObjectiv :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetQueryObjectiv id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectiv" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectiv (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectiv" (LogV'Void)
#endif
    return _result

glGetQueryObjectivARB :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetQueryObjectivARB id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectivARB" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectivARB (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectivARB" (LogV'Void)
#endif
    return _result

glGetQueryObjectui64v :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLuint64 -> m ()
glGetQueryObjectui64v id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectui64v" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectui64v (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectui64v" (LogV'Void)
#endif
    return _result

glGetQueryObjectui64vEXT :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLuint64 -> m ()
glGetQueryObjectui64vEXT id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectui64vEXT" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectui64vEXT (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectui64vEXT" (LogV'Void)
#endif
    return _result

glGetQueryObjectuiv :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetQueryObjectuiv id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectuiv" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectuiv (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectuiv" (LogV'Void)
#endif
    return _result

glGetQueryObjectuivARB :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetQueryObjectuivARB id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryObjectuivARB" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryObjectuivARB (coerce id) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryObjectuivARB" (LogV'Void)
#endif
    return _result

glGetQueryiv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetQueryiv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryiv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryiv target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryiv" (LogV'Void)
#endif
    return _result

glGetQueryivARB :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetQueryivARB target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetQueryivARB" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetQueryivARB target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetQueryivARB" (LogV'Void)
#endif
    return _result

glGetRenderbufferParameteriv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetRenderbufferParameteriv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetRenderbufferParameteriv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetRenderbufferParameteriv target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetRenderbufferParameteriv" (LogV'Void)
#endif
    return _result

glGetRenderbufferParameterivEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetRenderbufferParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetRenderbufferParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetRenderbufferParameterivEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetRenderbufferParameterivEXT" (LogV'Void)
#endif
    return _result

glGetSamplerParameterIiv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetSamplerParameterIiv sampler pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSamplerParameterIiv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetSamplerParameterIiv (coerce sampler) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSamplerParameterIiv" (LogV'Void)
#endif
    return _result

glGetSamplerParameterIuiv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetSamplerParameterIuiv sampler pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSamplerParameterIuiv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetSamplerParameterIuiv (coerce sampler) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSamplerParameterIuiv" (LogV'Void)
#endif
    return _result

glGetSamplerParameterfv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetSamplerParameterfv sampler pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSamplerParameterfv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetSamplerParameterfv (coerce sampler) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSamplerParameterfv" (LogV'Void)
#endif
    return _result

glGetSamplerParameteriv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetSamplerParameteriv sampler pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSamplerParameteriv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetSamplerParameteriv (coerce sampler) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSamplerParameteriv" (LogV'Void)
#endif
    return _result

glGetSeparableFilterEXT :: MonadIO m => SeparableTargetEXT -> PixelFormat -> PixelType -> Ptr () -> Ptr () -> Ptr () -> m ()
glGetSeparableFilterEXT target format type' row column span = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSeparableFilterEXT" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetSeparableFilterEXT (coerce target) (coerce format) (coerce type') row column span
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSeparableFilterEXT" (LogV'Void)
#endif
    return _result

glGetShaderInfoLog :: MonadIO m => Shader (a :: ShaderType) -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetShaderInfoLog shader bufSize length infoLog = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetShaderInfoLog" [LogV'GLuint shader, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetShaderInfoLog (coerce shader) bufSize length infoLog
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetShaderInfoLog" (LogV'Void)
#endif
    return _result

glGetShaderPrecisionFormat :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> Ptr GL.GLint -> m ()
glGetShaderPrecisionFormat shadertype precisiontype range precision = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetShaderPrecisionFormat" [LogV'GLenum shadertype, LogV'GLenum precisiontype, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetShaderPrecisionFormat shadertype precisiontype range precision
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetShaderPrecisionFormat" (LogV'Void)
#endif
    return _result

glGetShaderSource :: MonadIO m => Shader (a :: ShaderType) -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLchar -> m ()
glGetShaderSource shader bufSize length source = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetShaderSource" [LogV'GLuint shader, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetShaderSource (coerce shader) bufSize length source
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetShaderSource" (LogV'Void)
#endif
    return _result

glGetShaderSourceARB :: MonadIO m => GL.GLhandleARB -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLcharARB -> m ()
glGetShaderSourceARB obj maxLength length source = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetShaderSourceARB" [LogV'GLhandleARB obj, LogV'GLsizei maxLength, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetShaderSourceARB obj maxLength length source
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetShaderSourceARB" (LogV'Void)
#endif
    return _result

glGetShaderiv :: MonadIO m => Shader (a :: ShaderType) -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetShaderiv shader pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetShaderiv" [LogV'GLuint shader, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetShaderiv (coerce shader) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetShaderiv" (LogV'Void)
#endif
    return _result

glGetSharpenTexFuncSGIS :: MonadIO m => TextureTarget -> Ptr GL.GLfloat -> m ()
glGetSharpenTexFuncSGIS target points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSharpenTexFuncSGIS" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glGetSharpenTexFuncSGIS (coerce target) points
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSharpenTexFuncSGIS" (LogV'Void)
#endif
    return _result

glGetStageIndexNV :: MonadIO m => GL.GLenum -> m GL.GLushort
glGetStageIndexNV shadertype = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetStageIndexNV" [LogV'GLenum shadertype]
#endif
    _result <- GL.glGetStageIndexNV shadertype
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetStageIndexNV" (LogV'GLushort _result)
#endif
    return _result

glGetString :: MonadIO m => StringName -> m (Ptr GL.GLubyte)
glGetString name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetString" [LogV'GLenum name]
#endif
    _result <- GL.glGetString (coerce name)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetString" (LogV'Ptr)
#endif
    return _result

glGetStringi :: MonadIO m => GL.GLenum -> GL.GLuint -> m (Ptr GL.GLubyte)
glGetStringi name index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetStringi" [LogV'GLenum name, LogV'GLuint index]
#endif
    _result <- GL.glGetStringi name index
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetStringi" (LogV'Ptr)
#endif
    return _result

glGetSubroutineIndex :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLchar -> m GL.GLuint
glGetSubroutineIndex program shadertype name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSubroutineIndex" [LogV'GLuint program, LogV'GLenum shadertype, LogV'Ptr]
#endif
    _result <- GL.glGetSubroutineIndex (coerce program) shadertype name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSubroutineIndex" (LogV'GLuint _result)
#endif
    return _result

glGetSubroutineUniformLocation :: MonadIO m => Program -> GL.GLenum -> Ptr GL.GLchar -> m (Maybe UniformLocation)
glGetSubroutineUniformLocation program shadertype name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSubroutineUniformLocation" [LogV'GLuint program, LogV'GLenum shadertype, LogV'Ptr]
#endif
    _result <- fmap (UniformLocation . fromIntegral) . validate (>= 0) <$> GL.glGetSubroutineUniformLocation (coerce program) shadertype name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSubroutineUniformLocation" (LogV'GLint _result)
#endif
    return _result

glGetSynciv :: MonadIO m => GL.GLsync -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> m ()
glGetSynciv sync pname bufSize length values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetSynciv" [LogV'GLsync sync, LogV'GLenum pname, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetSynciv sync pname bufSize length values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetSynciv" (LogV'Void)
#endif
    return _result

glGetTexBumpParameterfvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetTexBumpParameterfvATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexBumpParameterfvATI" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexBumpParameterfvATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexBumpParameterfvATI" (LogV'Void)
#endif
    return _result

glGetTexBumpParameterivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glGetTexBumpParameterivATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexBumpParameterivATI" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexBumpParameterivATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexBumpParameterivATI" (LogV'Void)
#endif
    return _result

glGetTexFilterFuncSGIS :: MonadIO m => TextureTarget -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetTexFilterFuncSGIS target filter weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexFilterFuncSGIS" [LogV'GLenum target, LogV'GLenum filter, LogV'Ptr]
#endif
    _result <- GL.glGetTexFilterFuncSGIS (coerce target) filter weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexFilterFuncSGIS" (LogV'Void)
#endif
    return _result

glGetTexImage :: MonadIO m => TextureTarget -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetTexImage target level format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexImage" [LogV'GLenum target, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetTexImage (coerce target) level (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexImage" (LogV'Void)
#endif
    return _result

glGetTexLevelParameterfv :: MonadIO m => TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetTexLevelParameterfv target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexLevelParameterfv" [LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexLevelParameterfv (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexLevelParameterfv" (LogV'Void)
#endif
    return _result

glGetTexLevelParameteriv :: MonadIO m => TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTexLevelParameteriv target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexLevelParameteriv" [LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexLevelParameteriv (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexLevelParameteriv" (LogV'Void)
#endif
    return _result

glGetTexParameterIiv :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTexParameterIiv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterIiv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterIiv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterIiv" (LogV'Void)
#endif
    return _result

glGetTexParameterIivEXT :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTexParameterIivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterIivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterIivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterIivEXT" (LogV'Void)
#endif
    return _result

glGetTexParameterIuiv :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLuint -> m ()
glGetTexParameterIuiv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterIuiv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterIuiv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterIuiv" (LogV'Void)
#endif
    return _result

glGetTexParameterIuivEXT :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLuint -> m ()
glGetTexParameterIuivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterIuivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterIuivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterIuivEXT" (LogV'Void)
#endif
    return _result

glGetTexParameterPointervAPPLE :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetTexParameterPointervAPPLE target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterPointervAPPLE" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterPointervAPPLE target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterPointervAPPLE" (LogV'Void)
#endif
    return _result

glGetTexParameterfv :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetTexParameterfv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameterfv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameterfv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameterfv" (LogV'Void)
#endif
    return _result

glGetTexParameteriv :: MonadIO m => TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTexParameteriv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTexParameteriv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTexParameteriv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTexParameteriv" (LogV'Void)
#endif
    return _result

glGetTextureImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetTextureImage texture level format type' bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetTextureImage (coerce texture) level format type' bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureImage" (LogV'Void)
#endif
    return _result

glGetTextureImageEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glGetTextureImageEXT texture target level format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureImageEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glGetTextureImageEXT (coerce texture) (coerce target) level (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureImageEXT" (LogV'Void)
#endif
    return _result

glGetTextureLevelParameterfv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetTextureLevelParameterfv texture level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureLevelParameterfv" [LogV'GLuint texture, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureLevelParameterfv (coerce texture) level pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureLevelParameterfv" (LogV'Void)
#endif
    return _result

glGetTextureLevelParameterfvEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetTextureLevelParameterfvEXT texture target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureLevelParameterfvEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureLevelParameterfvEXT (coerce texture) (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureLevelParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetTextureLevelParameteriv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetTextureLevelParameteriv texture level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureLevelParameteriv" [LogV'GLuint texture, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureLevelParameteriv (coerce texture) level pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureLevelParameteriv" (LogV'Void)
#endif
    return _result

glGetTextureLevelParameterivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTextureLevelParameterivEXT texture target level pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureLevelParameterivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureLevelParameterivEXT (coerce texture) (coerce target) level (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureLevelParameterivEXT" (LogV'Void)
#endif
    return _result

glGetTextureParameterIiv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetTextureParameterIiv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterIiv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterIiv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterIiv" (LogV'Void)
#endif
    return _result

glGetTextureParameterIivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTextureParameterIivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterIivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterIivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterIivEXT" (LogV'Void)
#endif
    return _result

glGetTextureParameterIuiv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetTextureParameterIuiv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterIuiv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterIuiv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterIuiv" (LogV'Void)
#endif
    return _result

glGetTextureParameterIuivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GetTextureParameter -> Ptr GL.GLuint -> m ()
glGetTextureParameterIuivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterIuivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterIuivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterIuivEXT" (LogV'Void)
#endif
    return _result

glGetTextureParameterfv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetTextureParameterfv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterfv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterfv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterfv" (LogV'Void)
#endif
    return _result

glGetTextureParameterfvEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GetTextureParameter -> Ptr GL.GLfloat -> m ()
glGetTextureParameterfvEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterfvEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterfvEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterfvEXT" (LogV'Void)
#endif
    return _result

glGetTextureParameteriv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetTextureParameteriv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameteriv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameteriv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameteriv" (LogV'Void)
#endif
    return _result

glGetTextureParameterivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GetTextureParameter -> Ptr GL.GLint -> m ()
glGetTextureParameterivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureParameterivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTextureParameterivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureParameterivEXT" (LogV'Void)
#endif
    return _result

glGetTextureSubImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetTextureSubImage texture level xoffset yoffset zoffset width height depth format type' bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTextureSubImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetTextureSubImage (coerce texture) level xoffset yoffset zoffset width height depth format type' bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTextureSubImage" (LogV'Void)
#endif
    return _result

glGetTrackMatrixivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetTrackMatrixivNV target address pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTrackMatrixivNV" [LogV'GLenum target, LogV'GLuint address, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTrackMatrixivNV target address pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTrackMatrixivNV" (LogV'Void)
#endif
    return _result

glGetTransformFeedbackVarying :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLenum -> Ptr GL.GLchar -> m ()
glGetTransformFeedbackVarying program index bufSize length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbackVarying" [LogV'GLuint program, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbackVarying (coerce program) index bufSize length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbackVarying" (LogV'Void)
#endif
    return _result

glGetTransformFeedbackVaryingEXT :: MonadIO m => Program -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLenum -> Ptr GL.GLchar -> m ()
glGetTransformFeedbackVaryingEXT program index bufSize length size type' name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbackVaryingEXT" [LogV'GLuint program, LogV'GLuint index, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbackVaryingEXT (coerce program) index bufSize length size type' name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbackVaryingEXT" (LogV'Void)
#endif
    return _result

glGetTransformFeedbackVaryingNV :: MonadIO m => Program -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetTransformFeedbackVaryingNV program index location = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbackVaryingNV" [LogV'GLuint program, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbackVaryingNV (coerce program) index location
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbackVaryingNV" (LogV'Void)
#endif
    return _result

glGetTransformFeedbacki64_v :: MonadIO m => TransformFeedback -> GL.GLenum -> GL.GLuint -> Ptr GL.GLint64 -> m ()
glGetTransformFeedbacki64_v xfb pname index param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbacki64_v" [LogV'GLuint xfb, LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbacki64_v (coerce xfb) pname index param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbacki64_v" (LogV'Void)
#endif
    return _result

glGetTransformFeedbacki_v :: MonadIO m => TransformFeedback -> GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glGetTransformFeedbacki_v xfb pname index param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbacki_v" [LogV'GLuint xfb, LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbacki_v (coerce xfb) pname index param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbacki_v" (LogV'Void)
#endif
    return _result

glGetTransformFeedbackiv :: MonadIO m => TransformFeedback -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetTransformFeedbackiv xfb pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetTransformFeedbackiv" [LogV'GLuint xfb, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetTransformFeedbackiv (coerce xfb) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetTransformFeedbackiv" (LogV'Void)
#endif
    return _result

glGetUniformBlockIndex :: MonadIO m => Program -> Ptr GL.GLchar -> m GL.GLuint
glGetUniformBlockIndex program uniformBlockName = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformBlockIndex" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glGetUniformBlockIndex (coerce program) uniformBlockName
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformBlockIndex" (LogV'GLuint _result)
#endif
    return _result

glGetUniformBufferSizeEXT :: MonadIO m => Program -> UniformLocation -> m GL.GLint
glGetUniformBufferSizeEXT program location = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformBufferSizeEXT" [LogV'GLuint program, LogV'GLint location]
#endif
    _result <- GL.glGetUniformBufferSizeEXT (coerce program) (coerce location)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformBufferSizeEXT" (LogV'GLint _result)
#endif
    return _result

glGetUniformIndices :: MonadIO m => Program -> GL.GLsizei -> Ptr (Ptr GL.GLchar) -> Ptr GL.GLuint -> m ()
glGetUniformIndices program uniformCount uniformNames uniformIndices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformIndices" [LogV'GLuint program, LogV'GLsizei uniformCount, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetUniformIndices (coerce program) uniformCount uniformNames uniformIndices
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformIndices" (LogV'Void)
#endif
    return _result

glGetUniformLocation :: MonadIO m => Program -> Ptr GL.GLchar -> m (Maybe UniformLocation)
glGetUniformLocation program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformLocation" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- fmap (UniformLocation . fromIntegral) . validate (>= 0) <$> GL.glGetUniformLocation (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformLocation" (LogV'GLint _result)
#endif
    return _result

glGetUniformLocationARB :: MonadIO m => GL.GLhandleARB -> Ptr GL.GLcharARB -> m (Maybe UniformLocation)
glGetUniformLocationARB programObj name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformLocationARB" [LogV'GLhandleARB programObj, LogV'Ptr]
#endif
    _result <- fmap (UniformLocation . fromIntegral) . validate (>= 0) <$> GL.glGetUniformLocationARB programObj name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformLocationARB" (LogV'GLint _result)
#endif
    return _result

glGetUniformOffsetEXT :: MonadIO m => Program -> UniformLocation -> m GL.GLintptr
glGetUniformOffsetEXT program location = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformOffsetEXT" [LogV'GLuint program, LogV'GLint location]
#endif
    _result <- GL.glGetUniformOffsetEXT (coerce program) (coerce location)
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformOffsetEXT" (LogV'GLintptr _result)
#endif
    return _result

glGetUniformSubroutineuiv :: MonadIO m => GL.GLenum -> UniformLocation -> Ptr GL.GLuint -> m ()
glGetUniformSubroutineuiv shadertype location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformSubroutineuiv" [LogV'GLenum shadertype, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformSubroutineuiv shadertype (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformSubroutineuiv" (LogV'Void)
#endif
    return _result

glGetUniformdv :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLdouble -> m ()
glGetUniformdv program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformdv" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformdv (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformdv" (LogV'Void)
#endif
    return _result

glGetUniformfv :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLfloat -> m ()
glGetUniformfv program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformfv" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformfv (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformfv" (LogV'Void)
#endif
    return _result

glGetUniformfvARB :: MonadIO m => GL.GLhandleARB -> UniformLocation -> Ptr GL.GLfloat -> m ()
glGetUniformfvARB programObj location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformfvARB" [LogV'GLhandleARB programObj, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformfvARB programObj (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformfvARB" (LogV'Void)
#endif
    return _result

glGetUniformi64vARB :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLint64 -> m ()
glGetUniformi64vARB program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformi64vARB" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformi64vARB (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformi64vARB" (LogV'Void)
#endif
    return _result

glGetUniformi64vNV :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLint64EXT -> m ()
glGetUniformi64vNV program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformi64vNV" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformi64vNV (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformi64vNV" (LogV'Void)
#endif
    return _result

glGetUniformiv :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLint -> m ()
glGetUniformiv program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformiv" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformiv (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformiv" (LogV'Void)
#endif
    return _result

glGetUniformivARB :: MonadIO m => GL.GLhandleARB -> UniformLocation -> Ptr GL.GLint -> m ()
glGetUniformivARB programObj location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformivARB" [LogV'GLhandleARB programObj, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformivARB programObj (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformivARB" (LogV'Void)
#endif
    return _result

glGetUniformui64vARB :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLuint64 -> m ()
glGetUniformui64vARB program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformui64vARB (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformui64vARB" (LogV'Void)
#endif
    return _result

glGetUniformui64vNV :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLuint64EXT -> m ()
glGetUniformui64vNV program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformui64vNV (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformui64vNV" (LogV'Void)
#endif
    return _result

glGetUniformuiv :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLuint -> m ()
glGetUniformuiv program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformuiv" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformuiv (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformuiv" (LogV'Void)
#endif
    return _result

glGetUniformuivEXT :: MonadIO m => Program -> UniformLocation -> Ptr GL.GLuint -> m ()
glGetUniformuivEXT program location params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetUniformuivEXT" [LogV'GLuint program, LogV'GLint location, LogV'Ptr]
#endif
    _result <- GL.glGetUniformuivEXT (coerce program) (coerce location) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetUniformuivEXT" (LogV'Void)
#endif
    return _result

glGetVariantArrayObjectfvATI :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVariantArrayObjectfvATI id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantArrayObjectfvATI" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVariantArrayObjectfvATI id pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantArrayObjectfvATI" (LogV'Void)
#endif
    return _result

glGetVariantArrayObjectivATI :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVariantArrayObjectivATI id pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantArrayObjectivATI" [LogV'GLuint id, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVariantArrayObjectivATI id pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantArrayObjectivATI" (LogV'Void)
#endif
    return _result

glGetVariantBooleanvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr Boolean -> m ()
glGetVariantBooleanvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantBooleanvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetVariantBooleanvEXT id value (coerce data')
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantBooleanvEXT" (LogV'Void)
#endif
    return _result

glGetVariantFloatvEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVariantFloatvEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantFloatvEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetVariantFloatvEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantFloatvEXT" (LogV'Void)
#endif
    return _result

glGetVariantIntegervEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVariantIntegervEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantIntegervEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetVariantIntegervEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantIntegervEXT" (LogV'Void)
#endif
    return _result

glGetVariantPointervEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVariantPointervEXT id value data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVariantPointervEXT" [LogV'GLuint id, LogV'GLenum value, LogV'Ptr]
#endif
    _result <- GL.glGetVariantPointervEXT id value data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVariantPointervEXT" (LogV'Void)
#endif
    return _result

glGetVaryingLocationNV :: MonadIO m => Program -> Ptr GL.GLchar -> m GL.GLint
glGetVaryingLocationNV program name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVaryingLocationNV" [LogV'GLuint program, LogV'Ptr]
#endif
    _result <- GL.glGetVaryingLocationNV (coerce program) name
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVaryingLocationNV" (LogV'GLint _result)
#endif
    return _result

glGetVertexArrayIndexed64iv :: MonadIO m => VertexArray -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint64 -> m ()
glGetVertexArrayIndexed64iv vaobj index pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayIndexed64iv" [LogV'GLuint vaobj, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayIndexed64iv (coerce vaobj) index pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayIndexed64iv" (LogV'Void)
#endif
    return _result

glGetVertexArrayIndexediv :: MonadIO m => VertexArray -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexArrayIndexediv vaobj index pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayIndexediv" [LogV'GLuint vaobj, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayIndexediv (coerce vaobj) index pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayIndexediv" (LogV'Void)
#endif
    return _result

glGetVertexArrayIntegeri_vEXT :: MonadIO m => VertexArray -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexArrayIntegeri_vEXT vaobj index pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayIntegeri_vEXT" [LogV'GLuint vaobj, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayIntegeri_vEXT (coerce vaobj) index pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayIntegeri_vEXT" (LogV'Void)
#endif
    return _result

glGetVertexArrayIntegervEXT :: MonadIO m => VertexArray -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexArrayIntegervEXT vaobj pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayIntegervEXT" [LogV'GLuint vaobj, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayIntegervEXT (coerce vaobj) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayIntegervEXT" (LogV'Void)
#endif
    return _result

glGetVertexArrayPointeri_vEXT :: MonadIO m => VertexArray -> GL.GLuint -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVertexArrayPointeri_vEXT vaobj index pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayPointeri_vEXT" [LogV'GLuint vaobj, LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayPointeri_vEXT (coerce vaobj) index pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayPointeri_vEXT" (LogV'Void)
#endif
    return _result

glGetVertexArrayPointervEXT :: MonadIO m => VertexArray -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVertexArrayPointervEXT vaobj pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayPointervEXT" [LogV'GLuint vaobj, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayPointervEXT (coerce vaobj) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayPointervEXT" (LogV'Void)
#endif
    return _result

glGetVertexArrayiv :: MonadIO m => VertexArray -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexArrayiv vaobj pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexArrayiv" [LogV'GLuint vaobj, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexArrayiv (coerce vaobj) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexArrayiv" (LogV'Void)
#endif
    return _result

glGetVertexAttribArrayObjectfvATI :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVertexAttribArrayObjectfvATI index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribArrayObjectfvATI" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribArrayObjectfvATI (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribArrayObjectfvATI" (LogV'Void)
#endif
    return _result

glGetVertexAttribArrayObjectivATI :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribArrayObjectivATI index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribArrayObjectivATI" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribArrayObjectivATI (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribArrayObjectivATI" (LogV'Void)
#endif
    return _result

glGetVertexAttribIiv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribIiv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribIiv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribIiv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribIiv" (LogV'Void)
#endif
    return _result

glGetVertexAttribIivEXT :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribIivEXT index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribIivEXT" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribIivEXT (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribIivEXT" (LogV'Void)
#endif
    return _result

glGetVertexAttribIuiv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetVertexAttribIuiv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribIuiv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribIuiv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribIuiv" (LogV'Void)
#endif
    return _result

glGetVertexAttribIuivEXT :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetVertexAttribIuivEXT index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribIuivEXT" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribIuivEXT (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribIuivEXT" (LogV'Void)
#endif
    return _result

glGetVertexAttribLdv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVertexAttribLdv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribLdv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribLdv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribLdv" (LogV'Void)
#endif
    return _result

glGetVertexAttribLdvEXT :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVertexAttribLdvEXT index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribLdvEXT" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribLdvEXT (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribLdvEXT" (LogV'Void)
#endif
    return _result

glGetVertexAttribLi64vNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint64EXT -> m ()
glGetVertexAttribLi64vNV index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribLi64vNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribLi64vNV (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribLi64vNV" (LogV'Void)
#endif
    return _result

glGetVertexAttribLui64vNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLuint64EXT -> m ()
glGetVertexAttribLui64vNV index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribLui64vNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribLui64vNV (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribLui64vNV" (LogV'Void)
#endif
    return _result

glGetVertexAttribPointerv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVertexAttribPointerv index pname pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribPointerv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribPointerv (coerce index) pname pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribPointerv" (LogV'Void)
#endif
    return _result

glGetVertexAttribPointervARB :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVertexAttribPointervARB index pname pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribPointervARB" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribPointervARB (coerce index) pname pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribPointervARB" (LogV'Void)
#endif
    return _result

glGetVertexAttribPointervNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr (Ptr ()) -> m ()
glGetVertexAttribPointervNV index pname pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribPointervNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribPointervNV (coerce index) pname pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribPointervNV" (LogV'Void)
#endif
    return _result

glGetVertexAttribdv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVertexAttribdv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribdv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribdv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribdv" (LogV'Void)
#endif
    return _result

glGetVertexAttribdvARB :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVertexAttribdvARB index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribdvARB" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribdvARB (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribdvARB" (LogV'Void)
#endif
    return _result

glGetVertexAttribdvNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVertexAttribdvNV index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribdvNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribdvNV (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribdvNV" (LogV'Void)
#endif
    return _result

glGetVertexAttribfv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVertexAttribfv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribfv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribfv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribfv" (LogV'Void)
#endif
    return _result

glGetVertexAttribfvARB :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVertexAttribfvARB index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribfvARB" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribfvARB (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribfvARB" (LogV'Void)
#endif
    return _result

glGetVertexAttribfvNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVertexAttribfvNV index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribfvNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribfvNV (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribfvNV" (LogV'Void)
#endif
    return _result

glGetVertexAttribiv :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribiv index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribiv" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribiv (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribiv" (LogV'Void)
#endif
    return _result

glGetVertexAttribivARB :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribivARB index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribivARB" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribivARB (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribivARB" (LogV'Void)
#endif
    return _result

glGetVertexAttribivNV :: MonadIO m => AttribLocation -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVertexAttribivNV index pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVertexAttribivNV" [LogV'GLuint index, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVertexAttribivNV (coerce index) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVertexAttribivNV" (LogV'Void)
#endif
    return _result

glGetVideoCaptureStreamdvNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glGetVideoCaptureStreamdvNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoCaptureStreamdvNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoCaptureStreamdvNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoCaptureStreamdvNV" (LogV'Void)
#endif
    return _result

glGetVideoCaptureStreamfvNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glGetVideoCaptureStreamfvNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoCaptureStreamfvNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoCaptureStreamfvNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoCaptureStreamfvNV" (LogV'Void)
#endif
    return _result

glGetVideoCaptureStreamivNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVideoCaptureStreamivNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoCaptureStreamivNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoCaptureStreamivNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoCaptureStreamivNV" (LogV'Void)
#endif
    return _result

glGetVideoCaptureivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVideoCaptureivNV video_capture_slot pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoCaptureivNV" [LogV'GLuint video_capture_slot, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoCaptureivNV video_capture_slot pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoCaptureivNV" (LogV'Void)
#endif
    return _result

glGetVideoi64vNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint64EXT -> m ()
glGetVideoi64vNV video_slot pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoi64vNV" [LogV'GLuint video_slot, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoi64vNV video_slot pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoi64vNV" (LogV'Void)
#endif
    return _result

glGetVideoivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glGetVideoivNV video_slot pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoivNV" [LogV'GLuint video_slot, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoivNV video_slot pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoivNV" (LogV'Void)
#endif
    return _result

glGetVideoui64vNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLuint64EXT -> m ()
glGetVideoui64vNV video_slot pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideoui64vNV" [LogV'GLuint video_slot, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideoui64vNV video_slot pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideoui64vNV" (LogV'Void)
#endif
    return _result

glGetVideouivNV :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr GL.GLuint -> m ()
glGetVideouivNV video_slot pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetVideouivNV" [LogV'GLuint video_slot, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glGetVideouivNV video_slot pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetVideouivNV" (LogV'Void)
#endif
    return _result

glGetnColorTable :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetnColorTable target format type' bufSize table = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnColorTable" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnColorTable target format type' bufSize table
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnColorTable" (LogV'Void)
#endif
    return _result

glGetnCompressedTexImage :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLsizei -> Ptr () -> m ()
glGetnCompressedTexImage target lod bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnCompressedTexImage" [LogV'GLenum target, LogV'GLint lod, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnCompressedTexImage target lod bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnCompressedTexImage" (LogV'Void)
#endif
    return _result

glGetnConvolutionFilter :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetnConvolutionFilter target format type' bufSize image = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnConvolutionFilter" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnConvolutionFilter target format type' bufSize image
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnConvolutionFilter" (LogV'Void)
#endif
    return _result

glGetnHistogram :: MonadIO m => GL.GLenum -> GL.GLboolean -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetnHistogram target reset format type' bufSize values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnHistogram" [LogV'GLenum target, LogV'GLboolean reset, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnHistogram target reset format type' bufSize values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnHistogram" (LogV'Void)
#endif
    return _result

glGetnMapdv :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glGetnMapdv target query bufSize v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnMapdv" [LogV'GLenum target, LogV'GLenum query, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnMapdv target query bufSize v
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnMapdv" (LogV'Void)
#endif
    return _result

glGetnMapfv :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glGetnMapfv target query bufSize v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnMapfv" [LogV'GLenum target, LogV'GLenum query, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnMapfv target query bufSize v
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnMapfv" (LogV'Void)
#endif
    return _result

glGetnMapiv :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLint -> m ()
glGetnMapiv target query bufSize v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnMapiv" [LogV'GLenum target, LogV'GLenum query, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnMapiv target query bufSize v
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnMapiv" (LogV'Void)
#endif
    return _result

glGetnMinmax :: MonadIO m => GL.GLenum -> GL.GLboolean -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetnMinmax target reset format type' bufSize values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnMinmax" [LogV'GLenum target, LogV'GLboolean reset, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnMinmax target reset format type' bufSize values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnMinmax" (LogV'Void)
#endif
    return _result

glGetnPixelMapfv :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glGetnPixelMapfv map bufSize values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnPixelMapfv" [LogV'GLenum map, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnPixelMapfv map bufSize values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnPixelMapfv" (LogV'Void)
#endif
    return _result

glGetnPixelMapuiv :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glGetnPixelMapuiv map bufSize values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnPixelMapuiv" [LogV'GLenum map, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnPixelMapuiv map bufSize values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnPixelMapuiv" (LogV'Void)
#endif
    return _result

glGetnPixelMapusv :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLushort -> m ()
glGetnPixelMapusv map bufSize values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnPixelMapusv" [LogV'GLenum map, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnPixelMapusv map bufSize values
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnPixelMapusv" (LogV'Void)
#endif
    return _result

glGetnPolygonStipple :: MonadIO m => GL.GLsizei -> Ptr GL.GLubyte -> m ()
glGetnPolygonStipple bufSize pattern = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnPolygonStipple" [LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnPolygonStipple bufSize pattern
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnPolygonStipple" (LogV'Void)
#endif
    return _result

glGetnSeparableFilter :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> GL.GLsizei -> Ptr () -> Ptr () -> m ()
glGetnSeparableFilter target format type' rowBufSize row columnBufSize column span = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnSeparableFilter" [LogV'GLenum target, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei rowBufSize, LogV'Ptr, LogV'GLsizei columnBufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glGetnSeparableFilter target format type' rowBufSize row columnBufSize column span
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnSeparableFilter" (LogV'Void)
#endif
    return _result

glGetnTexImage :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glGetnTexImage target level format type' bufSize pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnTexImage" [LogV'GLenum target, LogV'GLint level, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnTexImage target level format type' bufSize pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnTexImage" (LogV'Void)
#endif
    return _result

glGetnUniformdv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glGetnUniformdv program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformdv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformdv (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformdv" (LogV'Void)
#endif
    return _result

glGetnUniformfv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glGetnUniformfv program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformfv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformfv (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformfv" (LogV'Void)
#endif
    return _result

glGetnUniformi64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glGetnUniformi64vARB program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformi64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformi64vARB (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformi64vARB" (LogV'Void)
#endif
    return _result

glGetnUniformiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glGetnUniformiv program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformiv (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformiv" (LogV'Void)
#endif
    return _result

glGetnUniformui64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glGetnUniformui64vARB program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformui64vARB (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformui64vARB" (LogV'Void)
#endif
    return _result

glGetnUniformuiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glGetnUniformuiv program location bufSize params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGetnUniformuiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glGetnUniformuiv (coerce program) (coerce location) bufSize params
#ifdef GLW_DEBUG
    logGLCommandEnd "glGetnUniformuiv" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactorbSUN :: MonadIO m => GL.GLbyte -> m ()
glGlobalAlphaFactorbSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactorbSUN" [LogV'GLbyte factor]
#endif
    _result <- GL.glGlobalAlphaFactorbSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactorbSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactordSUN :: MonadIO m => GL.GLdouble -> m ()
glGlobalAlphaFactordSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactordSUN" [LogV'GLdouble factor]
#endif
    _result <- GL.glGlobalAlphaFactordSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactordSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactorfSUN :: MonadIO m => GL.GLfloat -> m ()
glGlobalAlphaFactorfSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactorfSUN" [LogV'GLfloat factor]
#endif
    _result <- GL.glGlobalAlphaFactorfSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactorfSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactoriSUN :: MonadIO m => GL.GLint -> m ()
glGlobalAlphaFactoriSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactoriSUN" [LogV'GLint factor]
#endif
    _result <- GL.glGlobalAlphaFactoriSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactoriSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactorsSUN :: MonadIO m => GL.GLshort -> m ()
glGlobalAlphaFactorsSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactorsSUN" [LogV'GLshort factor]
#endif
    _result <- GL.glGlobalAlphaFactorsSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactorsSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactorubSUN :: MonadIO m => GL.GLubyte -> m ()
glGlobalAlphaFactorubSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactorubSUN" [LogV'GLubyte factor]
#endif
    _result <- GL.glGlobalAlphaFactorubSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactorubSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactoruiSUN :: MonadIO m => GL.GLuint -> m ()
glGlobalAlphaFactoruiSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactoruiSUN" [LogV'GLuint factor]
#endif
    _result <- GL.glGlobalAlphaFactoruiSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactoruiSUN" (LogV'Void)
#endif
    return _result

glGlobalAlphaFactorusSUN :: MonadIO m => GL.GLushort -> m ()
glGlobalAlphaFactorusSUN factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glGlobalAlphaFactorusSUN" [LogV'GLushort factor]
#endif
    _result <- GL.glGlobalAlphaFactorusSUN factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glGlobalAlphaFactorusSUN" (LogV'Void)
#endif
    return _result

glHint :: MonadIO m => HintTarget -> HintMode -> m ()
glHint target mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glHint" [LogV'GLenum target, LogV'GLenum mode]
#endif
    _result <- GL.glHint (coerce target) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glHint" (LogV'Void)
#endif
    return _result

glHintPGI :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glHintPGI target mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glHintPGI" [LogV'GLenum target, LogV'GLint mode]
#endif
    _result <- GL.glHintPGI target mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glHintPGI" (LogV'Void)
#endif
    return _result

glHistogramEXT :: MonadIO m => HistogramTargetEXT -> GL.GLsizei -> GL.GLenum -> Boolean -> m ()
glHistogramEXT target width internalformat sink = do
#ifdef GLW_DEBUG
    logGLCommandStart "glHistogramEXT" [LogV'GLenum target, LogV'GLsizei width, LogV'GLenum internalformat, LogV'GLboolean sink]
#endif
    _result <- GL.glHistogramEXT (coerce target) width internalformat (coerce sink)
#ifdef GLW_DEBUG
    logGLCommandEnd "glHistogramEXT" (LogV'Void)
#endif
    return _result

glIglooInterfaceSGIX :: MonadIO m => GL.GLenum -> Ptr () -> m ()
glIglooInterfaceSGIX pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIglooInterfaceSGIX" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glIglooInterfaceSGIX pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glIglooInterfaceSGIX" (LogV'Void)
#endif
    return _result

glImageTransformParameterfHP :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLfloat -> m ()
glImageTransformParameterfHP target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glImageTransformParameterfHP" [LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glImageTransformParameterfHP target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glImageTransformParameterfHP" (LogV'Void)
#endif
    return _result

glImageTransformParameterfvHP :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glImageTransformParameterfvHP target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glImageTransformParameterfvHP" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glImageTransformParameterfvHP target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glImageTransformParameterfvHP" (LogV'Void)
#endif
    return _result

glImageTransformParameteriHP :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLint -> m ()
glImageTransformParameteriHP target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glImageTransformParameteriHP" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glImageTransformParameteriHP target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glImageTransformParameteriHP" (LogV'Void)
#endif
    return _result

glImageTransformParameterivHP :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glImageTransformParameterivHP target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glImageTransformParameterivHP" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glImageTransformParameterivHP target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glImageTransformParameterivHP" (LogV'Void)
#endif
    return _result

glImportSyncEXT :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLbitfield -> m GL.GLsync
glImportSyncEXT external_sync_type external_sync flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glImportSyncEXT" [LogV'GLenum external_sync_type, LogV'GLintptr external_sync, LogV'GLbitfield flags]
#endif
    _result <- GL.glImportSyncEXT external_sync_type external_sync flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glImportSyncEXT" (LogV'GLsync _result)
#endif
    return _result

glIndexFormatNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> m ()
glIndexFormatNV type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIndexFormatNV" [LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glIndexFormatNV type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glIndexFormatNV" (LogV'Void)
#endif
    return _result

glIndexFuncEXT :: MonadIO m => GL.GLenum -> GL.GLclampf -> m ()
glIndexFuncEXT func ref = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIndexFuncEXT" [LogV'GLenum func, LogV'GLclampf ref]
#endif
    _result <- GL.glIndexFuncEXT func ref
#ifdef GLW_DEBUG
    logGLCommandEnd "glIndexFuncEXT" (LogV'Void)
#endif
    return _result

glIndexMaterialEXT :: MonadIO m => MaterialFace -> GL.GLenum -> m ()
glIndexMaterialEXT face mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIndexMaterialEXT" [LogV'GLenum face, LogV'GLenum mode]
#endif
    _result <- GL.glIndexMaterialEXT (coerce face) mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glIndexMaterialEXT" (LogV'Void)
#endif
    return _result

glIndexPointerEXT :: MonadIO m => IndexPointerType -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glIndexPointerEXT type' stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIndexPointerEXT" [LogV'GLenum type', LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glIndexPointerEXT (coerce type') stride count pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glIndexPointerEXT" (LogV'Void)
#endif
    return _result

glIndexPointerListIBM :: MonadIO m => IndexPointerType -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glIndexPointerListIBM type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIndexPointerListIBM" [LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glIndexPointerListIBM (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glIndexPointerListIBM" (LogV'Void)
#endif
    return _result

glInsertComponentEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glInsertComponentEXT res src num = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInsertComponentEXT" [LogV'GLuint res, LogV'GLuint src, LogV'GLuint num]
#endif
    _result <- GL.glInsertComponentEXT res src num
#ifdef GLW_DEBUG
    logGLCommandEnd "glInsertComponentEXT" (LogV'Void)
#endif
    return _result

glInstrumentsBufferSGIX :: MonadIO m => GL.GLsizei -> Ptr GL.GLint -> m ()
glInstrumentsBufferSGIX size buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInstrumentsBufferSGIX" [LogV'GLsizei size, LogV'Ptr]
#endif
    _result <- GL.glInstrumentsBufferSGIX size buffer
#ifdef GLW_DEBUG
    logGLCommandEnd "glInstrumentsBufferSGIX" (LogV'Void)
#endif
    return _result

glInvalidateBufferData :: MonadIO m => Buffer -> m ()
glInvalidateBufferData buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateBufferData" [LogV'GLuint buffer]
#endif
    _result <- GL.glInvalidateBufferData (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateBufferData" (LogV'Void)
#endif
    return _result

glInvalidateBufferSubData :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glInvalidateBufferSubData buffer offset length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateBufferSubData" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr length]
#endif
    _result <- GL.glInvalidateBufferSubData (coerce buffer) offset length
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateBufferSubData" (LogV'Void)
#endif
    return _result

glInvalidateFramebuffer :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLenum -> m ()
glInvalidateFramebuffer target numAttachments attachments = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateFramebuffer" [LogV'GLenum target, LogV'GLsizei numAttachments, LogV'Ptr]
#endif
    _result <- GL.glInvalidateFramebuffer target numAttachments attachments
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateFramebuffer" (LogV'Void)
#endif
    return _result

glInvalidateNamedFramebufferData :: MonadIO m => Framebuffer -> GL.GLsizei -> Ptr GL.GLenum -> m ()
glInvalidateNamedFramebufferData framebuffer numAttachments attachments = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateNamedFramebufferData" [LogV'GLuint framebuffer, LogV'GLsizei numAttachments, LogV'Ptr]
#endif
    _result <- GL.glInvalidateNamedFramebufferData (coerce framebuffer) numAttachments attachments
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateNamedFramebufferData" (LogV'Void)
#endif
    return _result

glInvalidateNamedFramebufferSubData :: MonadIO m => Framebuffer -> GL.GLsizei -> Ptr GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glInvalidateNamedFramebufferSubData framebuffer numAttachments attachments x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateNamedFramebufferSubData" [LogV'GLuint framebuffer, LogV'GLsizei numAttachments, LogV'Ptr, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glInvalidateNamedFramebufferSubData (coerce framebuffer) numAttachments attachments x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateNamedFramebufferSubData" (LogV'Void)
#endif
    return _result

glInvalidateSubFramebuffer :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glInvalidateSubFramebuffer target numAttachments attachments x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateSubFramebuffer" [LogV'GLenum target, LogV'GLsizei numAttachments, LogV'Ptr, LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glInvalidateSubFramebuffer target numAttachments attachments x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateSubFramebuffer" (LogV'Void)
#endif
    return _result

glInvalidateTexImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> m ()
glInvalidateTexImage texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateTexImage" [LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glInvalidateTexImage (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateTexImage" (LogV'Void)
#endif
    return _result

glInvalidateTexSubImage :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glInvalidateTexSubImage texture level xoffset yoffset zoffset width height depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glInvalidateTexSubImage" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth]
#endif
    _result <- GL.glInvalidateTexSubImage (coerce texture) level xoffset yoffset zoffset width height depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glInvalidateTexSubImage" (LogV'Void)
#endif
    return _result

glIsAsyncMarkerSGIX :: MonadIO m => GL.GLuint -> m Boolean
glIsAsyncMarkerSGIX marker = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsAsyncMarkerSGIX" [LogV'GLuint marker]
#endif
    _result <- coerce <$> GL.glIsAsyncMarkerSGIX marker
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsAsyncMarkerSGIX" (LogV'GLboolean _result)
#endif
    return _result

glIsBuffer :: MonadIO m => Buffer -> m Boolean
glIsBuffer buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsBuffer" [LogV'GLuint buffer]
#endif
    _result <- coerce <$> GL.glIsBuffer (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsBuffer" (LogV'GLboolean _result)
#endif
    return _result

glIsBufferARB :: MonadIO m => Buffer -> m Boolean
glIsBufferARB buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsBufferARB" [LogV'GLuint buffer]
#endif
    _result <- coerce <$> GL.glIsBufferARB (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsBufferARB" (LogV'GLboolean _result)
#endif
    return _result

glIsBufferResidentNV :: MonadIO m => GL.GLenum -> m Boolean
glIsBufferResidentNV target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsBufferResidentNV" [LogV'GLenum target]
#endif
    _result <- coerce <$> GL.glIsBufferResidentNV target
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsBufferResidentNV" (LogV'GLboolean _result)
#endif
    return _result

glIsCommandListNV :: MonadIO m => GL.GLuint -> m GL.GLboolean
glIsCommandListNV list = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsCommandListNV" [LogV'GLuint list]
#endif
    _result <- GL.glIsCommandListNV list
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsCommandListNV" (LogV'GLboolean _result)
#endif
    return _result

glIsEnabled :: MonadIO m => EnableCap -> m Boolean
glIsEnabled cap = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsEnabled" [LogV'GLenum cap]
#endif
    _result <- coerce <$> GL.glIsEnabled (coerce cap)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsEnabled" (LogV'GLboolean _result)
#endif
    return _result

glIsEnabledIndexedEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> m Boolean
glIsEnabledIndexedEXT target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsEnabledIndexedEXT" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- coerce <$> GL.glIsEnabledIndexedEXT target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsEnabledIndexedEXT" (LogV'GLboolean _result)
#endif
    return _result

glIsEnabledi :: MonadIO m => GL.GLenum -> GL.GLuint -> m Boolean
glIsEnabledi target index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsEnabledi" [LogV'GLenum target, LogV'GLuint index]
#endif
    _result <- coerce <$> GL.glIsEnabledi target index
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsEnabledi" (LogV'GLboolean _result)
#endif
    return _result

glIsFenceAPPLE :: MonadIO m => GL.GLuint -> m Boolean
glIsFenceAPPLE fence = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsFenceAPPLE" [LogV'GLuint fence]
#endif
    _result <- coerce <$> GL.glIsFenceAPPLE fence
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsFenceAPPLE" (LogV'GLboolean _result)
#endif
    return _result

glIsFramebuffer :: MonadIO m => Framebuffer -> m Boolean
glIsFramebuffer framebuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsFramebuffer" [LogV'GLuint framebuffer]
#endif
    _result <- coerce <$> GL.glIsFramebuffer (coerce framebuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsFramebuffer" (LogV'GLboolean _result)
#endif
    return _result

glIsFramebufferEXT :: MonadIO m => Framebuffer -> m Boolean
glIsFramebufferEXT framebuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsFramebufferEXT" [LogV'GLuint framebuffer]
#endif
    _result <- coerce <$> GL.glIsFramebufferEXT (coerce framebuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsFramebufferEXT" (LogV'GLboolean _result)
#endif
    return _result

glIsNameAMD :: MonadIO m => GL.GLenum -> GL.GLuint -> m Boolean
glIsNameAMD identifier name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsNameAMD" [LogV'GLenum identifier, LogV'GLuint name]
#endif
    _result <- coerce <$> GL.glIsNameAMD identifier name
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsNameAMD" (LogV'GLboolean _result)
#endif
    return _result

glIsNamedBufferResidentNV :: MonadIO m => Buffer -> m Boolean
glIsNamedBufferResidentNV buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsNamedBufferResidentNV" [LogV'GLuint buffer]
#endif
    _result <- coerce <$> GL.glIsNamedBufferResidentNV (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsNamedBufferResidentNV" (LogV'GLboolean _result)
#endif
    return _result

glIsObjectBufferATI :: MonadIO m => Buffer -> m Boolean
glIsObjectBufferATI buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsObjectBufferATI" [LogV'GLuint buffer]
#endif
    _result <- coerce <$> GL.glIsObjectBufferATI (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsObjectBufferATI" (LogV'GLboolean _result)
#endif
    return _result

glIsOcclusionQueryNV :: MonadIO m => GL.GLuint -> m Boolean
glIsOcclusionQueryNV id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsOcclusionQueryNV" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsOcclusionQueryNV id
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsOcclusionQueryNV" (LogV'GLboolean _result)
#endif
    return _result

glIsProgram :: MonadIO m => Program -> m Boolean
glIsProgram program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsProgram" [LogV'GLuint program]
#endif
    _result <- coerce <$> GL.glIsProgram (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsProgram" (LogV'GLboolean _result)
#endif
    return _result

glIsProgramARB :: MonadIO m => Program -> m Boolean
glIsProgramARB program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsProgramARB" [LogV'GLuint program]
#endif
    _result <- coerce <$> GL.glIsProgramARB (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsProgramARB" (LogV'GLboolean _result)
#endif
    return _result

glIsProgramNV :: MonadIO m => GL.GLuint -> m Boolean
glIsProgramNV id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsProgramNV" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsProgramNV id
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsProgramNV" (LogV'GLboolean _result)
#endif
    return _result

glIsProgramPipeline :: MonadIO m => ProgramPipeline -> m Boolean
glIsProgramPipeline pipeline = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsProgramPipeline" [LogV'GLuint pipeline]
#endif
    _result <- coerce <$> GL.glIsProgramPipeline (coerce pipeline)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsProgramPipeline" (LogV'GLboolean _result)
#endif
    return _result

glIsQuery :: MonadIO m => Query (a :: QueryTarget) -> m Boolean
glIsQuery id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsQuery" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsQuery (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsQuery" (LogV'GLboolean _result)
#endif
    return _result

glIsQueryARB :: MonadIO m => Query (a :: QueryTarget) -> m Boolean
glIsQueryARB id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsQueryARB" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsQueryARB (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsQueryARB" (LogV'GLboolean _result)
#endif
    return _result

glIsRenderbuffer :: MonadIO m => Renderbuffer -> m Boolean
glIsRenderbuffer renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsRenderbuffer" [LogV'GLuint renderbuffer]
#endif
    _result <- coerce <$> GL.glIsRenderbuffer (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsRenderbuffer" (LogV'GLboolean _result)
#endif
    return _result

glIsRenderbufferEXT :: MonadIO m => Renderbuffer -> m Boolean
glIsRenderbufferEXT renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsRenderbufferEXT" [LogV'GLuint renderbuffer]
#endif
    _result <- coerce <$> GL.glIsRenderbufferEXT (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsRenderbufferEXT" (LogV'GLboolean _result)
#endif
    return _result

glIsSampler :: MonadIO m => Sampler -> m Boolean
glIsSampler sampler = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsSampler" [LogV'GLuint sampler]
#endif
    _result <- coerce <$> GL.glIsSampler (coerce sampler)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsSampler" (LogV'GLboolean _result)
#endif
    return _result

glIsShader :: MonadIO m => Shader (a :: ShaderType) -> m Boolean
glIsShader shader = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsShader" [LogV'GLuint shader]
#endif
    _result <- coerce <$> GL.glIsShader (coerce shader)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsShader" (LogV'GLboolean _result)
#endif
    return _result

glIsStateNV :: MonadIO m => GL.GLuint -> m GL.GLboolean
glIsStateNV state = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsStateNV" [LogV'GLuint state]
#endif
    _result <- GL.glIsStateNV state
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsStateNV" (LogV'GLboolean _result)
#endif
    return _result

glIsSync :: MonadIO m => GL.GLsync -> m Boolean
glIsSync sync = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsSync" [LogV'GLsync sync]
#endif
    _result <- coerce <$> GL.glIsSync sync
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsSync" (LogV'GLboolean _result)
#endif
    return _result

glIsTexture :: MonadIO m => Texture (a :: TextureTarget') -> m Boolean
glIsTexture texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsTexture" [LogV'GLuint texture]
#endif
    _result <- coerce <$> GL.glIsTexture (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsTexture" (LogV'GLboolean _result)
#endif
    return _result

glIsTextureEXT :: MonadIO m => Texture (a :: TextureTarget') -> m Boolean
glIsTextureEXT texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsTextureEXT" [LogV'GLuint texture]
#endif
    _result <- coerce <$> GL.glIsTextureEXT (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsTextureEXT" (LogV'GLboolean _result)
#endif
    return _result

glIsTransformFeedback :: MonadIO m => TransformFeedback -> m Boolean
glIsTransformFeedback id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsTransformFeedback" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsTransformFeedback (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsTransformFeedback" (LogV'GLboolean _result)
#endif
    return _result

glIsTransformFeedbackNV :: MonadIO m => TransformFeedback -> m Boolean
glIsTransformFeedbackNV id = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsTransformFeedbackNV" [LogV'GLuint id]
#endif
    _result <- coerce <$> GL.glIsTransformFeedbackNV (coerce id)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsTransformFeedbackNV" (LogV'GLboolean _result)
#endif
    return _result

glIsVariantEnabledEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> m Boolean
glIsVariantEnabledEXT id cap = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsVariantEnabledEXT" [LogV'GLuint id, LogV'GLenum cap]
#endif
    _result <- coerce <$> GL.glIsVariantEnabledEXT id cap
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsVariantEnabledEXT" (LogV'GLboolean _result)
#endif
    return _result

glIsVertexArray :: MonadIO m => VertexArray -> m Boolean
glIsVertexArray array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsVertexArray" [LogV'GLuint array]
#endif
    _result <- coerce <$> GL.glIsVertexArray (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsVertexArray" (LogV'GLboolean _result)
#endif
    return _result

glIsVertexArrayAPPLE :: MonadIO m => VertexArray -> m Boolean
glIsVertexArrayAPPLE array = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsVertexArrayAPPLE" [LogV'GLuint array]
#endif
    _result <- coerce <$> GL.glIsVertexArrayAPPLE (coerce array)
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsVertexArrayAPPLE" (LogV'GLboolean _result)
#endif
    return _result

glIsVertexAttribEnabledAPPLE :: MonadIO m => AttribLocation -> GL.GLenum -> m Boolean
glIsVertexAttribEnabledAPPLE index pname = do
#ifdef GLW_DEBUG
    logGLCommandStart "glIsVertexAttribEnabledAPPLE" [LogV'GLuint index, LogV'GLenum pname]
#endif
    _result <- coerce <$> GL.glIsVertexAttribEnabledAPPLE (coerce index) pname
#ifdef GLW_DEBUG
    logGLCommandEnd "glIsVertexAttribEnabledAPPLE" (LogV'GLboolean _result)
#endif
    return _result

glLightEnviSGIX :: MonadIO m => LightEnvParameterSGIX -> GL.GLint -> m ()
glLightEnviSGIX pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLightEnviSGIX" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glLightEnviSGIX (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glLightEnviSGIX" (LogV'Void)
#endif
    return _result

glLineWidth :: MonadIO m => GL.GLfloat -> m ()
glLineWidth width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLineWidth" [LogV'GLfloat width]
#endif
    _result <- GL.glLineWidth width
#ifdef GLW_DEBUG
    logGLCommandEnd "glLineWidth" (LogV'Void)
#endif
    return _result

glLinkProgram :: MonadIO m => Program -> m ()
glLinkProgram program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLinkProgram" [LogV'GLuint program]
#endif
    _result <- GL.glLinkProgram (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glLinkProgram" (LogV'Void)
#endif
    return _result

glLinkProgramARB :: MonadIO m => GL.GLhandleARB -> m ()
glLinkProgramARB programObj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLinkProgramARB" [LogV'GLhandleARB programObj]
#endif
    _result <- GL.glLinkProgramARB programObj
#ifdef GLW_DEBUG
    logGLCommandEnd "glLinkProgramARB" (LogV'Void)
#endif
    return _result

glListDrawCommandsStatesClientNV :: MonadIO m => GL.GLuint -> GL.GLuint -> Ptr (Ptr ()) -> Ptr GL.GLsizei -> Ptr GL.GLuint -> Ptr GL.GLuint -> GL.GLuint -> m ()
glListDrawCommandsStatesClientNV list segment indirects sizes states fbos count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glListDrawCommandsStatesClientNV" [LogV'GLuint list, LogV'GLuint segment, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'GLuint count]
#endif
    _result <- GL.glListDrawCommandsStatesClientNV list segment indirects sizes states fbos count
#ifdef GLW_DEBUG
    logGLCommandEnd "glListDrawCommandsStatesClientNV" (LogV'Void)
#endif
    return _result

glListParameterfSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> GL.GLfloat -> m ()
glListParameterfSGIX list pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glListParameterfSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glListParameterfSGIX list (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glListParameterfSGIX" (LogV'Void)
#endif
    return _result

glListParameterfvSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> Ptr GL.GLfloat -> m ()
glListParameterfvSGIX list pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glListParameterfvSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glListParameterfvSGIX list (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glListParameterfvSGIX" (LogV'Void)
#endif
    return _result

glListParameteriSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> GL.GLint -> m ()
glListParameteriSGIX list pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glListParameteriSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glListParameteriSGIX list (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glListParameteriSGIX" (LogV'Void)
#endif
    return _result

glListParameterivSGIX :: MonadIO m => GL.GLuint -> ListParameterName -> Ptr GL.GLint -> m ()
glListParameterivSGIX list pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glListParameterivSGIX" [LogV'GLuint list, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glListParameterivSGIX list (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glListParameterivSGIX" (LogV'Void)
#endif
    return _result

glLoadIdentityDeformationMapSGIX :: MonadIO m => GL.GLbitfield -> m ()
glLoadIdentityDeformationMapSGIX mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLoadIdentityDeformationMapSGIX" [LogV'GLbitfield mask]
#endif
    _result <- GL.glLoadIdentityDeformationMapSGIX mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glLoadIdentityDeformationMapSGIX" (LogV'Void)
#endif
    return _result

glLoadProgramNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> m ()
glLoadProgramNV target id len program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLoadProgramNV" [LogV'GLenum target, LogV'GLuint id, LogV'GLsizei len, LogV'Ptr]
#endif
    _result <- GL.glLoadProgramNV target id len program
#ifdef GLW_DEBUG
    logGLCommandEnd "glLoadProgramNV" (LogV'Void)
#endif
    return _result

glLoadTransposeMatrixdARB :: MonadIO m => Ptr GL.GLdouble -> m ()
glLoadTransposeMatrixdARB m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLoadTransposeMatrixdARB" [LogV'Ptr]
#endif
    _result <- GL.glLoadTransposeMatrixdARB m
#ifdef GLW_DEBUG
    logGLCommandEnd "glLoadTransposeMatrixdARB" (LogV'Void)
#endif
    return _result

glLoadTransposeMatrixfARB :: MonadIO m => Ptr GL.GLfloat -> m ()
glLoadTransposeMatrixfARB m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLoadTransposeMatrixfARB" [LogV'Ptr]
#endif
    _result <- GL.glLoadTransposeMatrixfARB m
#ifdef GLW_DEBUG
    logGLCommandEnd "glLoadTransposeMatrixfARB" (LogV'Void)
#endif
    return _result

glLockArraysEXT :: MonadIO m => GL.GLint -> GL.GLsizei -> m ()
glLockArraysEXT first count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLockArraysEXT" [LogV'GLint first, LogV'GLsizei count]
#endif
    _result <- GL.glLockArraysEXT first count
#ifdef GLW_DEBUG
    logGLCommandEnd "glLockArraysEXT" (LogV'Void)
#endif
    return _result

glLogicOp :: MonadIO m => LogicOp -> m ()
glLogicOp opcode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glLogicOp" [LogV'GLenum opcode]
#endif
    _result <- GL.glLogicOp (coerce opcode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glLogicOp" (LogV'Void)
#endif
    return _result

glMakeBufferNonResidentNV :: MonadIO m => GL.GLenum -> m ()
glMakeBufferNonResidentNV target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMakeBufferNonResidentNV" [LogV'GLenum target]
#endif
    _result <- GL.glMakeBufferNonResidentNV target
#ifdef GLW_DEBUG
    logGLCommandEnd "glMakeBufferNonResidentNV" (LogV'Void)
#endif
    return _result

glMakeBufferResidentNV :: MonadIO m => GL.GLenum -> GL.GLenum -> m ()
glMakeBufferResidentNV target access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMakeBufferResidentNV" [LogV'GLenum target, LogV'GLenum access]
#endif
    _result <- GL.glMakeBufferResidentNV target access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMakeBufferResidentNV" (LogV'Void)
#endif
    return _result

glMakeNamedBufferNonResidentNV :: MonadIO m => Buffer -> m ()
glMakeNamedBufferNonResidentNV buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMakeNamedBufferNonResidentNV" [LogV'GLuint buffer]
#endif
    _result <- GL.glMakeNamedBufferNonResidentNV (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMakeNamedBufferNonResidentNV" (LogV'Void)
#endif
    return _result

glMakeNamedBufferResidentNV :: MonadIO m => Buffer -> GL.GLenum -> m ()
glMakeNamedBufferResidentNV buffer access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMakeNamedBufferResidentNV" [LogV'GLuint buffer, LogV'GLenum access]
#endif
    _result <- GL.glMakeNamedBufferResidentNV (coerce buffer) access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMakeNamedBufferResidentNV" (LogV'Void)
#endif
    return _result

glMapBuffer :: MonadIO m => GL.GLenum -> GL.GLenum -> m (Ptr ())
glMapBuffer target access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapBuffer" [LogV'GLenum target, LogV'GLenum access]
#endif
    _result <- GL.glMapBuffer target access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapBuffer" (LogV'Ptr)
#endif
    return _result

glMapBufferARB :: MonadIO m => GL.GLenum -> GL.GLenum -> m (Ptr ())
glMapBufferARB target access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapBufferARB" [LogV'GLenum target, LogV'GLenum access]
#endif
    _result <- GL.glMapBufferARB target access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapBufferARB" (LogV'Ptr)
#endif
    return _result

glMapBufferRange :: MonadIO m => GL.GLenum -> GL.GLintptr -> GL.GLsizeiptr -> GL.GLbitfield -> m (Ptr ())
glMapBufferRange target offset length access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapBufferRange" [LogV'GLenum target, LogV'GLintptr offset, LogV'GLsizeiptr length, LogV'GLbitfield access]
#endif
    _result <- GL.glMapBufferRange target offset length access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapBufferRange" (LogV'Ptr)
#endif
    return _result

glMapControlPointsNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLint -> Boolean -> Ptr () -> m ()
glMapControlPointsNV target index type' ustride vstride uorder vorder packed points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapControlPointsNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLenum type', LogV'GLsizei ustride, LogV'GLsizei vstride, LogV'GLint uorder, LogV'GLint vorder, LogV'GLboolean packed, LogV'Ptr]
#endif
    _result <- GL.glMapControlPointsNV target index type' ustride vstride uorder vorder (coerce packed) points
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapControlPointsNV" (LogV'Void)
#endif
    return _result

glMapNamedBuffer :: MonadIO m => Buffer -> GL.GLenum -> m (Ptr ())
glMapNamedBuffer buffer access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapNamedBuffer" [LogV'GLuint buffer, LogV'GLenum access]
#endif
    _result <- GL.glMapNamedBuffer (coerce buffer) access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapNamedBuffer" (LogV'Ptr)
#endif
    return _result

glMapNamedBufferEXT :: MonadIO m => Buffer -> GL.GLenum -> m (Ptr ())
glMapNamedBufferEXT buffer access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapNamedBufferEXT" [LogV'GLuint buffer, LogV'GLenum access]
#endif
    _result <- GL.glMapNamedBufferEXT (coerce buffer) access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapNamedBufferEXT" (LogV'Ptr)
#endif
    return _result

glMapNamedBufferRange :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> GL.GLbitfield -> m (Ptr ())
glMapNamedBufferRange buffer offset length access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapNamedBufferRange" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr length, LogV'GLbitfield access]
#endif
    _result <- GL.glMapNamedBufferRange (coerce buffer) offset length access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapNamedBufferRange" (LogV'Ptr)
#endif
    return _result

glMapNamedBufferRangeEXT :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> GL.GLbitfield -> m (Ptr ())
glMapNamedBufferRangeEXT buffer offset length access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapNamedBufferRangeEXT" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr length, LogV'GLbitfield access]
#endif
    _result <- GL.glMapNamedBufferRangeEXT (coerce buffer) offset length access
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapNamedBufferRangeEXT" (LogV'Ptr)
#endif
    return _result

glMapObjectBufferATI :: MonadIO m => Buffer -> m (Ptr ())
glMapObjectBufferATI buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapObjectBufferATI" [LogV'GLuint buffer]
#endif
    _result <- GL.glMapObjectBufferATI (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapObjectBufferATI" (LogV'Ptr)
#endif
    return _result

glMapParameterfvNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glMapParameterfvNV target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapParameterfvNV" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMapParameterfvNV target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapParameterfvNV" (LogV'Void)
#endif
    return _result

glMapParameterivNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glMapParameterivNV target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapParameterivNV" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMapParameterivNV target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapParameterivNV" (LogV'Void)
#endif
    return _result

glMapTexture2DINTEL :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLbitfield -> Ptr GL.GLint -> Ptr GL.GLenum -> m (Ptr ())
glMapTexture2DINTEL texture level access stride layout = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapTexture2DINTEL" [LogV'GLuint texture, LogV'GLint level, LogV'GLbitfield access, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glMapTexture2DINTEL (coerce texture) level access stride layout
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapTexture2DINTEL" (LogV'Ptr)
#endif
    return _result

glMapVertexAttrib1dAPPLE :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> Ptr GL.GLdouble -> m ()
glMapVertexAttrib1dAPPLE index size u1 u2 stride order points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapVertexAttrib1dAPPLE" [LogV'GLuint index, LogV'GLuint size, LogV'GLdouble u1, LogV'GLdouble u2, LogV'GLint stride, LogV'GLint order, LogV'Ptr]
#endif
    _result <- GL.glMapVertexAttrib1dAPPLE (coerce index) size u1 u2 stride order points
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapVertexAttrib1dAPPLE" (LogV'Void)
#endif
    return _result

glMapVertexAttrib1fAPPLE :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> Ptr GL.GLfloat -> m ()
glMapVertexAttrib1fAPPLE index size u1 u2 stride order points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapVertexAttrib1fAPPLE" [LogV'GLuint index, LogV'GLuint size, LogV'GLfloat u1, LogV'GLfloat u2, LogV'GLint stride, LogV'GLint order, LogV'Ptr]
#endif
    _result <- GL.glMapVertexAttrib1fAPPLE (coerce index) size u1 u2 stride order points
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapVertexAttrib1fAPPLE" (LogV'Void)
#endif
    return _result

glMapVertexAttrib2dAPPLE :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> GL.GLdouble -> GL.GLdouble -> GL.GLint -> GL.GLint -> Ptr GL.GLdouble -> m ()
glMapVertexAttrib2dAPPLE index size u1 u2 ustride uorder v1 v2 vstride vorder points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapVertexAttrib2dAPPLE" [LogV'GLuint index, LogV'GLuint size, LogV'GLdouble u1, LogV'GLdouble u2, LogV'GLint ustride, LogV'GLint uorder, LogV'GLdouble v1, LogV'GLdouble v2, LogV'GLint vstride, LogV'GLint vorder, LogV'Ptr]
#endif
    _result <- GL.glMapVertexAttrib2dAPPLE (coerce index) size u1 u2 ustride uorder v1 v2 vstride vorder points
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapVertexAttrib2dAPPLE" (LogV'Void)
#endif
    return _result

glMapVertexAttrib2fAPPLE :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> GL.GLfloat -> GL.GLfloat -> GL.GLint -> GL.GLint -> Ptr GL.GLfloat -> m ()
glMapVertexAttrib2fAPPLE index size u1 u2 ustride uorder v1 v2 vstride vorder points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMapVertexAttrib2fAPPLE" [LogV'GLuint index, LogV'GLuint size, LogV'GLfloat u1, LogV'GLfloat u2, LogV'GLint ustride, LogV'GLint uorder, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLint vstride, LogV'GLint vorder, LogV'Ptr]
#endif
    _result <- GL.glMapVertexAttrib2fAPPLE (coerce index) size u1 u2 ustride uorder v1 v2 vstride vorder points
#ifdef GLW_DEBUG
    logGLCommandEnd "glMapVertexAttrib2fAPPLE" (LogV'Void)
#endif
    return _result

glMatrixFrustumEXT :: MonadIO m => MatrixMode -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMatrixFrustumEXT mode left right bottom top zNear zFar = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixFrustumEXT" [LogV'GLenum mode, LogV'GLdouble left, LogV'GLdouble right, LogV'GLdouble bottom, LogV'GLdouble top, LogV'GLdouble zNear, LogV'GLdouble zFar]
#endif
    _result <- GL.glMatrixFrustumEXT (coerce mode) left right bottom top zNear zFar
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixFrustumEXT" (LogV'Void)
#endif
    return _result

glMatrixIndexPointerARB :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glMatrixIndexPointerARB size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixIndexPointerARB" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glMatrixIndexPointerARB size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixIndexPointerARB" (LogV'Void)
#endif
    return _result

glMatrixIndexubvARB :: MonadIO m => GL.GLint -> Ptr GL.GLubyte -> m ()
glMatrixIndexubvARB size indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixIndexubvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glMatrixIndexubvARB size indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixIndexubvARB" (LogV'Void)
#endif
    return _result

glMatrixIndexuivARB :: MonadIO m => GL.GLint -> Ptr GL.GLuint -> m ()
glMatrixIndexuivARB size indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixIndexuivARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glMatrixIndexuivARB size indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixIndexuivARB" (LogV'Void)
#endif
    return _result

glMatrixIndexusvARB :: MonadIO m => GL.GLint -> Ptr GL.GLushort -> m ()
glMatrixIndexusvARB size indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixIndexusvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glMatrixIndexusvARB size indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixIndexusvARB" (LogV'Void)
#endif
    return _result

glMatrixLoadIdentityEXT :: MonadIO m => MatrixMode -> m ()
glMatrixLoadIdentityEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixLoadIdentityEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glMatrixLoadIdentityEXT (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixLoadIdentityEXT" (LogV'Void)
#endif
    return _result

glMatrixLoadTransposedEXT :: MonadIO m => MatrixMode -> Ptr GL.GLdouble -> m ()
glMatrixLoadTransposedEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixLoadTransposedEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixLoadTransposedEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixLoadTransposedEXT" (LogV'Void)
#endif
    return _result

glMatrixLoadTransposefEXT :: MonadIO m => MatrixMode -> Ptr GL.GLfloat -> m ()
glMatrixLoadTransposefEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixLoadTransposefEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixLoadTransposefEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixLoadTransposefEXT" (LogV'Void)
#endif
    return _result

glMatrixLoaddEXT :: MonadIO m => MatrixMode -> Ptr GL.GLdouble -> m ()
glMatrixLoaddEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixLoaddEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixLoaddEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixLoaddEXT" (LogV'Void)
#endif
    return _result

glMatrixLoadfEXT :: MonadIO m => MatrixMode -> Ptr GL.GLfloat -> m ()
glMatrixLoadfEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixLoadfEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixLoadfEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixLoadfEXT" (LogV'Void)
#endif
    return _result

glMatrixMultTransposedEXT :: MonadIO m => MatrixMode -> Ptr GL.GLdouble -> m ()
glMatrixMultTransposedEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixMultTransposedEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixMultTransposedEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixMultTransposedEXT" (LogV'Void)
#endif
    return _result

glMatrixMultTransposefEXT :: MonadIO m => MatrixMode -> Ptr GL.GLfloat -> m ()
glMatrixMultTransposefEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixMultTransposefEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixMultTransposefEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixMultTransposefEXT" (LogV'Void)
#endif
    return _result

glMatrixMultdEXT :: MonadIO m => MatrixMode -> Ptr GL.GLdouble -> m ()
glMatrixMultdEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixMultdEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixMultdEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixMultdEXT" (LogV'Void)
#endif
    return _result

glMatrixMultfEXT :: MonadIO m => MatrixMode -> Ptr GL.GLfloat -> m ()
glMatrixMultfEXT mode m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixMultfEXT" [LogV'GLenum mode, LogV'Ptr]
#endif
    _result <- GL.glMatrixMultfEXT (coerce mode) m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixMultfEXT" (LogV'Void)
#endif
    return _result

glMatrixOrthoEXT :: MonadIO m => MatrixMode -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMatrixOrthoEXT mode left right bottom top zNear zFar = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixOrthoEXT" [LogV'GLenum mode, LogV'GLdouble left, LogV'GLdouble right, LogV'GLdouble bottom, LogV'GLdouble top, LogV'GLdouble zNear, LogV'GLdouble zFar]
#endif
    _result <- GL.glMatrixOrthoEXT (coerce mode) left right bottom top zNear zFar
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixOrthoEXT" (LogV'Void)
#endif
    return _result

glMatrixPopEXT :: MonadIO m => MatrixMode -> m ()
glMatrixPopEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixPopEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glMatrixPopEXT (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixPopEXT" (LogV'Void)
#endif
    return _result

glMatrixPushEXT :: MonadIO m => MatrixMode -> m ()
glMatrixPushEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixPushEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glMatrixPushEXT (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixPushEXT" (LogV'Void)
#endif
    return _result

glMatrixRotatedEXT :: MonadIO m => MatrixMode -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMatrixRotatedEXT mode angle x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixRotatedEXT" [LogV'GLenum mode, LogV'GLdouble angle, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glMatrixRotatedEXT (coerce mode) angle x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixRotatedEXT" (LogV'Void)
#endif
    return _result

glMatrixRotatefEXT :: MonadIO m => MatrixMode -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glMatrixRotatefEXT mode angle x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixRotatefEXT" [LogV'GLenum mode, LogV'GLfloat angle, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glMatrixRotatefEXT (coerce mode) angle x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixRotatefEXT" (LogV'Void)
#endif
    return _result

glMatrixScaledEXT :: MonadIO m => MatrixMode -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMatrixScaledEXT mode x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixScaledEXT" [LogV'GLenum mode, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glMatrixScaledEXT (coerce mode) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixScaledEXT" (LogV'Void)
#endif
    return _result

glMatrixScalefEXT :: MonadIO m => MatrixMode -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glMatrixScalefEXT mode x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixScalefEXT" [LogV'GLenum mode, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glMatrixScalefEXT (coerce mode) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixScalefEXT" (LogV'Void)
#endif
    return _result

glMatrixTranslatedEXT :: MonadIO m => MatrixMode -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMatrixTranslatedEXT mode x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixTranslatedEXT" [LogV'GLenum mode, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glMatrixTranslatedEXT (coerce mode) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixTranslatedEXT" (LogV'Void)
#endif
    return _result

glMatrixTranslatefEXT :: MonadIO m => MatrixMode -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glMatrixTranslatefEXT mode x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMatrixTranslatefEXT" [LogV'GLenum mode, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glMatrixTranslatefEXT (coerce mode) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glMatrixTranslatefEXT" (LogV'Void)
#endif
    return _result

glMaxShaderCompilerThreadsARB :: MonadIO m => GL.GLuint -> m ()
glMaxShaderCompilerThreadsARB count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMaxShaderCompilerThreadsARB" [LogV'GLuint count]
#endif
    _result <- GL.glMaxShaderCompilerThreadsARB count
#ifdef GLW_DEBUG
    logGLCommandEnd "glMaxShaderCompilerThreadsARB" (LogV'Void)
#endif
    return _result

glMemoryBarrier :: MonadIO m => GL.GLbitfield -> m ()
glMemoryBarrier barriers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMemoryBarrier" [LogV'GLbitfield barriers]
#endif
    _result <- GL.glMemoryBarrier barriers
#ifdef GLW_DEBUG
    logGLCommandEnd "glMemoryBarrier" (LogV'Void)
#endif
    return _result

glMemoryBarrierByRegion :: MonadIO m => GL.GLbitfield -> m ()
glMemoryBarrierByRegion barriers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMemoryBarrierByRegion" [LogV'GLbitfield barriers]
#endif
    _result <- GL.glMemoryBarrierByRegion barriers
#ifdef GLW_DEBUG
    logGLCommandEnd "glMemoryBarrierByRegion" (LogV'Void)
#endif
    return _result

glMemoryBarrierEXT :: MonadIO m => GL.GLbitfield -> m ()
glMemoryBarrierEXT barriers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMemoryBarrierEXT" [LogV'GLbitfield barriers]
#endif
    _result <- GL.glMemoryBarrierEXT barriers
#ifdef GLW_DEBUG
    logGLCommandEnd "glMemoryBarrierEXT" (LogV'Void)
#endif
    return _result

glMinSampleShading :: MonadIO m => GL.GLfloat -> m ()
glMinSampleShading value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMinSampleShading" [LogV'GLfloat value]
#endif
    _result <- GL.glMinSampleShading value
#ifdef GLW_DEBUG
    logGLCommandEnd "glMinSampleShading" (LogV'Void)
#endif
    return _result

glMinmaxEXT :: MonadIO m => MinmaxTargetEXT -> GL.GLenum -> Boolean -> m ()
glMinmaxEXT target internalformat sink = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMinmaxEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLboolean sink]
#endif
    _result <- GL.glMinmaxEXT (coerce target) internalformat (coerce sink)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMinmaxEXT" (LogV'Void)
#endif
    return _result

glMultTransposeMatrixdARB :: MonadIO m => Ptr GL.GLdouble -> m ()
glMultTransposeMatrixdARB m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultTransposeMatrixdARB" [LogV'Ptr]
#endif
    _result <- GL.glMultTransposeMatrixdARB m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultTransposeMatrixdARB" (LogV'Void)
#endif
    return _result

glMultTransposeMatrixfARB :: MonadIO m => Ptr GL.GLfloat -> m ()
glMultTransposeMatrixfARB m = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultTransposeMatrixfARB" [LogV'Ptr]
#endif
    _result <- GL.glMultTransposeMatrixfARB m
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultTransposeMatrixfARB" (LogV'Void)
#endif
    return _result

glMultiDrawArrays :: MonadIO m => PrimitiveType -> Ptr GL.GLint -> Ptr GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawArrays mode first count drawcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawArrays" [LogV'GLenum mode, LogV'Ptr, LogV'Ptr, LogV'GLsizei drawcount]
#endif
    _result <- GL.glMultiDrawArrays (coerce mode) first count drawcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawArrays" (LogV'Void)
#endif
    return _result

glMultiDrawArraysIndirect :: MonadIO m => GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawArraysIndirect mode indirect drawcount stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawArraysIndirect" [LogV'GLenum mode, LogV'Ptr, LogV'GLsizei drawcount, LogV'GLsizei stride]
#endif
    _result <- GL.glMultiDrawArraysIndirect mode indirect drawcount stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawArraysIndirect" (LogV'Void)
#endif
    return _result

glMultiDrawArraysIndirectAMD :: MonadIO m => GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawArraysIndirectAMD mode indirect primcount stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawArraysIndirectAMD" [LogV'GLenum mode, LogV'Ptr, LogV'GLsizei primcount, LogV'GLsizei stride]
#endif
    _result <- GL.glMultiDrawArraysIndirectAMD mode indirect primcount stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawArraysIndirectAMD" (LogV'Void)
#endif
    return _result

glMultiDrawArraysIndirectBindlessCountNV :: MonadIO m => GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glMultiDrawArraysIndirectBindlessCountNV mode indirect drawCount maxDrawCount stride vertexBufferCount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawArraysIndirectBindlessCountNV" [LogV'GLenum mode, LogV'Ptr, LogV'GLsizei drawCount, LogV'GLsizei maxDrawCount, LogV'GLsizei stride, LogV'GLint vertexBufferCount]
#endif
    _result <- GL.glMultiDrawArraysIndirectBindlessCountNV mode indirect drawCount maxDrawCount stride vertexBufferCount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawArraysIndirectBindlessCountNV" (LogV'Void)
#endif
    return _result

glMultiDrawArraysIndirectBindlessNV :: MonadIO m => GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glMultiDrawArraysIndirectBindlessNV mode indirect drawCount stride vertexBufferCount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawArraysIndirectBindlessNV" [LogV'GLenum mode, LogV'Ptr, LogV'GLsizei drawCount, LogV'GLsizei stride, LogV'GLint vertexBufferCount]
#endif
    _result <- GL.glMultiDrawArraysIndirectBindlessNV mode indirect drawCount stride vertexBufferCount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawArraysIndirectBindlessNV" (LogV'Void)
#endif
    return _result

glMultiDrawElementArrayAPPLE :: MonadIO m => PrimitiveType -> Ptr GL.GLint -> Ptr GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawElementArrayAPPLE mode first count primcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementArrayAPPLE" [LogV'GLenum mode, LogV'Ptr, LogV'Ptr, LogV'GLsizei primcount]
#endif
    _result <- GL.glMultiDrawElementArrayAPPLE (coerce mode) first count primcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementArrayAPPLE" (LogV'Void)
#endif
    return _result

glMultiDrawElements :: MonadIO m => PrimitiveType -> Ptr GL.GLsizei -> GL.GLenum -> Ptr (Ptr ()) -> GL.GLsizei -> m ()
glMultiDrawElements mode count type' indices drawcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElements" [LogV'GLenum mode, LogV'Ptr, LogV'GLenum type', LogV'Ptr, LogV'GLsizei drawcount]
#endif
    _result <- GL.glMultiDrawElements (coerce mode) count type' indices drawcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElements" (LogV'Void)
#endif
    return _result

glMultiDrawElementsBaseVertex :: MonadIO m => GL.GLenum -> Ptr GL.GLsizei -> GL.GLenum -> Ptr (Ptr ()) -> GL.GLsizei -> Ptr GL.GLint -> m ()
glMultiDrawElementsBaseVertex mode count type' indices drawcount basevertex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementsBaseVertex" [LogV'GLenum mode, LogV'Ptr, LogV'GLenum type', LogV'Ptr, LogV'GLsizei drawcount, LogV'Ptr]
#endif
    _result <- GL.glMultiDrawElementsBaseVertex mode count type' indices drawcount basevertex
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementsBaseVertex" (LogV'Void)
#endif
    return _result

glMultiDrawElementsIndirect :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawElementsIndirect mode type' indirect drawcount stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementsIndirect" [LogV'GLenum mode, LogV'GLenum type', LogV'Ptr, LogV'GLsizei drawcount, LogV'GLsizei stride]
#endif
    _result <- GL.glMultiDrawElementsIndirect mode type' indirect drawcount stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementsIndirect" (LogV'Void)
#endif
    return _result

glMultiDrawElementsIndirectAMD :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawElementsIndirectAMD mode type' indirect primcount stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementsIndirectAMD" [LogV'GLenum mode, LogV'GLenum type', LogV'Ptr, LogV'GLsizei primcount, LogV'GLsizei stride]
#endif
    _result <- GL.glMultiDrawElementsIndirectAMD mode type' indirect primcount stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementsIndirectAMD" (LogV'Void)
#endif
    return _result

glMultiDrawElementsIndirectBindlessCountNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glMultiDrawElementsIndirectBindlessCountNV mode type' indirect drawCount maxDrawCount stride vertexBufferCount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementsIndirectBindlessCountNV" [LogV'GLenum mode, LogV'GLenum type', LogV'Ptr, LogV'GLsizei drawCount, LogV'GLsizei maxDrawCount, LogV'GLsizei stride, LogV'GLint vertexBufferCount]
#endif
    _result <- GL.glMultiDrawElementsIndirectBindlessCountNV mode type' indirect drawCount maxDrawCount stride vertexBufferCount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementsIndirectBindlessCountNV" (LogV'Void)
#endif
    return _result

glMultiDrawElementsIndirectBindlessNV :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr () -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glMultiDrawElementsIndirectBindlessNV mode type' indirect drawCount stride vertexBufferCount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawElementsIndirectBindlessNV" [LogV'GLenum mode, LogV'GLenum type', LogV'Ptr, LogV'GLsizei drawCount, LogV'GLsizei stride, LogV'GLint vertexBufferCount]
#endif
    _result <- GL.glMultiDrawElementsIndirectBindlessNV mode type' indirect drawCount stride vertexBufferCount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawElementsIndirectBindlessNV" (LogV'Void)
#endif
    return _result

glMultiDrawRangeElementArrayAPPLE :: MonadIO m => PrimitiveType -> GL.GLuint -> GL.GLuint -> Ptr GL.GLint -> Ptr GL.GLsizei -> GL.GLsizei -> m ()
glMultiDrawRangeElementArrayAPPLE mode start end first count primcount = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiDrawRangeElementArrayAPPLE" [LogV'GLenum mode, LogV'GLuint start, LogV'GLuint end, LogV'Ptr, LogV'Ptr, LogV'GLsizei primcount]
#endif
    _result <- GL.glMultiDrawRangeElementArrayAPPLE (coerce mode) start end first count primcount
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiDrawRangeElementArrayAPPLE" (LogV'Void)
#endif
    return _result

glMultiModeDrawArraysIBM :: MonadIO m => Ptr PrimitiveType -> Ptr GL.GLint -> Ptr GL.GLsizei -> GL.GLsizei -> GL.GLint -> m ()
glMultiModeDrawArraysIBM mode first count primcount modestride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiModeDrawArraysIBM" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'GLsizei primcount, LogV'GLint modestride]
#endif
    _result <- GL.glMultiModeDrawArraysIBM (coerce mode) first count primcount modestride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiModeDrawArraysIBM" (LogV'Void)
#endif
    return _result

glMultiModeDrawElementsIBM :: MonadIO m => Ptr PrimitiveType -> Ptr GL.GLsizei -> GL.GLenum -> Ptr (Ptr ()) -> GL.GLsizei -> GL.GLint -> m ()
glMultiModeDrawElementsIBM mode count type' indices primcount modestride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiModeDrawElementsIBM" [LogV'Ptr, LogV'Ptr, LogV'GLenum type', LogV'Ptr, LogV'GLsizei primcount, LogV'GLint modestride]
#endif
    _result <- GL.glMultiModeDrawElementsIBM (coerce mode) count type' indices primcount modestride
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiModeDrawElementsIBM" (LogV'Void)
#endif
    return _result

glMultiTexBufferEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLenum -> Buffer -> m ()
glMultiTexBufferEXT texunit target internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexBufferEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glMultiTexBufferEXT (coerce texunit) (coerce target) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexBufferEXT" (LogV'Void)
#endif
    return _result

glMultiTexCoord1dARB :: MonadIO m => TextureUnit -> GL.GLdouble -> m ()
glMultiTexCoord1dARB target s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1dARB" [LogV'GLenum target, LogV'GLdouble s]
#endif
    _result <- GL.glMultiTexCoord1dARB (coerce target) s
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1dARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1dvARB :: MonadIO m => TextureUnit -> Ptr GL.GLdouble -> m ()
glMultiTexCoord1dvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1dvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord1dvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1dvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1fARB :: MonadIO m => TextureUnit -> GL.GLfloat -> m ()
glMultiTexCoord1fARB target s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1fARB" [LogV'GLenum target, LogV'GLfloat s]
#endif
    _result <- GL.glMultiTexCoord1fARB (coerce target) s
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1fARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1fvARB :: MonadIO m => TextureUnit -> Ptr GL.GLfloat -> m ()
glMultiTexCoord1fvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1fvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord1fvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1fvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1hNV :: MonadIO m => TextureUnit -> GL.GLhalfNV -> m ()
glMultiTexCoord1hNV target s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1hNV" [LogV'GLenum target, LogV'GLhalfNV s]
#endif
    _result <- GL.glMultiTexCoord1hNV (coerce target) s
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1hNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord1hvNV :: MonadIO m => TextureUnit -> Ptr GL.GLhalfNV -> m ()
glMultiTexCoord1hvNV target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1hvNV" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord1hvNV (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1hvNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord1iARB :: MonadIO m => TextureUnit -> GL.GLint -> m ()
glMultiTexCoord1iARB target s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1iARB" [LogV'GLenum target, LogV'GLint s]
#endif
    _result <- GL.glMultiTexCoord1iARB (coerce target) s
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1iARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1ivARB :: MonadIO m => TextureUnit -> Ptr GL.GLint -> m ()
glMultiTexCoord1ivARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1ivARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord1ivARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1ivARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1sARB :: MonadIO m => TextureUnit -> GL.GLshort -> m ()
glMultiTexCoord1sARB target s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1sARB" [LogV'GLenum target, LogV'GLshort s]
#endif
    _result <- GL.glMultiTexCoord1sARB (coerce target) s
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1sARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord1svARB :: MonadIO m => TextureUnit -> Ptr GL.GLshort -> m ()
glMultiTexCoord1svARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord1svARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord1svARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord1svARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2dARB :: MonadIO m => TextureUnit -> GL.GLdouble -> GL.GLdouble -> m ()
glMultiTexCoord2dARB target s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2dARB" [LogV'GLenum target, LogV'GLdouble s, LogV'GLdouble t]
#endif
    _result <- GL.glMultiTexCoord2dARB (coerce target) s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2dARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2dvARB :: MonadIO m => TextureUnit -> Ptr GL.GLdouble -> m ()
glMultiTexCoord2dvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2dvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord2dvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2dvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2fARB :: MonadIO m => TextureUnit -> GL.GLfloat -> GL.GLfloat -> m ()
glMultiTexCoord2fARB target s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2fARB" [LogV'GLenum target, LogV'GLfloat s, LogV'GLfloat t]
#endif
    _result <- GL.glMultiTexCoord2fARB (coerce target) s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2fARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2fvARB :: MonadIO m => TextureUnit -> Ptr GL.GLfloat -> m ()
glMultiTexCoord2fvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2fvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord2fvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2fvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2hNV :: MonadIO m => TextureUnit -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glMultiTexCoord2hNV target s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2hNV" [LogV'GLenum target, LogV'GLhalfNV s, LogV'GLhalfNV t]
#endif
    _result <- GL.glMultiTexCoord2hNV (coerce target) s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2hNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord2hvNV :: MonadIO m => TextureUnit -> Ptr GL.GLhalfNV -> m ()
glMultiTexCoord2hvNV target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2hvNV" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord2hvNV (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2hvNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord2iARB :: MonadIO m => TextureUnit -> GL.GLint -> GL.GLint -> m ()
glMultiTexCoord2iARB target s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2iARB" [LogV'GLenum target, LogV'GLint s, LogV'GLint t]
#endif
    _result <- GL.glMultiTexCoord2iARB (coerce target) s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2iARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2ivARB :: MonadIO m => TextureUnit -> Ptr GL.GLint -> m ()
glMultiTexCoord2ivARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2ivARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord2ivARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2ivARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2sARB :: MonadIO m => TextureUnit -> GL.GLshort -> GL.GLshort -> m ()
glMultiTexCoord2sARB target s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2sARB" [LogV'GLenum target, LogV'GLshort s, LogV'GLshort t]
#endif
    _result <- GL.glMultiTexCoord2sARB (coerce target) s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2sARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord2svARB :: MonadIO m => TextureUnit -> Ptr GL.GLshort -> m ()
glMultiTexCoord2svARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord2svARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord2svARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord2svARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3dARB :: MonadIO m => TextureUnit -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMultiTexCoord3dARB target s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3dARB" [LogV'GLenum target, LogV'GLdouble s, LogV'GLdouble t, LogV'GLdouble r]
#endif
    _result <- GL.glMultiTexCoord3dARB (coerce target) s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3dARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3dvARB :: MonadIO m => TextureUnit -> Ptr GL.GLdouble -> m ()
glMultiTexCoord3dvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3dvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord3dvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3dvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3fARB :: MonadIO m => TextureUnit -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glMultiTexCoord3fARB target s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3fARB" [LogV'GLenum target, LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat r]
#endif
    _result <- GL.glMultiTexCoord3fARB (coerce target) s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3fARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3fvARB :: MonadIO m => TextureUnit -> Ptr GL.GLfloat -> m ()
glMultiTexCoord3fvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3fvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord3fvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3fvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3hNV :: MonadIO m => TextureUnit -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glMultiTexCoord3hNV target s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3hNV" [LogV'GLenum target, LogV'GLhalfNV s, LogV'GLhalfNV t, LogV'GLhalfNV r]
#endif
    _result <- GL.glMultiTexCoord3hNV (coerce target) s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3hNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord3hvNV :: MonadIO m => TextureUnit -> Ptr GL.GLhalfNV -> m ()
glMultiTexCoord3hvNV target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3hvNV" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord3hvNV (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3hvNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord3iARB :: MonadIO m => TextureUnit -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glMultiTexCoord3iARB target s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3iARB" [LogV'GLenum target, LogV'GLint s, LogV'GLint t, LogV'GLint r]
#endif
    _result <- GL.glMultiTexCoord3iARB (coerce target) s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3iARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3ivARB :: MonadIO m => TextureUnit -> Ptr GL.GLint -> m ()
glMultiTexCoord3ivARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3ivARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord3ivARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3ivARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3sARB :: MonadIO m => TextureUnit -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glMultiTexCoord3sARB target s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3sARB" [LogV'GLenum target, LogV'GLshort s, LogV'GLshort t, LogV'GLshort r]
#endif
    _result <- GL.glMultiTexCoord3sARB (coerce target) s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3sARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord3svARB :: MonadIO m => TextureUnit -> Ptr GL.GLshort -> m ()
glMultiTexCoord3svARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord3svARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord3svARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord3svARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4dARB :: MonadIO m => TextureUnit -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glMultiTexCoord4dARB target s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4dARB" [LogV'GLenum target, LogV'GLdouble s, LogV'GLdouble t, LogV'GLdouble r, LogV'GLdouble q]
#endif
    _result <- GL.glMultiTexCoord4dARB (coerce target) s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4dARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4dvARB :: MonadIO m => TextureUnit -> Ptr GL.GLdouble -> m ()
glMultiTexCoord4dvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4dvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord4dvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4dvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4fARB :: MonadIO m => TextureUnit -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glMultiTexCoord4fARB target s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4fARB" [LogV'GLenum target, LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat r, LogV'GLfloat q]
#endif
    _result <- GL.glMultiTexCoord4fARB (coerce target) s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4fARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4fvARB :: MonadIO m => TextureUnit -> Ptr GL.GLfloat -> m ()
glMultiTexCoord4fvARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4fvARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord4fvARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4fvARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4hNV :: MonadIO m => TextureUnit -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glMultiTexCoord4hNV target s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4hNV" [LogV'GLenum target, LogV'GLhalfNV s, LogV'GLhalfNV t, LogV'GLhalfNV r, LogV'GLhalfNV q]
#endif
    _result <- GL.glMultiTexCoord4hNV (coerce target) s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4hNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord4hvNV :: MonadIO m => TextureUnit -> Ptr GL.GLhalfNV -> m ()
glMultiTexCoord4hvNV target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4hvNV" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord4hvNV (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4hvNV" (LogV'Void)
#endif
    return _result

glMultiTexCoord4iARB :: MonadIO m => TextureUnit -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glMultiTexCoord4iARB target s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4iARB" [LogV'GLenum target, LogV'GLint s, LogV'GLint t, LogV'GLint r, LogV'GLint q]
#endif
    _result <- GL.glMultiTexCoord4iARB (coerce target) s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4iARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4ivARB :: MonadIO m => TextureUnit -> Ptr GL.GLint -> m ()
glMultiTexCoord4ivARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4ivARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord4ivARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4ivARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4sARB :: MonadIO m => TextureUnit -> GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glMultiTexCoord4sARB target s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4sARB" [LogV'GLenum target, LogV'GLshort s, LogV'GLshort t, LogV'GLshort r, LogV'GLshort q]
#endif
    _result <- GL.glMultiTexCoord4sARB (coerce target) s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4sARB" (LogV'Void)
#endif
    return _result

glMultiTexCoord4svARB :: MonadIO m => TextureUnit -> Ptr GL.GLshort -> m ()
glMultiTexCoord4svARB target v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoord4svARB" [LogV'GLenum target, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoord4svARB (coerce target) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoord4svARB" (LogV'Void)
#endif
    return _result

glMultiTexCoordP1ui :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> m ()
glMultiTexCoordP1ui texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP1ui" [LogV'GLenum texture, LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glMultiTexCoordP1ui texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP1ui" (LogV'Void)
#endif
    return _result

glMultiTexCoordP1uiv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLuint -> m ()
glMultiTexCoordP1uiv texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP1uiv" [LogV'GLenum texture, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoordP1uiv texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP1uiv" (LogV'Void)
#endif
    return _result

glMultiTexCoordP2ui :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> m ()
glMultiTexCoordP2ui texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP2ui" [LogV'GLenum texture, LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glMultiTexCoordP2ui texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP2ui" (LogV'Void)
#endif
    return _result

glMultiTexCoordP2uiv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLuint -> m ()
glMultiTexCoordP2uiv texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP2uiv" [LogV'GLenum texture, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoordP2uiv texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP2uiv" (LogV'Void)
#endif
    return _result

glMultiTexCoordP3ui :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> m ()
glMultiTexCoordP3ui texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP3ui" [LogV'GLenum texture, LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glMultiTexCoordP3ui texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP3ui" (LogV'Void)
#endif
    return _result

glMultiTexCoordP3uiv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLuint -> m ()
glMultiTexCoordP3uiv texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP3uiv" [LogV'GLenum texture, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoordP3uiv texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP3uiv" (LogV'Void)
#endif
    return _result

glMultiTexCoordP4ui :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLuint -> m ()
glMultiTexCoordP4ui texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP4ui" [LogV'GLenum texture, LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glMultiTexCoordP4ui texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP4ui" (LogV'Void)
#endif
    return _result

glMultiTexCoordP4uiv :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLuint -> m ()
glMultiTexCoordP4uiv texture type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordP4uiv" [LogV'GLenum texture, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoordP4uiv texture type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordP4uiv" (LogV'Void)
#endif
    return _result

glMultiTexCoordPointerEXT :: MonadIO m => TextureUnit -> GL.GLint -> TexCoordPointerType -> GL.GLsizei -> Ptr () -> m ()
glMultiTexCoordPointerEXT texunit size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexCoordPointerEXT" [LogV'GLenum texunit, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glMultiTexCoordPointerEXT (coerce texunit) size (coerce type') stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexCoordPointerEXT" (LogV'Void)
#endif
    return _result

glMultiTexEnvfEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> GL.GLfloat -> m ()
glMultiTexEnvfEXT texunit target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexEnvfEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glMultiTexEnvfEXT (coerce texunit) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexEnvfEXT" (LogV'Void)
#endif
    return _result

glMultiTexEnvfvEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> Ptr GL.GLfloat -> m ()
glMultiTexEnvfvEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexEnvfvEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexEnvfvEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexEnvfvEXT" (LogV'Void)
#endif
    return _result

glMultiTexEnviEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> GL.GLint -> m ()
glMultiTexEnviEXT texunit target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexEnviEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glMultiTexEnviEXT (coerce texunit) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexEnviEXT" (LogV'Void)
#endif
    return _result

glMultiTexEnvivEXT :: MonadIO m => TextureUnit -> TextureEnvTarget -> TextureEnvParameter -> Ptr GL.GLint -> m ()
glMultiTexEnvivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexEnvivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexEnvivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexEnvivEXT" (LogV'Void)
#endif
    return _result

glMultiTexGendEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> GL.GLdouble -> m ()
glMultiTexGendEXT texunit coord pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGendEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'GLdouble param]
#endif
    _result <- GL.glMultiTexGendEXT (coerce texunit) (coerce coord) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGendEXT" (LogV'Void)
#endif
    return _result

glMultiTexGendvEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLdouble -> m ()
glMultiTexGendvEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGendvEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexGendvEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGendvEXT" (LogV'Void)
#endif
    return _result

glMultiTexGenfEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> GL.GLfloat -> m ()
glMultiTexGenfEXT texunit coord pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGenfEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glMultiTexGenfEXT (coerce texunit) (coerce coord) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGenfEXT" (LogV'Void)
#endif
    return _result

glMultiTexGenfvEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLfloat -> m ()
glMultiTexGenfvEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGenfvEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexGenfvEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGenfvEXT" (LogV'Void)
#endif
    return _result

glMultiTexGeniEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> GL.GLint -> m ()
glMultiTexGeniEXT texunit coord pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGeniEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glMultiTexGeniEXT (coerce texunit) (coerce coord) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGeniEXT" (LogV'Void)
#endif
    return _result

glMultiTexGenivEXT :: MonadIO m => TextureUnit -> TextureCoordName -> TextureGenParameter -> Ptr GL.GLint -> m ()
glMultiTexGenivEXT texunit coord pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexGenivEXT" [LogV'GLenum texunit, LogV'GLenum coord, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexGenivEXT (coerce texunit) (coerce coord) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexGenivEXT" (LogV'Void)
#endif
    return _result

glMultiTexImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexImage1DEXT texunit target level internalformat width border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexImage1DEXT (coerce texunit) (coerce target) level internalformat width border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexImage1DEXT" (LogV'Void)
#endif
    return _result

glMultiTexImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexImage2DEXT texunit target level internalformat width height border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexImage2DEXT (coerce texunit) (coerce target) level internalformat width height border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexImage2DEXT" (LogV'Void)
#endif
    return _result

glMultiTexImage3DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexImage3DEXT texunit target level internalformat width height depth border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexImage3DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexImage3DEXT (coerce texunit) (coerce target) level internalformat width height depth border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexImage3DEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameterIivEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glMultiTexParameterIivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameterIivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexParameterIivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameterIivEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameterIuivEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> Ptr GL.GLuint -> m ()
glMultiTexParameterIuivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameterIuivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexParameterIuivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameterIuivEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameterfEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> GL.GLfloat -> m ()
glMultiTexParameterfEXT texunit target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameterfEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glMultiTexParameterfEXT (coerce texunit) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameterfEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameterfvEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> Ptr GL.GLfloat -> m ()
glMultiTexParameterfvEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameterfvEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexParameterfvEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameterfvEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameteriEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> GL.GLint -> m ()
glMultiTexParameteriEXT texunit target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameteriEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glMultiTexParameteriEXT (coerce texunit) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameteriEXT" (LogV'Void)
#endif
    return _result

glMultiTexParameterivEXT :: MonadIO m => TextureUnit -> TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glMultiTexParameterivEXT texunit target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexParameterivEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glMultiTexParameterivEXT (coerce texunit) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexParameterivEXT" (LogV'Void)
#endif
    return _result

glMultiTexRenderbufferEXT :: MonadIO m => TextureUnit -> TextureTarget -> Renderbuffer -> m ()
glMultiTexRenderbufferEXT texunit target renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexRenderbufferEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glMultiTexRenderbufferEXT (coerce texunit) (coerce target) (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexRenderbufferEXT" (LogV'Void)
#endif
    return _result

glMultiTexSubImage1DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexSubImage1DEXT texunit target level xoffset width format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexSubImage1DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexSubImage1DEXT (coerce texunit) (coerce target) level xoffset width (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexSubImage1DEXT" (LogV'Void)
#endif
    return _result

glMultiTexSubImage2DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexSubImage2DEXT texunit target level xoffset yoffset width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexSubImage2DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexSubImage2DEXT (coerce texunit) (coerce target) level xoffset yoffset width height (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexSubImage2DEXT" (LogV'Void)
#endif
    return _result

glMultiTexSubImage3DEXT :: MonadIO m => TextureUnit -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glMultiTexSubImage3DEXT texunit target level xoffset yoffset zoffset width height depth format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glMultiTexSubImage3DEXT" [LogV'GLenum texunit, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glMultiTexSubImage3DEXT (coerce texunit) (coerce target) level xoffset yoffset zoffset width height depth (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glMultiTexSubImage3DEXT" (LogV'Void)
#endif
    return _result

glNamedBufferData :: MonadIO m => Buffer -> GL.GLsizeiptr -> Ptr () -> GL.GLenum -> m ()
glNamedBufferData buffer size data' usage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferData" [LogV'GLuint buffer, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLenum usage]
#endif
    _result <- GL.glNamedBufferData (coerce buffer) size data' usage
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferData" (LogV'Void)
#endif
    return _result

glNamedBufferDataEXT :: MonadIO m => Buffer -> GL.GLsizeiptr -> Ptr () -> GL.GLenum -> m ()
glNamedBufferDataEXT buffer size data' usage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferDataEXT" [LogV'GLuint buffer, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLenum usage]
#endif
    _result <- GL.glNamedBufferDataEXT (coerce buffer) size data' usage
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferDataEXT" (LogV'Void)
#endif
    return _result

glNamedBufferStorage :: MonadIO m => Buffer -> GL.GLsizeiptr -> Ptr () -> GL.GLbitfield -> m ()
glNamedBufferStorage buffer size data' flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferStorage" [LogV'GLuint buffer, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLbitfield flags]
#endif
    _result <- GL.glNamedBufferStorage (coerce buffer) size data' flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferStorage" (LogV'Void)
#endif
    return _result

glNamedBufferStorageEXT :: MonadIO m => Buffer -> GL.GLsizeiptr -> Ptr () -> GL.GLbitfield -> m ()
glNamedBufferStorageEXT buffer size data' flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferStorageEXT" [LogV'GLuint buffer, LogV'GLsizeiptr size, LogV'Ptr, LogV'GLbitfield flags]
#endif
    _result <- GL.glNamedBufferStorageEXT (coerce buffer) size data' flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferStorageEXT" (LogV'Void)
#endif
    return _result

glNamedBufferSubData :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glNamedBufferSubData buffer offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferSubData" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glNamedBufferSubData (coerce buffer) offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferSubData" (LogV'Void)
#endif
    return _result

glNamedBufferSubDataEXT :: MonadIO m => Buffer -> GL.GLintptr -> GL.GLsizeiptr -> Ptr () -> m ()
glNamedBufferSubDataEXT buffer offset size data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedBufferSubDataEXT" [LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size, LogV'Ptr]
#endif
    _result <- GL.glNamedBufferSubDataEXT (coerce buffer) offset size data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedBufferSubDataEXT" (LogV'Void)
#endif
    return _result

glNamedCopyBufferSubDataEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLintptr -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glNamedCopyBufferSubDataEXT readBuffer writeBuffer readOffset writeOffset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedCopyBufferSubDataEXT" [LogV'GLuint readBuffer, LogV'GLuint writeBuffer, LogV'GLintptr readOffset, LogV'GLintptr writeOffset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glNamedCopyBufferSubDataEXT readBuffer writeBuffer readOffset writeOffset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedCopyBufferSubDataEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferDrawBuffer :: MonadIO m => Framebuffer -> GL.GLenum -> m ()
glNamedFramebufferDrawBuffer framebuffer buf = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferDrawBuffer" [LogV'GLuint framebuffer, LogV'GLenum buf]
#endif
    _result <- GL.glNamedFramebufferDrawBuffer (coerce framebuffer) buf
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferDrawBuffer" (LogV'Void)
#endif
    return _result

glNamedFramebufferDrawBuffers :: MonadIO m => Framebuffer -> GL.GLsizei -> Ptr GL.GLenum -> m ()
glNamedFramebufferDrawBuffers framebuffer n bufs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferDrawBuffers" [LogV'GLuint framebuffer, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glNamedFramebufferDrawBuffers (coerce framebuffer) n bufs
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferDrawBuffers" (LogV'Void)
#endif
    return _result

glNamedFramebufferParameteri :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> m ()
glNamedFramebufferParameteri framebuffer pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferParameteri" [LogV'GLuint framebuffer, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glNamedFramebufferParameteri (coerce framebuffer) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferParameteri" (LogV'Void)
#endif
    return _result

glNamedFramebufferParameteriEXT :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLint -> m ()
glNamedFramebufferParameteriEXT framebuffer pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferParameteriEXT" [LogV'GLuint framebuffer, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glNamedFramebufferParameteriEXT (coerce framebuffer) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferParameteriEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferReadBuffer :: MonadIO m => Framebuffer -> GL.GLenum -> m ()
glNamedFramebufferReadBuffer framebuffer src = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferReadBuffer" [LogV'GLuint framebuffer, LogV'GLenum src]
#endif
    _result <- GL.glNamedFramebufferReadBuffer (coerce framebuffer) src
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferReadBuffer" (LogV'Void)
#endif
    return _result

glNamedFramebufferRenderbuffer :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLenum -> Renderbuffer -> m ()
glNamedFramebufferRenderbuffer framebuffer attachment renderbuffertarget renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferRenderbuffer" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum renderbuffertarget, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glNamedFramebufferRenderbuffer (coerce framebuffer) attachment renderbuffertarget (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferRenderbuffer" (LogV'Void)
#endif
    return _result

glNamedFramebufferRenderbufferEXT :: MonadIO m => Framebuffer -> GL.GLenum -> GL.GLenum -> Renderbuffer -> m ()
glNamedFramebufferRenderbufferEXT framebuffer attachment renderbuffertarget renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferRenderbufferEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum renderbuffertarget, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glNamedFramebufferRenderbufferEXT (coerce framebuffer) attachment renderbuffertarget (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferRenderbufferEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferSampleLocationsfvARB :: MonadIO m => Framebuffer -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glNamedFramebufferSampleLocationsfvARB framebuffer start count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferSampleLocationsfvARB" [LogV'GLuint framebuffer, LogV'GLuint start, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glNamedFramebufferSampleLocationsfvARB (coerce framebuffer) start count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferSampleLocationsfvARB" (LogV'Void)
#endif
    return _result

glNamedFramebufferTexture :: MonadIO m => Framebuffer -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glNamedFramebufferTexture framebuffer attachment texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTexture" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glNamedFramebufferTexture (coerce framebuffer) attachment (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTexture" (LogV'Void)
#endif
    return _result

glNamedFramebufferTexture1DEXT :: MonadIO m => Framebuffer -> GL.GLenum -> TextureTarget -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glNamedFramebufferTexture1DEXT framebuffer attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTexture1DEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glNamedFramebufferTexture1DEXT (coerce framebuffer) attachment (coerce textarget) (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTexture1DEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferTexture2DEXT :: MonadIO m => Framebuffer -> GL.GLenum -> TextureTarget -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glNamedFramebufferTexture2DEXT framebuffer attachment textarget texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTexture2DEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glNamedFramebufferTexture2DEXT (coerce framebuffer) attachment (coerce textarget) (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTexture2DEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferTexture3DEXT :: MonadIO m => Framebuffer -> GL.GLenum -> TextureTarget -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glNamedFramebufferTexture3DEXT framebuffer attachment textarget texture level zoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTexture3DEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLenum textarget, LogV'GLuint texture, LogV'GLint level, LogV'GLint zoffset]
#endif
    _result <- GL.glNamedFramebufferTexture3DEXT (coerce framebuffer) attachment (coerce textarget) (coerce texture) level zoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTexture3DEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferTextureEXT :: MonadIO m => Framebuffer -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> m ()
glNamedFramebufferTextureEXT framebuffer attachment texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTextureEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glNamedFramebufferTextureEXT (coerce framebuffer) attachment (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTextureEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferTextureFaceEXT :: MonadIO m => Framebuffer -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> TextureTarget -> m ()
glNamedFramebufferTextureFaceEXT framebuffer attachment texture level face = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTextureFaceEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLenum face]
#endif
    _result <- GL.glNamedFramebufferTextureFaceEXT (coerce framebuffer) attachment (coerce texture) level (coerce face)
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTextureFaceEXT" (LogV'Void)
#endif
    return _result

glNamedFramebufferTextureLayer :: MonadIO m => Framebuffer -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glNamedFramebufferTextureLayer framebuffer attachment texture level layer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTextureLayer" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLint layer]
#endif
    _result <- GL.glNamedFramebufferTextureLayer (coerce framebuffer) attachment (coerce texture) level layer
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTextureLayer" (LogV'Void)
#endif
    return _result

glNamedFramebufferTextureLayerEXT :: MonadIO m => Framebuffer -> GL.GLenum -> Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> m ()
glNamedFramebufferTextureLayerEXT framebuffer attachment texture level layer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedFramebufferTextureLayerEXT" [LogV'GLuint framebuffer, LogV'GLenum attachment, LogV'GLuint texture, LogV'GLint level, LogV'GLint layer]
#endif
    _result <- GL.glNamedFramebufferTextureLayerEXT (coerce framebuffer) attachment (coerce texture) level layer
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedFramebufferTextureLayerEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameter4dEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glNamedProgramLocalParameter4dEXT program target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameter4dEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glNamedProgramLocalParameter4dEXT (coerce program) target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameter4dEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameter4dvEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glNamedProgramLocalParameter4dvEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameter4dvEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParameter4dvEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameter4dvEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameter4fEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glNamedProgramLocalParameter4fEXT program target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameter4fEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glNamedProgramLocalParameter4fEXT (coerce program) target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameter4fEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameter4fvEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glNamedProgramLocalParameter4fvEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameter4fvEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParameter4fvEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameter4fvEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameterI4iEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glNamedProgramLocalParameterI4iEXT program target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameterI4iEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glNamedProgramLocalParameterI4iEXT (coerce program) target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameterI4iEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameterI4ivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glNamedProgramLocalParameterI4ivEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameterI4ivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParameterI4ivEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameterI4ivEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameterI4uiEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glNamedProgramLocalParameterI4uiEXT program target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameterI4uiEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z, LogV'GLuint w]
#endif
    _result <- GL.glNamedProgramLocalParameterI4uiEXT (coerce program) target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameterI4uiEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameterI4uivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glNamedProgramLocalParameterI4uivEXT program target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameterI4uivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParameterI4uivEXT (coerce program) target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameterI4uivEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParameters4fvEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glNamedProgramLocalParameters4fvEXT program target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParameters4fvEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParameters4fvEXT (coerce program) target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParameters4fvEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParametersI4ivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLint -> m ()
glNamedProgramLocalParametersI4ivEXT program target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParametersI4ivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParametersI4ivEXT (coerce program) target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParametersI4ivEXT" (LogV'Void)
#endif
    return _result

glNamedProgramLocalParametersI4uivEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glNamedProgramLocalParametersI4uivEXT program target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramLocalParametersI4uivEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramLocalParametersI4uivEXT (coerce program) target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramLocalParametersI4uivEXT" (LogV'Void)
#endif
    return _result

glNamedProgramStringEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glNamedProgramStringEXT program target format len string = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedProgramStringEXT" [LogV'GLuint program, LogV'GLenum target, LogV'GLenum format, LogV'GLsizei len, LogV'Ptr]
#endif
    _result <- GL.glNamedProgramStringEXT (coerce program) target format len string
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedProgramStringEXT" (LogV'Void)
#endif
    return _result

glNamedRenderbufferStorage :: MonadIO m => Renderbuffer -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glNamedRenderbufferStorage renderbuffer internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedRenderbufferStorage" [LogV'GLuint renderbuffer, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glNamedRenderbufferStorage (coerce renderbuffer) internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedRenderbufferStorage" (LogV'Void)
#endif
    return _result

glNamedRenderbufferStorageEXT :: MonadIO m => Renderbuffer -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glNamedRenderbufferStorageEXT renderbuffer internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedRenderbufferStorageEXT" [LogV'GLuint renderbuffer, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glNamedRenderbufferStorageEXT (coerce renderbuffer) internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedRenderbufferStorageEXT" (LogV'Void)
#endif
    return _result

glNamedRenderbufferStorageMultisample :: MonadIO m => Renderbuffer -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glNamedRenderbufferStorageMultisample renderbuffer samples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedRenderbufferStorageMultisample" [LogV'GLuint renderbuffer, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glNamedRenderbufferStorageMultisample (coerce renderbuffer) samples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedRenderbufferStorageMultisample" (LogV'Void)
#endif
    return _result

glNamedRenderbufferStorageMultisampleCoverageEXT :: MonadIO m => Renderbuffer -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glNamedRenderbufferStorageMultisampleCoverageEXT renderbuffer coverageSamples colorSamples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedRenderbufferStorageMultisampleCoverageEXT" [LogV'GLuint renderbuffer, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glNamedRenderbufferStorageMultisampleCoverageEXT (coerce renderbuffer) coverageSamples colorSamples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedRenderbufferStorageMultisampleCoverageEXT" (LogV'Void)
#endif
    return _result

glNamedRenderbufferStorageMultisampleEXT :: MonadIO m => Renderbuffer -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glNamedRenderbufferStorageMultisampleEXT renderbuffer samples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNamedRenderbufferStorageMultisampleEXT" [LogV'GLuint renderbuffer, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glNamedRenderbufferStorageMultisampleEXT (coerce renderbuffer) samples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glNamedRenderbufferStorageMultisampleEXT" (LogV'Void)
#endif
    return _result

glNewObjectBufferATI :: MonadIO m => GL.GLsizei -> Ptr () -> GL.GLenum -> m GL.GLuint
glNewObjectBufferATI size pointer usage = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNewObjectBufferATI" [LogV'GLsizei size, LogV'Ptr, LogV'GLenum usage]
#endif
    _result <- GL.glNewObjectBufferATI size pointer usage
#ifdef GLW_DEBUG
    logGLCommandEnd "glNewObjectBufferATI" (LogV'GLuint _result)
#endif
    return _result

glNormal3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glNormal3fVertex3fSUN nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormal3fVertex3fSUN" [LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glNormal3fVertex3fSUN nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glNormal3fVertex3fvSUN n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glNormal3fVertex3fvSUN n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glNormal3hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glNormal3hNV nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormal3hNV" [LogV'GLhalfNV nx, LogV'GLhalfNV ny, LogV'GLhalfNV nz]
#endif
    _result <- GL.glNormal3hNV nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormal3hNV" (LogV'Void)
#endif
    return _result

glNormal3hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glNormal3hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormal3hvNV" [LogV'Ptr]
#endif
    _result <- GL.glNormal3hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormal3hvNV" (LogV'Void)
#endif
    return _result

glNormalFormatNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> m ()
glNormalFormatNV type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalFormatNV" [LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glNormalFormatNV type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalFormatNV" (LogV'Void)
#endif
    return _result

glNormalP3ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glNormalP3ui type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalP3ui" [LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glNormalP3ui type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalP3ui" (LogV'Void)
#endif
    return _result

glNormalP3uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glNormalP3uiv type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalP3uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glNormalP3uiv type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalP3uiv" (LogV'Void)
#endif
    return _result

glNormalPointerEXT :: MonadIO m => NormalPointerType -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glNormalPointerEXT type' stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalPointerEXT" [LogV'GLenum type', LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glNormalPointerEXT (coerce type') stride count pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalPointerEXT" (LogV'Void)
#endif
    return _result

glNormalPointerListIBM :: MonadIO m => NormalPointerType -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glNormalPointerListIBM type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalPointerListIBM" [LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glNormalPointerListIBM (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalPointerListIBM" (LogV'Void)
#endif
    return _result

glNormalPointervINTEL :: MonadIO m => NormalPointerType -> Ptr (Ptr ()) -> m ()
glNormalPointervINTEL type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalPointervINTEL" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glNormalPointervINTEL (coerce type') pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalPointervINTEL" (LogV'Void)
#endif
    return _result

glNormalStream3bATI :: MonadIO m => GL.GLenum -> GL.GLbyte -> GL.GLbyte -> GL.GLbyte -> m ()
glNormalStream3bATI stream nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3bATI" [LogV'GLenum stream, LogV'GLbyte nx, LogV'GLbyte ny, LogV'GLbyte nz]
#endif
    _result <- GL.glNormalStream3bATI stream nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3bATI" (LogV'Void)
#endif
    return _result

glNormalStream3bvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLbyte -> m ()
glNormalStream3bvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3bvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glNormalStream3bvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3bvATI" (LogV'Void)
#endif
    return _result

glNormalStream3dATI :: MonadIO m => GL.GLenum -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glNormalStream3dATI stream nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3dATI" [LogV'GLenum stream, LogV'GLdouble nx, LogV'GLdouble ny, LogV'GLdouble nz]
#endif
    _result <- GL.glNormalStream3dATI stream nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3dATI" (LogV'Void)
#endif
    return _result

glNormalStream3dvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glNormalStream3dvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3dvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glNormalStream3dvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3dvATI" (LogV'Void)
#endif
    return _result

glNormalStream3fATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glNormalStream3fATI stream nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3fATI" [LogV'GLenum stream, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz]
#endif
    _result <- GL.glNormalStream3fATI stream nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3fATI" (LogV'Void)
#endif
    return _result

glNormalStream3fvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glNormalStream3fvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3fvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glNormalStream3fvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3fvATI" (LogV'Void)
#endif
    return _result

glNormalStream3iATI :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glNormalStream3iATI stream nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3iATI" [LogV'GLenum stream, LogV'GLint nx, LogV'GLint ny, LogV'GLint nz]
#endif
    _result <- GL.glNormalStream3iATI stream nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3iATI" (LogV'Void)
#endif
    return _result

glNormalStream3ivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glNormalStream3ivATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3ivATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glNormalStream3ivATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3ivATI" (LogV'Void)
#endif
    return _result

glNormalStream3sATI :: MonadIO m => GL.GLenum -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glNormalStream3sATI stream nx ny nz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3sATI" [LogV'GLenum stream, LogV'GLshort nx, LogV'GLshort ny, LogV'GLshort nz]
#endif
    _result <- GL.glNormalStream3sATI stream nx ny nz
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3sATI" (LogV'Void)
#endif
    return _result

glNormalStream3svATI :: MonadIO m => GL.GLenum -> Ptr GL.GLshort -> m ()
glNormalStream3svATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glNormalStream3svATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glNormalStream3svATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glNormalStream3svATI" (LogV'Void)
#endif
    return _result

glObjectLabel :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLchar -> m ()
glObjectLabel identifier name length label = do
#ifdef GLW_DEBUG
    logGLCommandStart "glObjectLabel" [LogV'GLenum identifier, LogV'GLuint name, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glObjectLabel identifier name length label
#ifdef GLW_DEBUG
    logGLCommandEnd "glObjectLabel" (LogV'Void)
#endif
    return _result

glObjectPtrLabel :: MonadIO m => Ptr () -> GL.GLsizei -> Ptr GL.GLchar -> m ()
glObjectPtrLabel ptr length label = do
#ifdef GLW_DEBUG
    logGLCommandStart "glObjectPtrLabel" [LogV'Ptr, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glObjectPtrLabel ptr length label
#ifdef GLW_DEBUG
    logGLCommandEnd "glObjectPtrLabel" (LogV'Void)
#endif
    return _result

glObjectPurgeableAPPLE :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> m GL.GLenum
glObjectPurgeableAPPLE objectType name option = do
#ifdef GLW_DEBUG
    logGLCommandStart "glObjectPurgeableAPPLE" [LogV'GLenum objectType, LogV'GLuint name, LogV'GLenum option]
#endif
    _result <- GL.glObjectPurgeableAPPLE objectType name option
#ifdef GLW_DEBUG
    logGLCommandEnd "glObjectPurgeableAPPLE" (LogV'GLenum _result)
#endif
    return _result

glObjectUnpurgeableAPPLE :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> m GL.GLenum
glObjectUnpurgeableAPPLE objectType name option = do
#ifdef GLW_DEBUG
    logGLCommandStart "glObjectUnpurgeableAPPLE" [LogV'GLenum objectType, LogV'GLuint name, LogV'GLenum option]
#endif
    _result <- GL.glObjectUnpurgeableAPPLE objectType name option
#ifdef GLW_DEBUG
    logGLCommandEnd "glObjectUnpurgeableAPPLE" (LogV'GLenum _result)
#endif
    return _result

glPNTrianglesfATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glPNTrianglesfATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPNTrianglesfATI" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPNTrianglesfATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPNTrianglesfATI" (LogV'Void)
#endif
    return _result

glPNTrianglesiATI :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glPNTrianglesiATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPNTrianglesiATI" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPNTrianglesiATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPNTrianglesiATI" (LogV'Void)
#endif
    return _result

glPassTexCoordATI :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> m ()
glPassTexCoordATI dst coord swizzle = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPassTexCoordATI" [LogV'GLuint dst, LogV'GLuint coord, LogV'GLenum swizzle]
#endif
    _result <- GL.glPassTexCoordATI dst coord swizzle
#ifdef GLW_DEBUG
    logGLCommandEnd "glPassTexCoordATI" (LogV'Void)
#endif
    return _result

glPatchParameterfv :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glPatchParameterfv pname values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPatchParameterfv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPatchParameterfv pname values
#ifdef GLW_DEBUG
    logGLCommandEnd "glPatchParameterfv" (LogV'Void)
#endif
    return _result

glPatchParameteri :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glPatchParameteri pname value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPatchParameteri" [LogV'GLenum pname, LogV'GLint value]
#endif
    _result <- GL.glPatchParameteri pname value
#ifdef GLW_DEBUG
    logGLCommandEnd "glPatchParameteri" (LogV'Void)
#endif
    return _result

glPauseTransformFeedback :: MonadIO m => m ()
glPauseTransformFeedback  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPauseTransformFeedback" []
#endif
    _result <- GL.glPauseTransformFeedback 
#ifdef GLW_DEBUG
    logGLCommandEnd "glPauseTransformFeedback" (LogV'Void)
#endif
    return _result

glPauseTransformFeedbackNV :: MonadIO m => m ()
glPauseTransformFeedbackNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPauseTransformFeedbackNV" []
#endif
    _result <- GL.glPauseTransformFeedbackNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glPauseTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glPixelDataRangeNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glPixelDataRangeNV target length pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelDataRangeNV" [LogV'GLenum target, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glPixelDataRangeNV target length pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelDataRangeNV" (LogV'Void)
#endif
    return _result

glPixelStoref :: MonadIO m => PixelStoreParameter -> GL.GLfloat -> m ()
glPixelStoref pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelStoref" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPixelStoref (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelStoref" (LogV'Void)
#endif
    return _result

glPixelStorei :: MonadIO m => PixelStoreParameter -> GL.GLint -> m ()
glPixelStorei pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelStorei" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPixelStorei (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelStorei" (LogV'Void)
#endif
    return _result

glPixelTexGenParameterfSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> GL.GLfloat -> m ()
glPixelTexGenParameterfSGIS pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTexGenParameterfSGIS" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPixelTexGenParameterfSGIS (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTexGenParameterfSGIS" (LogV'Void)
#endif
    return _result

glPixelTexGenParameterfvSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> Ptr GL.GLfloat -> m ()
glPixelTexGenParameterfvSGIS pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTexGenParameterfvSGIS" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPixelTexGenParameterfvSGIS (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTexGenParameterfvSGIS" (LogV'Void)
#endif
    return _result

glPixelTexGenParameteriSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> GL.GLint -> m ()
glPixelTexGenParameteriSGIS pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTexGenParameteriSGIS" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPixelTexGenParameteriSGIS (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTexGenParameteriSGIS" (LogV'Void)
#endif
    return _result

glPixelTexGenParameterivSGIS :: MonadIO m => PixelTexGenParameterNameSGIS -> Ptr GL.GLint -> m ()
glPixelTexGenParameterivSGIS pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTexGenParameterivSGIS" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPixelTexGenParameterivSGIS (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTexGenParameterivSGIS" (LogV'Void)
#endif
    return _result

glPixelTexGenSGIX :: MonadIO m => GL.GLenum -> m ()
glPixelTexGenSGIX mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTexGenSGIX" [LogV'GLenum mode]
#endif
    _result <- GL.glPixelTexGenSGIX mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTexGenSGIX" (LogV'Void)
#endif
    return _result

glPixelTransformParameterfEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLfloat -> m ()
glPixelTransformParameterfEXT target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTransformParameterfEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPixelTransformParameterfEXT target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTransformParameterfEXT" (LogV'Void)
#endif
    return _result

glPixelTransformParameterfvEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glPixelTransformParameterfvEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTransformParameterfvEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPixelTransformParameterfvEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTransformParameterfvEXT" (LogV'Void)
#endif
    return _result

glPixelTransformParameteriEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLint -> m ()
glPixelTransformParameteriEXT target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTransformParameteriEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPixelTransformParameteriEXT target pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTransformParameteriEXT" (LogV'Void)
#endif
    return _result

glPixelTransformParameterivEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> Ptr GL.GLint -> m ()
glPixelTransformParameterivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPixelTransformParameterivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPixelTransformParameterivEXT target pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPixelTransformParameterivEXT" (LogV'Void)
#endif
    return _result

glPointParameterf :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glPointParameterf pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterf" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPointParameterf pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterf" (LogV'Void)
#endif
    return _result

glPointParameterfARB :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glPointParameterfARB pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfARB" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPointParameterfARB pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfARB" (LogV'Void)
#endif
    return _result

glPointParameterfEXT :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glPointParameterfEXT pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfEXT" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPointParameterfEXT pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfEXT" (LogV'Void)
#endif
    return _result

glPointParameterfSGIS :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glPointParameterfSGIS pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfSGIS" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glPointParameterfSGIS pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfSGIS" (LogV'Void)
#endif
    return _result

glPointParameterfv :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glPointParameterfv pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameterfv pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfv" (LogV'Void)
#endif
    return _result

glPointParameterfvARB :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glPointParameterfvARB pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfvARB" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameterfvARB pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfvARB" (LogV'Void)
#endif
    return _result

glPointParameterfvEXT :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glPointParameterfvEXT pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfvEXT" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameterfvEXT pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfvEXT" (LogV'Void)
#endif
    return _result

glPointParameterfvSGIS :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glPointParameterfvSGIS pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterfvSGIS" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameterfvSGIS pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterfvSGIS" (LogV'Void)
#endif
    return _result

glPointParameteri :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glPointParameteri pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameteri" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPointParameteri pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameteri" (LogV'Void)
#endif
    return _result

glPointParameteriNV :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glPointParameteriNV pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameteriNV" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glPointParameteriNV pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameteriNV" (LogV'Void)
#endif
    return _result

glPointParameteriv :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glPointParameteriv pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameteriv" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameteriv pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameteriv" (LogV'Void)
#endif
    return _result

glPointParameterivNV :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glPointParameterivNV pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointParameterivNV" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glPointParameterivNV pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointParameterivNV" (LogV'Void)
#endif
    return _result

glPointSize :: MonadIO m => GL.GLfloat -> m ()
glPointSize size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPointSize" [LogV'GLfloat size]
#endif
    _result <- GL.glPointSize size
#ifdef GLW_DEBUG
    logGLCommandEnd "glPointSize" (LogV'Void)
#endif
    return _result

glPollAsyncSGIX :: MonadIO m => Ptr GL.GLuint -> m GL.GLint
glPollAsyncSGIX markerp = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPollAsyncSGIX" [LogV'Ptr]
#endif
    _result <- GL.glPollAsyncSGIX markerp
#ifdef GLW_DEBUG
    logGLCommandEnd "glPollAsyncSGIX" (LogV'GLint _result)
#endif
    return _result

glPollInstrumentsSGIX :: MonadIO m => Ptr GL.GLint -> m GL.GLint
glPollInstrumentsSGIX marker_p = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPollInstrumentsSGIX" [LogV'Ptr]
#endif
    _result <- GL.glPollInstrumentsSGIX marker_p
#ifdef GLW_DEBUG
    logGLCommandEnd "glPollInstrumentsSGIX" (LogV'GLint _result)
#endif
    return _result

glPolygonMode :: MonadIO m => MaterialFace -> PolygonMode -> m ()
glPolygonMode face mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPolygonMode" [LogV'GLenum face, LogV'GLenum mode]
#endif
    _result <- GL.glPolygonMode (coerce face) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glPolygonMode" (LogV'Void)
#endif
    return _result

glPolygonOffset :: MonadIO m => GL.GLfloat -> GL.GLfloat -> m ()
glPolygonOffset factor units = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPolygonOffset" [LogV'GLfloat factor, LogV'GLfloat units]
#endif
    _result <- GL.glPolygonOffset factor units
#ifdef GLW_DEBUG
    logGLCommandEnd "glPolygonOffset" (LogV'Void)
#endif
    return _result

glPolygonOffsetEXT :: MonadIO m => GL.GLfloat -> GL.GLfloat -> m ()
glPolygonOffsetEXT factor bias = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPolygonOffsetEXT" [LogV'GLfloat factor, LogV'GLfloat bias]
#endif
    _result <- GL.glPolygonOffsetEXT factor bias
#ifdef GLW_DEBUG
    logGLCommandEnd "glPolygonOffsetEXT" (LogV'Void)
#endif
    return _result

glPopDebugGroup :: MonadIO m => m ()
glPopDebugGroup  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPopDebugGroup" []
#endif
    _result <- GL.glPopDebugGroup 
#ifdef GLW_DEBUG
    logGLCommandEnd "glPopDebugGroup" (LogV'Void)
#endif
    return _result

glPresentFrameDualFillNV :: MonadIO m => GL.GLuint -> GL.GLuint64EXT -> GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLuint -> m ()
glPresentFrameDualFillNV video_slot minPresentTime beginPresentTimeId presentDurationId type' target0 fill0 target1 fill1 target2 fill2 target3 fill3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPresentFrameDualFillNV" [LogV'GLuint video_slot, LogV'GLuint64EXT minPresentTime, LogV'GLuint beginPresentTimeId, LogV'GLuint presentDurationId, LogV'GLenum type', LogV'GLenum target0, LogV'GLuint fill0, LogV'GLenum target1, LogV'GLuint fill1, LogV'GLenum target2, LogV'GLuint fill2, LogV'GLenum target3, LogV'GLuint fill3]
#endif
    _result <- GL.glPresentFrameDualFillNV video_slot minPresentTime beginPresentTimeId presentDurationId type' target0 fill0 target1 fill1 target2 fill2 target3 fill3
#ifdef GLW_DEBUG
    logGLCommandEnd "glPresentFrameDualFillNV" (LogV'Void)
#endif
    return _result

glPresentFrameKeyedNV :: MonadIO m => GL.GLuint -> GL.GLuint64EXT -> GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLuint -> GL.GLuint -> m ()
glPresentFrameKeyedNV video_slot minPresentTime beginPresentTimeId presentDurationId type' target0 fill0 key0 target1 fill1 key1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPresentFrameKeyedNV" [LogV'GLuint video_slot, LogV'GLuint64EXT minPresentTime, LogV'GLuint beginPresentTimeId, LogV'GLuint presentDurationId, LogV'GLenum type', LogV'GLenum target0, LogV'GLuint fill0, LogV'GLuint key0, LogV'GLenum target1, LogV'GLuint fill1, LogV'GLuint key1]
#endif
    _result <- GL.glPresentFrameKeyedNV video_slot minPresentTime beginPresentTimeId presentDurationId type' target0 fill0 key0 target1 fill1 key1
#ifdef GLW_DEBUG
    logGLCommandEnd "glPresentFrameKeyedNV" (LogV'Void)
#endif
    return _result

glPrimitiveBoundingBoxARB :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glPrimitiveBoundingBoxARB minX minY minZ minW maxX maxY maxZ maxW = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPrimitiveBoundingBoxARB" [LogV'GLfloat minX, LogV'GLfloat minY, LogV'GLfloat minZ, LogV'GLfloat minW, LogV'GLfloat maxX, LogV'GLfloat maxY, LogV'GLfloat maxZ, LogV'GLfloat maxW]
#endif
    _result <- GL.glPrimitiveBoundingBoxARB minX minY minZ minW maxX maxY maxZ maxW
#ifdef GLW_DEBUG
    logGLCommandEnd "glPrimitiveBoundingBoxARB" (LogV'Void)
#endif
    return _result

glPrimitiveRestartIndex :: MonadIO m => GL.GLuint -> m ()
glPrimitiveRestartIndex index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPrimitiveRestartIndex" [LogV'GLuint index]
#endif
    _result <- GL.glPrimitiveRestartIndex index
#ifdef GLW_DEBUG
    logGLCommandEnd "glPrimitiveRestartIndex" (LogV'Void)
#endif
    return _result

glPrimitiveRestartIndexNV :: MonadIO m => GL.GLuint -> m ()
glPrimitiveRestartIndexNV index = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPrimitiveRestartIndexNV" [LogV'GLuint index]
#endif
    _result <- GL.glPrimitiveRestartIndexNV index
#ifdef GLW_DEBUG
    logGLCommandEnd "glPrimitiveRestartIndexNV" (LogV'Void)
#endif
    return _result

glPrimitiveRestartNV :: MonadIO m => m ()
glPrimitiveRestartNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPrimitiveRestartNV" []
#endif
    _result <- GL.glPrimitiveRestartNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glPrimitiveRestartNV" (LogV'Void)
#endif
    return _result

glPrioritizeTexturesEXT :: MonadIO m => GL.GLsizei -> Ptr (Texture (a :: TextureTarget')) -> Ptr GL.GLclampf -> m ()
glPrioritizeTexturesEXT n textures priorities = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPrioritizeTexturesEXT" [LogV'GLsizei n, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glPrioritizeTexturesEXT n (coerce textures) priorities
#ifdef GLW_DEBUG
    logGLCommandEnd "glPrioritizeTexturesEXT" (LogV'Void)
#endif
    return _result

glProgramBinary :: MonadIO m => Program -> GL.GLenum -> Ptr () -> GL.GLsizei -> m ()
glProgramBinary program binaryFormat binary length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramBinary" [LogV'GLuint program, LogV'GLenum binaryFormat, LogV'Ptr, LogV'GLsizei length]
#endif
    _result <- GL.glProgramBinary (coerce program) binaryFormat binary length
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramBinary" (LogV'Void)
#endif
    return _result

glProgramBufferParametersIivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramBufferParametersIivNV target bindingIndex wordIndex count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramBufferParametersIivNV" [LogV'GLenum target, LogV'GLuint bindingIndex, LogV'GLuint wordIndex, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramBufferParametersIivNV target bindingIndex wordIndex count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramBufferParametersIivNV" (LogV'Void)
#endif
    return _result

glProgramBufferParametersIuivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramBufferParametersIuivNV target bindingIndex wordIndex count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramBufferParametersIuivNV" [LogV'GLenum target, LogV'GLuint bindingIndex, LogV'GLuint wordIndex, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramBufferParametersIuivNV target bindingIndex wordIndex count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramBufferParametersIuivNV" (LogV'Void)
#endif
    return _result

glProgramBufferParametersfvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramBufferParametersfvNV target bindingIndex wordIndex count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramBufferParametersfvNV" [LogV'GLenum target, LogV'GLuint bindingIndex, LogV'GLuint wordIndex, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramBufferParametersfvNV target bindingIndex wordIndex count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramBufferParametersfvNV" (LogV'Void)
#endif
    return _result

glProgramEnvParameter4dARB :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramEnvParameter4dARB target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameter4dARB" [LogV'GLenum target, LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glProgramEnvParameter4dARB target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameter4dARB" (LogV'Void)
#endif
    return _result

glProgramEnvParameter4dvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glProgramEnvParameter4dvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameter4dvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParameter4dvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameter4dvARB" (LogV'Void)
#endif
    return _result

glProgramEnvParameter4fARB :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramEnvParameter4fARB target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameter4fARB" [LogV'GLenum target, LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glProgramEnvParameter4fARB target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameter4fARB" (LogV'Void)
#endif
    return _result

glProgramEnvParameter4fvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glProgramEnvParameter4fvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameter4fvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParameter4fvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameter4fvARB" (LogV'Void)
#endif
    return _result

glProgramEnvParameterI4iNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramEnvParameterI4iNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameterI4iNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glProgramEnvParameterI4iNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameterI4iNV" (LogV'Void)
#endif
    return _result

glProgramEnvParameterI4ivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glProgramEnvParameterI4ivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameterI4ivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParameterI4ivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameterI4ivNV" (LogV'Void)
#endif
    return _result

glProgramEnvParameterI4uiNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramEnvParameterI4uiNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameterI4uiNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z, LogV'GLuint w]
#endif
    _result <- GL.glProgramEnvParameterI4uiNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameterI4uiNV" (LogV'Void)
#endif
    return _result

glProgramEnvParameterI4uivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glProgramEnvParameterI4uivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameterI4uivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParameterI4uivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameterI4uivNV" (LogV'Void)
#endif
    return _result

glProgramEnvParameters4fvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramEnvParameters4fvEXT target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParameters4fvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParameters4fvEXT target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParameters4fvEXT" (LogV'Void)
#endif
    return _result

glProgramEnvParametersI4ivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramEnvParametersI4ivNV target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParametersI4ivNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParametersI4ivNV target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParametersI4ivNV" (LogV'Void)
#endif
    return _result

glProgramEnvParametersI4uivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramEnvParametersI4uivNV target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramEnvParametersI4uivNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramEnvParametersI4uivNV target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramEnvParametersI4uivNV" (LogV'Void)
#endif
    return _result

glProgramLocalParameter4dARB :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramLocalParameter4dARB target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameter4dARB" [LogV'GLenum target, LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glProgramLocalParameter4dARB target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameter4dARB" (LogV'Void)
#endif
    return _result

glProgramLocalParameter4dvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glProgramLocalParameter4dvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameter4dvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParameter4dvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameter4dvARB" (LogV'Void)
#endif
    return _result

glProgramLocalParameter4fARB :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramLocalParameter4fARB target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameter4fARB" [LogV'GLenum target, LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glProgramLocalParameter4fARB target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameter4fARB" (LogV'Void)
#endif
    return _result

glProgramLocalParameter4fvARB :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glProgramLocalParameter4fvARB target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameter4fvARB" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParameter4fvARB target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameter4fvARB" (LogV'Void)
#endif
    return _result

glProgramLocalParameterI4iNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramLocalParameterI4iNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameterI4iNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glProgramLocalParameterI4iNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameterI4iNV" (LogV'Void)
#endif
    return _result

glProgramLocalParameterI4ivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLint -> m ()
glProgramLocalParameterI4ivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameterI4ivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParameterI4ivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameterI4ivNV" (LogV'Void)
#endif
    return _result

glProgramLocalParameterI4uiNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramLocalParameterI4uiNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameterI4uiNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z, LogV'GLuint w]
#endif
    _result <- GL.glProgramLocalParameterI4uiNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameterI4uiNV" (LogV'Void)
#endif
    return _result

glProgramLocalParameterI4uivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLuint -> m ()
glProgramLocalParameterI4uivNV target index params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameterI4uivNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParameterI4uivNV target index params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameterI4uivNV" (LogV'Void)
#endif
    return _result

glProgramLocalParameters4fvEXT :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramLocalParameters4fvEXT target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParameters4fvEXT" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParameters4fvEXT target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParameters4fvEXT" (LogV'Void)
#endif
    return _result

glProgramLocalParametersI4ivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramLocalParametersI4ivNV target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParametersI4ivNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParametersI4ivNV target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParametersI4ivNV" (LogV'Void)
#endif
    return _result

glProgramLocalParametersI4uivNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramLocalParametersI4uivNV target index count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramLocalParametersI4uivNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramLocalParametersI4uivNV target index count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramLocalParametersI4uivNV" (LogV'Void)
#endif
    return _result

glProgramNamedParameter4dNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramNamedParameter4dNV id len name x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramNamedParameter4dNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glProgramNamedParameter4dNV id len name x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramNamedParameter4dNV" (LogV'Void)
#endif
    return _result

glProgramNamedParameter4dvNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> Ptr GL.GLdouble -> m ()
glProgramNamedParameter4dvNV id len name v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramNamedParameter4dvNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glProgramNamedParameter4dvNV id len name v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramNamedParameter4dvNV" (LogV'Void)
#endif
    return _result

glProgramNamedParameter4fNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramNamedParameter4fNV id len name x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramNamedParameter4fNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glProgramNamedParameter4fNV id len name x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramNamedParameter4fNV" (LogV'Void)
#endif
    return _result

glProgramNamedParameter4fvNV :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glProgramNamedParameter4fvNV id len name v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramNamedParameter4fvNV" [LogV'GLuint id, LogV'GLsizei len, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glProgramNamedParameter4fvNV id len name v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramNamedParameter4fvNV" (LogV'Void)
#endif
    return _result

glProgramParameter4dNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramParameter4dNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameter4dNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glProgramParameter4dNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameter4dNV" (LogV'Void)
#endif
    return _result

glProgramParameter4dvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLdouble -> m ()
glProgramParameter4dvNV target index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameter4dvNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramParameter4dvNV target index v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameter4dvNV" (LogV'Void)
#endif
    return _result

glProgramParameter4fNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramParameter4fNV target index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameter4fNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glProgramParameter4fNV target index x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameter4fNV" (LogV'Void)
#endif
    return _result

glProgramParameter4fvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glProgramParameter4fvNV target index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameter4fvNV" [LogV'GLenum target, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glProgramParameter4fvNV target index v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameter4fvNV" (LogV'Void)
#endif
    return _result

glProgramParameteri :: MonadIO m => Program -> GL.GLenum -> GL.GLint -> m ()
glProgramParameteri program pname value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameteri" [LogV'GLuint program, LogV'GLenum pname, LogV'GLint value]
#endif
    _result <- GL.glProgramParameteri (coerce program) pname value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameteri" (LogV'Void)
#endif
    return _result

glProgramParameteriARB :: MonadIO m => Program -> GL.GLenum -> GL.GLint -> m ()
glProgramParameteriARB program pname value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameteriARB" [LogV'GLuint program, LogV'GLenum pname, LogV'GLint value]
#endif
    _result <- GL.glProgramParameteriARB (coerce program) pname value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameteriARB" (LogV'Void)
#endif
    return _result

glProgramParameteriEXT :: MonadIO m => Program -> GL.GLenum -> GL.GLint -> m ()
glProgramParameteriEXT program pname value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameteriEXT" [LogV'GLuint program, LogV'GLenum pname, LogV'GLint value]
#endif
    _result <- GL.glProgramParameteriEXT (coerce program) pname value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameteriEXT" (LogV'Void)
#endif
    return _result

glProgramParameters4dvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramParameters4dvNV target index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameters4dvNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramParameters4dvNV target index count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameters4dvNV" (LogV'Void)
#endif
    return _result

glProgramParameters4fvNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramParameters4fvNV target index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramParameters4fvNV" [LogV'GLenum target, LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramParameters4fvNV target index count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramParameters4fvNV" (LogV'Void)
#endif
    return _result

glProgramStringARB :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glProgramStringARB target format len string = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramStringARB" [LogV'GLenum target, LogV'GLenum format, LogV'GLsizei len, LogV'Ptr]
#endif
    _result <- GL.glProgramStringARB target format len string
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramStringARB" (LogV'Void)
#endif
    return _result

glProgramSubroutineParametersuivNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramSubroutineParametersuivNV target count params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramSubroutineParametersuivNV" [LogV'GLenum target, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramSubroutineParametersuivNV target count params
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramSubroutineParametersuivNV" (LogV'Void)
#endif
    return _result

glProgramUniform1d :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> m ()
glProgramUniform1d program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1d" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble v0]
#endif
    _result <- GL.glProgramUniform1d (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1d" (LogV'Void)
#endif
    return _result

glProgramUniform1dEXT :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> m ()
glProgramUniform1dEXT program location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1dEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble x]
#endif
    _result <- GL.glProgramUniform1dEXT (coerce program) (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1dEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform1dv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1dv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1dv" (LogV'Void)
#endif
    return _result

glProgramUniform1dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform1dvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1dvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1f :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> m ()
glProgramUniform1f program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1f" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0]
#endif
    _result <- GL.glProgramUniform1f (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1f" (LogV'Void)
#endif
    return _result

glProgramUniform1fEXT :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> m ()
glProgramUniform1fEXT program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1fEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0]
#endif
    _result <- GL.glProgramUniform1fEXT (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1fEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform1fv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1fv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1fv" (LogV'Void)
#endif
    return _result

glProgramUniform1fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform1fvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1fvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1i :: MonadIO m => Program -> UniformLocation -> GL.GLint -> m ()
glProgramUniform1i program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1i" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0]
#endif
    _result <- GL.glProgramUniform1i (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1i" (LogV'Void)
#endif
    return _result

glProgramUniform1i64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLint64 -> m ()
glProgramUniform1i64ARB program location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1i64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLint64 x]
#endif
    _result <- GL.glProgramUniform1i64ARB (coerce program) (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1i64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform1i64NV :: MonadIO m => Program -> UniformLocation -> GL.GLint64EXT -> m ()
glProgramUniform1i64NV program location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1i64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLint64EXT x]
#endif
    _result <- GL.glProgramUniform1i64NV (coerce program) (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1i64NV" (LogV'Void)
#endif
    return _result

glProgramUniform1i64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glProgramUniform1i64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1i64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1i64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1i64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform1i64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glProgramUniform1i64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1i64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1i64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1i64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform1iEXT :: MonadIO m => Program -> UniformLocation -> GL.GLint -> m ()
glProgramUniform1iEXT program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1iEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0]
#endif
    _result <- GL.glProgramUniform1iEXT (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1iEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1iv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform1iv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1iv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1iv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1iv" (LogV'Void)
#endif
    return _result

glProgramUniform1ivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform1ivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1ivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1ui :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> m ()
glProgramUniform1ui program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ui" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0]
#endif
    _result <- GL.glProgramUniform1ui (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ui" (LogV'Void)
#endif
    return _result

glProgramUniform1ui64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLuint64 -> m ()
glProgramUniform1ui64ARB program location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ui64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64 x]
#endif
    _result <- GL.glProgramUniform1ui64ARB (coerce program) (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ui64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform1ui64NV :: MonadIO m => Program -> UniformLocation -> GL.GLuint64EXT -> m ()
glProgramUniform1ui64NV program location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ui64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64EXT x]
#endif
    _result <- GL.glProgramUniform1ui64NV (coerce program) (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ui64NV" (LogV'Void)
#endif
    return _result

glProgramUniform1ui64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glProgramUniform1ui64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1ui64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ui64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform1ui64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glProgramUniform1ui64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1ui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1ui64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1ui64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform1uiEXT :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> m ()
glProgramUniform1uiEXT program location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1uiEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0]
#endif
    _result <- GL.glProgramUniform1uiEXT (coerce program) (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1uiEXT" (LogV'Void)
#endif
    return _result

glProgramUniform1uiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform1uiv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1uiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1uiv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1uiv" (LogV'Void)
#endif
    return _result

glProgramUniform1uivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform1uivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform1uivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform1uivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform1uivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2d :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform2d program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2d" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble v0, LogV'GLdouble v1]
#endif
    _result <- GL.glProgramUniform2d (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2d" (LogV'Void)
#endif
    return _result

glProgramUniform2dEXT :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform2dEXT program location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2dEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glProgramUniform2dEXT (coerce program) (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2dEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform2dv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2dv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2dv" (LogV'Void)
#endif
    return _result

glProgramUniform2dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform2dvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2dvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2f :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform2f program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2f" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1]
#endif
    _result <- GL.glProgramUniform2f (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2f" (LogV'Void)
#endif
    return _result

glProgramUniform2fEXT :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform2fEXT program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2fEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1]
#endif
    _result <- GL.glProgramUniform2fEXT (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2fEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform2fv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2fv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2fv" (LogV'Void)
#endif
    return _result

glProgramUniform2fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform2fvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2fvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2i :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> m ()
glProgramUniform2i program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2i" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1]
#endif
    _result <- GL.glProgramUniform2i (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2i" (LogV'Void)
#endif
    return _result

glProgramUniform2i64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLint64 -> GL.GLint64 -> m ()
glProgramUniform2i64ARB program location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2i64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y]
#endif
    _result <- GL.glProgramUniform2i64ARB (coerce program) (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2i64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform2i64NV :: MonadIO m => Program -> UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glProgramUniform2i64NV program location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2i64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y]
#endif
    _result <- GL.glProgramUniform2i64NV (coerce program) (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2i64NV" (LogV'Void)
#endif
    return _result

glProgramUniform2i64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glProgramUniform2i64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2i64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2i64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2i64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform2i64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glProgramUniform2i64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2i64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2i64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2i64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform2iEXT :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> m ()
glProgramUniform2iEXT program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2iEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1]
#endif
    _result <- GL.glProgramUniform2iEXT (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2iEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2iv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform2iv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2iv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2iv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2iv" (LogV'Void)
#endif
    return _result

glProgramUniform2ivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform2ivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2ivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2ui :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform2ui program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ui" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1]
#endif
    _result <- GL.glProgramUniform2ui (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ui" (LogV'Void)
#endif
    return _result

glProgramUniform2ui64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> m ()
glProgramUniform2ui64ARB program location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ui64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y]
#endif
    _result <- GL.glProgramUniform2ui64ARB (coerce program) (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ui64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform2ui64NV :: MonadIO m => Program -> UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glProgramUniform2ui64NV program location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ui64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y]
#endif
    _result <- GL.glProgramUniform2ui64NV (coerce program) (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ui64NV" (LogV'Void)
#endif
    return _result

glProgramUniform2ui64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glProgramUniform2ui64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2ui64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ui64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform2ui64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glProgramUniform2ui64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2ui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2ui64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2ui64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform2uiEXT :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform2uiEXT program location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2uiEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1]
#endif
    _result <- GL.glProgramUniform2uiEXT (coerce program) (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2uiEXT" (LogV'Void)
#endif
    return _result

glProgramUniform2uiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform2uiv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2uiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2uiv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2uiv" (LogV'Void)
#endif
    return _result

glProgramUniform2uivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform2uivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform2uivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform2uivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform2uivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3d :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform3d program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3d" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble v0, LogV'GLdouble v1, LogV'GLdouble v2]
#endif
    _result <- GL.glProgramUniform3d (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3d" (LogV'Void)
#endif
    return _result

glProgramUniform3dEXT :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform3dEXT program location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3dEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glProgramUniform3dEXT (coerce program) (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3dEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform3dv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3dv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3dv" (LogV'Void)
#endif
    return _result

glProgramUniform3dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform3dvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3dvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3f :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform3f program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3f" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2]
#endif
    _result <- GL.glProgramUniform3f (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3f" (LogV'Void)
#endif
    return _result

glProgramUniform3fEXT :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform3fEXT program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3fEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2]
#endif
    _result <- GL.glProgramUniform3fEXT (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3fEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform3fv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3fv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3fv" (LogV'Void)
#endif
    return _result

glProgramUniform3fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform3fvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3fvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3i :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramUniform3i program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3i" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2]
#endif
    _result <- GL.glProgramUniform3i (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3i" (LogV'Void)
#endif
    return _result

glProgramUniform3i64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> m ()
glProgramUniform3i64ARB program location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3i64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y, LogV'GLint64 z]
#endif
    _result <- GL.glProgramUniform3i64ARB (coerce program) (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3i64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform3i64NV :: MonadIO m => Program -> UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glProgramUniform3i64NV program location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3i64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z]
#endif
    _result <- GL.glProgramUniform3i64NV (coerce program) (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3i64NV" (LogV'Void)
#endif
    return _result

glProgramUniform3i64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glProgramUniform3i64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3i64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3i64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3i64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform3i64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glProgramUniform3i64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3i64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3i64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3i64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform3iEXT :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramUniform3iEXT program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3iEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2]
#endif
    _result <- GL.glProgramUniform3iEXT (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3iEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3iv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform3iv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3iv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3iv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3iv" (LogV'Void)
#endif
    return _result

glProgramUniform3ivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform3ivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3ivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3ui :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform3ui program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ui" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2]
#endif
    _result <- GL.glProgramUniform3ui (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ui" (LogV'Void)
#endif
    return _result

glProgramUniform3ui64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> m ()
glProgramUniform3ui64ARB program location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ui64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y, LogV'GLuint64 z]
#endif
    _result <- GL.glProgramUniform3ui64ARB (coerce program) (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ui64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform3ui64NV :: MonadIO m => Program -> UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glProgramUniform3ui64NV program location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ui64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z]
#endif
    _result <- GL.glProgramUniform3ui64NV (coerce program) (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ui64NV" (LogV'Void)
#endif
    return _result

glProgramUniform3ui64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glProgramUniform3ui64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3ui64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ui64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform3ui64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glProgramUniform3ui64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3ui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3ui64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3ui64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform3uiEXT :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform3uiEXT program location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3uiEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2]
#endif
    _result <- GL.glProgramUniform3uiEXT (coerce program) (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3uiEXT" (LogV'Void)
#endif
    return _result

glProgramUniform3uiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform3uiv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3uiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3uiv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3uiv" (LogV'Void)
#endif
    return _result

glProgramUniform3uivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform3uivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform3uivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform3uivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform3uivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4d :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform4d program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4d" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble v0, LogV'GLdouble v1, LogV'GLdouble v2, LogV'GLdouble v3]
#endif
    _result <- GL.glProgramUniform4d (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4d" (LogV'Void)
#endif
    return _result

glProgramUniform4dEXT :: MonadIO m => Program -> UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glProgramUniform4dEXT program location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4dEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glProgramUniform4dEXT (coerce program) (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4dEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform4dv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4dv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4dv" (LogV'Void)
#endif
    return _result

glProgramUniform4dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glProgramUniform4dvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4dvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4f :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform4f program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4f" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLfloat v3]
#endif
    _result <- GL.glProgramUniform4f (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4f" (LogV'Void)
#endif
    return _result

glProgramUniform4fEXT :: MonadIO m => Program -> UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glProgramUniform4fEXT program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4fEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLfloat v3]
#endif
    _result <- GL.glProgramUniform4fEXT (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4fEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform4fv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4fv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4fv" (LogV'Void)
#endif
    return _result

glProgramUniform4fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glProgramUniform4fvEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4fvEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4i :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramUniform4i program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4i" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2, LogV'GLint v3]
#endif
    _result <- GL.glProgramUniform4i (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4i" (LogV'Void)
#endif
    return _result

glProgramUniform4i64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> m ()
glProgramUniform4i64ARB program location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4i64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y, LogV'GLint64 z, LogV'GLint64 w]
#endif
    _result <- GL.glProgramUniform4i64ARB (coerce program) (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4i64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform4i64NV :: MonadIO m => Program -> UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glProgramUniform4i64NV program location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4i64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z, LogV'GLint64EXT w]
#endif
    _result <- GL.glProgramUniform4i64NV (coerce program) (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4i64NV" (LogV'Void)
#endif
    return _result

glProgramUniform4i64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glProgramUniform4i64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4i64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4i64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4i64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform4i64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glProgramUniform4i64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4i64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4i64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4i64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform4iEXT :: MonadIO m => Program -> UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glProgramUniform4iEXT program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4iEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2, LogV'GLint v3]
#endif
    _result <- GL.glProgramUniform4iEXT (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4iEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4iv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform4iv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4iv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4iv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4iv" (LogV'Void)
#endif
    return _result

glProgramUniform4ivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glProgramUniform4ivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4ivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ivEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4ui :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform4ui program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ui" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2, LogV'GLuint v3]
#endif
    _result <- GL.glProgramUniform4ui (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ui" (LogV'Void)
#endif
    return _result

glProgramUniform4ui64ARB :: MonadIO m => Program -> UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> m ()
glProgramUniform4ui64ARB program location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ui64ARB" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y, LogV'GLuint64 z, LogV'GLuint64 w]
#endif
    _result <- GL.glProgramUniform4ui64ARB (coerce program) (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ui64ARB" (LogV'Void)
#endif
    return _result

glProgramUniform4ui64NV :: MonadIO m => Program -> UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glProgramUniform4ui64NV program location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ui64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z, LogV'GLuint64EXT w]
#endif
    _result <- GL.glProgramUniform4ui64NV (coerce program) (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ui64NV" (LogV'Void)
#endif
    return _result

glProgramUniform4ui64vARB :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glProgramUniform4ui64vARB program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ui64vARB" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4ui64vARB (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ui64vARB" (LogV'Void)
#endif
    return _result

glProgramUniform4ui64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glProgramUniform4ui64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4ui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4ui64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4ui64vNV" (LogV'Void)
#endif
    return _result

glProgramUniform4uiEXT :: MonadIO m => Program -> UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glProgramUniform4uiEXT program location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4uiEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2, LogV'GLuint v3]
#endif
    _result <- GL.glProgramUniform4uiEXT (coerce program) (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4uiEXT" (LogV'Void)
#endif
    return _result

glProgramUniform4uiv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform4uiv program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4uiv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4uiv (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4uiv" (LogV'Void)
#endif
    return _result

glProgramUniform4uivEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glProgramUniform4uivEXT program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniform4uivEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniform4uivEXT (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniform4uivEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x3dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2x3dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x3dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x3dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x3dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x3dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2x3dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x3dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x3dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x3dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x3fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2x3fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x3fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x3fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x3fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x3fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2x3fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x3fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x3fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x3fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x4dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2x4dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x4dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x4dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x4dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x4dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix2x4dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x4dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x4dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x4dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x4fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2x4fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x4fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x4fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x4fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix2x4fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix2x4fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix2x4fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix2x4fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix2x4fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x2dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3x2dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x2dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x2dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x2dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x2dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3x2dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x2dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x2dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x2dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x2fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3x2fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x2fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x2fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x2fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x2fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3x2fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x2fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x2fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x2fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x4dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3x4dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x4dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x4dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x4dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x4dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix3x4dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x4dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x4dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x4dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x4fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3x4fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x4fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x4fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x4fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix3x4fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix3x4fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix3x4fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix3x4fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix3x4fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x2dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4x2dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x2dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x2dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x2dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x2dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4x2dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x2dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x2dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x2dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x2fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4x2fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x2fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x2fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x2fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x2fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4x2fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x2fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x2fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x2fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x3dv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4x3dv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x3dv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x3dv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x3dv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x3dvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glProgramUniformMatrix4x3dvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x3dvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x3dvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x3dvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x3fv :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4x3fv program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x3fv" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x3fv (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x3fv" (LogV'Void)
#endif
    return _result

glProgramUniformMatrix4x3fvEXT :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glProgramUniformMatrix4x3fvEXT program location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformMatrix4x3fvEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformMatrix4x3fvEXT (coerce program) (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformMatrix4x3fvEXT" (LogV'Void)
#endif
    return _result

glProgramUniformui64NV :: MonadIO m => Program -> UniformLocation -> GL.GLuint64EXT -> m ()
glProgramUniformui64NV program location value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformui64NV" [LogV'GLuint program, LogV'GLint location, LogV'GLuint64EXT value]
#endif
    _result <- GL.glProgramUniformui64NV (coerce program) (coerce location) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformui64NV" (LogV'Void)
#endif
    return _result

glProgramUniformui64vNV :: MonadIO m => Program -> UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glProgramUniformui64vNV program location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramUniformui64vNV" [LogV'GLuint program, LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glProgramUniformui64vNV (coerce program) (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramUniformui64vNV" (LogV'Void)
#endif
    return _result

glProgramVertexLimitNV :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glProgramVertexLimitNV target limit = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProgramVertexLimitNV" [LogV'GLenum target, LogV'GLint limit]
#endif
    _result <- GL.glProgramVertexLimitNV target limit
#ifdef GLW_DEBUG
    logGLCommandEnd "glProgramVertexLimitNV" (LogV'Void)
#endif
    return _result

glProvokingVertex :: MonadIO m => GL.GLenum -> m ()
glProvokingVertex mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProvokingVertex" [LogV'GLenum mode]
#endif
    _result <- GL.glProvokingVertex mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glProvokingVertex" (LogV'Void)
#endif
    return _result

glProvokingVertexEXT :: MonadIO m => GL.GLenum -> m ()
glProvokingVertexEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glProvokingVertexEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glProvokingVertexEXT mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glProvokingVertexEXT" (LogV'Void)
#endif
    return _result

glPushClientAttribDefaultEXT :: MonadIO m => ClientAttribMask -> m ()
glPushClientAttribDefaultEXT mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPushClientAttribDefaultEXT" [LogV'GLbitfield mask]
#endif
    _result <- GL.glPushClientAttribDefaultEXT (coerce mask)
#ifdef GLW_DEBUG
    logGLCommandEnd "glPushClientAttribDefaultEXT" (LogV'Void)
#endif
    return _result

glPushDebugGroup :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLsizei -> Ptr GL.GLchar -> m ()
glPushDebugGroup source id length message = do
#ifdef GLW_DEBUG
    logGLCommandStart "glPushDebugGroup" [LogV'GLenum source, LogV'GLuint id, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glPushDebugGroup source id length message
#ifdef GLW_DEBUG
    logGLCommandEnd "glPushDebugGroup" (LogV'Void)
#endif
    return _result

glQueryCounter :: MonadIO m => Query (a :: QueryTarget) -> GL.GLenum -> m ()
glQueryCounter id target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glQueryCounter" [LogV'GLuint id, LogV'GLenum target]
#endif
    _result <- GL.glQueryCounter (coerce id) target
#ifdef GLW_DEBUG
    logGLCommandEnd "glQueryCounter" (LogV'Void)
#endif
    return _result

glQueryObjectParameteruiAMD :: MonadIO m => GL.GLenum -> Query (a :: QueryTarget) -> GL.GLenum -> OcclusionQueryEventMaskAMD -> m ()
glQueryObjectParameteruiAMD target id pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glQueryObjectParameteruiAMD" [LogV'GLenum target, LogV'GLuint id, LogV'GLenum pname, LogV'GLuint param]
#endif
    _result <- GL.glQueryObjectParameteruiAMD target (coerce id) pname (coerce param)
#ifdef GLW_DEBUG
    logGLCommandEnd "glQueryObjectParameteruiAMD" (LogV'Void)
#endif
    return _result

glReadBuffer :: MonadIO m => ReadBufferMode -> m ()
glReadBuffer src = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReadBuffer" [LogV'GLenum src]
#endif
    _result <- GL.glReadBuffer (coerce src)
#ifdef GLW_DEBUG
    logGLCommandEnd "glReadBuffer" (LogV'Void)
#endif
    return _result

glReadInstrumentsSGIX :: MonadIO m => GL.GLint -> m ()
glReadInstrumentsSGIX marker = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReadInstrumentsSGIX" [LogV'GLint marker]
#endif
    _result <- GL.glReadInstrumentsSGIX marker
#ifdef GLW_DEBUG
    logGLCommandEnd "glReadInstrumentsSGIX" (LogV'Void)
#endif
    return _result

glReadPixels :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glReadPixels x y width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReadPixels" [LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glReadPixels x y width height (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glReadPixels" (LogV'Void)
#endif
    return _result

glReadnPixels :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glReadnPixels x y width height format type' bufSize data' = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReadnPixels" [LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'GLsizei bufSize, LogV'Ptr]
#endif
    _result <- GL.glReadnPixels x y width height format type' bufSize data'
#ifdef GLW_DEBUG
    logGLCommandEnd "glReadnPixels" (LogV'Void)
#endif
    return _result

glReferencePlaneSGIX :: MonadIO m => Ptr GL.GLdouble -> m ()
glReferencePlaneSGIX equation = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReferencePlaneSGIX" [LogV'Ptr]
#endif
    _result <- GL.glReferencePlaneSGIX equation
#ifdef GLW_DEBUG
    logGLCommandEnd "glReferencePlaneSGIX" (LogV'Void)
#endif
    return _result

glReleaseShaderCompiler :: MonadIO m => m ()
glReleaseShaderCompiler  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReleaseShaderCompiler" []
#endif
    _result <- GL.glReleaseShaderCompiler 
#ifdef GLW_DEBUG
    logGLCommandEnd "glReleaseShaderCompiler" (LogV'Void)
#endif
    return _result

glRenderbufferStorage :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glRenderbufferStorage target internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRenderbufferStorage" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glRenderbufferStorage target internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glRenderbufferStorage" (LogV'Void)
#endif
    return _result

glRenderbufferStorageEXT :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glRenderbufferStorageEXT target internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRenderbufferStorageEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glRenderbufferStorageEXT target internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glRenderbufferStorageEXT" (LogV'Void)
#endif
    return _result

glRenderbufferStorageMultisample :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glRenderbufferStorageMultisample target samples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRenderbufferStorageMultisample" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glRenderbufferStorageMultisample target samples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glRenderbufferStorageMultisample" (LogV'Void)
#endif
    return _result

glRenderbufferStorageMultisampleCoverageNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glRenderbufferStorageMultisampleCoverageNV target coverageSamples colorSamples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRenderbufferStorageMultisampleCoverageNV" [LogV'GLenum target, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glRenderbufferStorageMultisampleCoverageNV target coverageSamples colorSamples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glRenderbufferStorageMultisampleCoverageNV" (LogV'Void)
#endif
    return _result

glRenderbufferStorageMultisampleEXT :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glRenderbufferStorageMultisampleEXT target samples internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRenderbufferStorageMultisampleEXT" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glRenderbufferStorageMultisampleEXT target samples internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glRenderbufferStorageMultisampleEXT" (LogV'Void)
#endif
    return _result

glReplacementCodePointerSUN :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr (Ptr ()) -> m ()
glReplacementCodePointerSUN type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodePointerSUN" [LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodePointerSUN type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodePointerSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeubSUN :: MonadIO m => GL.GLubyte -> m ()
glReplacementCodeubSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeubSUN" [LogV'GLubyte code]
#endif
    _result <- GL.glReplacementCodeubSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeubSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeubvSUN :: MonadIO m => Ptr GL.GLubyte -> m ()
glReplacementCodeubvSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeubvSUN" [LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeubvSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeubvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor3fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiColor3fVertex3fSUN rc r g b x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor3fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiColor3fVertex3fSUN rc r g b x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor3fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiColor3fVertex3fvSUN rc c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiColor3fVertex3fvSUN rc c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor4fNormal3fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiColor4fNormal3fVertex3fSUN rc r g b a nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor4fNormal3fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat a, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiColor4fNormal3fVertex3fSUN rc r g b a nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor4fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor4fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiColor4fNormal3fVertex3fvSUN rc c n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor4fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiColor4fNormal3fVertex3fvSUN rc c n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor4fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor4ubVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiColor4ubVertex3fSUN rc r g b a x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor4ubVertex3fSUN" [LogV'GLuint rc, LogV'GLubyte r, LogV'GLubyte g, LogV'GLubyte b, LogV'GLubyte a, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiColor4ubVertex3fSUN rc r g b a x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor4ubVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiColor4ubVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiColor4ubVertex3fvSUN rc c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiColor4ubVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiColor4ubVertex3fvSUN rc c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiColor4ubVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiNormal3fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiNormal3fVertex3fSUN rc nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiNormal3fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiNormal3fVertex3fSUN rc nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiNormal3fVertex3fvSUN rc n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiNormal3fVertex3fvSUN rc n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiSUN :: MonadIO m => GL.GLuint -> m ()
glReplacementCodeuiSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiSUN" [LogV'GLuint code]
#endif
    _result <- GL.glReplacementCodeuiSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN rc s t r g b a nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat a, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN rc s t r g b a nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN rc tc c n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN rc tc c n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN rc s t nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN rc s t nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN rc tc n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN rc tc n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fVertex3fSUN rc s t x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fVertex3fSUN rc s t x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiTexCoord2fVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiTexCoord2fVertex3fvSUN rc tc v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiTexCoord2fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiTexCoord2fVertex3fvSUN rc tc v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiTexCoord2fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiVertex3fSUN :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glReplacementCodeuiVertex3fSUN rc x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiVertex3fSUN" [LogV'GLuint rc, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glReplacementCodeuiVertex3fSUN rc x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiVertex3fSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuiVertex3fvSUN :: MonadIO m => Ptr GL.GLuint -> Ptr GL.GLfloat -> m ()
glReplacementCodeuiVertex3fvSUN rc v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuiVertex3fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuiVertex3fvSUN rc v
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuiVertex3fvSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeuivSUN :: MonadIO m => Ptr GL.GLuint -> m ()
glReplacementCodeuivSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeuivSUN" [LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeuivSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeuivSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeusSUN :: MonadIO m => GL.GLushort -> m ()
glReplacementCodeusSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeusSUN" [LogV'GLushort code]
#endif
    _result <- GL.glReplacementCodeusSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeusSUN" (LogV'Void)
#endif
    return _result

glReplacementCodeusvSUN :: MonadIO m => Ptr GL.GLushort -> m ()
glReplacementCodeusvSUN code = do
#ifdef GLW_DEBUG
    logGLCommandStart "glReplacementCodeusvSUN" [LogV'Ptr]
#endif
    _result <- GL.glReplacementCodeusvSUN code
#ifdef GLW_DEBUG
    logGLCommandEnd "glReplacementCodeusvSUN" (LogV'Void)
#endif
    return _result

glRequestResidentProgramsNV :: MonadIO m => GL.GLsizei -> Ptr Program -> m ()
glRequestResidentProgramsNV n programs = do
#ifdef GLW_DEBUG
    logGLCommandStart "glRequestResidentProgramsNV" [LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glRequestResidentProgramsNV n (coerce programs)
#ifdef GLW_DEBUG
    logGLCommandEnd "glRequestResidentProgramsNV" (LogV'Void)
#endif
    return _result

glResetHistogramEXT :: MonadIO m => HistogramTargetEXT -> m ()
glResetHistogramEXT target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glResetHistogramEXT" [LogV'GLenum target]
#endif
    _result <- GL.glResetHistogramEXT (coerce target)
#ifdef GLW_DEBUG
    logGLCommandEnd "glResetHistogramEXT" (LogV'Void)
#endif
    return _result

glResetMinmaxEXT :: MonadIO m => MinmaxTargetEXT -> m ()
glResetMinmaxEXT target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glResetMinmaxEXT" [LogV'GLenum target]
#endif
    _result <- GL.glResetMinmaxEXT (coerce target)
#ifdef GLW_DEBUG
    logGLCommandEnd "glResetMinmaxEXT" (LogV'Void)
#endif
    return _result

glResizeBuffersMESA :: MonadIO m => m ()
glResizeBuffersMESA  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glResizeBuffersMESA" []
#endif
    _result <- GL.glResizeBuffersMESA 
#ifdef GLW_DEBUG
    logGLCommandEnd "glResizeBuffersMESA" (LogV'Void)
#endif
    return _result

glResumeTransformFeedback :: MonadIO m => m ()
glResumeTransformFeedback  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glResumeTransformFeedback" []
#endif
    _result <- GL.glResumeTransformFeedback 
#ifdef GLW_DEBUG
    logGLCommandEnd "glResumeTransformFeedback" (LogV'Void)
#endif
    return _result

glResumeTransformFeedbackNV :: MonadIO m => m ()
glResumeTransformFeedbackNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glResumeTransformFeedbackNV" []
#endif
    _result <- GL.glResumeTransformFeedbackNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glResumeTransformFeedbackNV" (LogV'Void)
#endif
    return _result

glSampleCoverage :: MonadIO m => GL.GLfloat -> Boolean -> m ()
glSampleCoverage value invert = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleCoverage" [LogV'GLfloat value, LogV'GLboolean invert]
#endif
    _result <- GL.glSampleCoverage value (coerce invert)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleCoverage" (LogV'Void)
#endif
    return _result

glSampleCoverageARB :: MonadIO m => GL.GLfloat -> Boolean -> m ()
glSampleCoverageARB value invert = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleCoverageARB" [LogV'GLfloat value, LogV'GLboolean invert]
#endif
    _result <- GL.glSampleCoverageARB value (coerce invert)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleCoverageARB" (LogV'Void)
#endif
    return _result

glSampleMapATI :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> m ()
glSampleMapATI dst interp swizzle = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleMapATI" [LogV'GLuint dst, LogV'GLuint interp, LogV'GLenum swizzle]
#endif
    _result <- GL.glSampleMapATI dst interp swizzle
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleMapATI" (LogV'Void)
#endif
    return _result

glSampleMaskEXT :: MonadIO m => GL.GLclampf -> Boolean -> m ()
glSampleMaskEXT value invert = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleMaskEXT" [LogV'GLclampf value, LogV'GLboolean invert]
#endif
    _result <- GL.glSampleMaskEXT value (coerce invert)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleMaskEXT" (LogV'Void)
#endif
    return _result

glSampleMaskIndexedNV :: MonadIO m => GL.GLuint -> GL.GLbitfield -> m ()
glSampleMaskIndexedNV index mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleMaskIndexedNV" [LogV'GLuint index, LogV'GLbitfield mask]
#endif
    _result <- GL.glSampleMaskIndexedNV index mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleMaskIndexedNV" (LogV'Void)
#endif
    return _result

glSampleMaskSGIS :: MonadIO m => GL.GLclampf -> Boolean -> m ()
glSampleMaskSGIS value invert = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleMaskSGIS" [LogV'GLclampf value, LogV'GLboolean invert]
#endif
    _result <- GL.glSampleMaskSGIS value (coerce invert)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleMaskSGIS" (LogV'Void)
#endif
    return _result

glSampleMaski :: MonadIO m => GL.GLuint -> GL.GLbitfield -> m ()
glSampleMaski maskNumber mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSampleMaski" [LogV'GLuint maskNumber, LogV'GLbitfield mask]
#endif
    _result <- GL.glSampleMaski maskNumber mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glSampleMaski" (LogV'Void)
#endif
    return _result

glSamplePatternEXT :: MonadIO m => GL.GLenum -> m ()
glSamplePatternEXT pattern = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplePatternEXT" [LogV'GLenum pattern]
#endif
    _result <- GL.glSamplePatternEXT pattern
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplePatternEXT" (LogV'Void)
#endif
    return _result

glSamplePatternSGIS :: MonadIO m => SamplePatternSGIS -> m ()
glSamplePatternSGIS pattern = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplePatternSGIS" [LogV'GLenum pattern]
#endif
    _result <- GL.glSamplePatternSGIS (coerce pattern)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplePatternSGIS" (LogV'Void)
#endif
    return _result

glSamplerParameterIiv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLint -> m ()
glSamplerParameterIiv sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameterIiv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSamplerParameterIiv (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameterIiv" (LogV'Void)
#endif
    return _result

glSamplerParameterIuiv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLuint -> m ()
glSamplerParameterIuiv sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameterIuiv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSamplerParameterIuiv (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameterIuiv" (LogV'Void)
#endif
    return _result

glSamplerParameterf :: MonadIO m => Sampler -> GL.GLenum -> GL.GLfloat -> m ()
glSamplerParameterf sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameterf" [LogV'GLuint sampler, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glSamplerParameterf (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameterf" (LogV'Void)
#endif
    return _result

glSamplerParameterfv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glSamplerParameterfv sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameterfv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSamplerParameterfv (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameterfv" (LogV'Void)
#endif
    return _result

glSamplerParameteri :: MonadIO m => Sampler -> GL.GLenum -> GL.GLint -> m ()
glSamplerParameteri sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameteri" [LogV'GLuint sampler, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glSamplerParameteri (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameteri" (LogV'Void)
#endif
    return _result

glSamplerParameteriv :: MonadIO m => Sampler -> GL.GLenum -> Ptr GL.GLint -> m ()
glSamplerParameteriv sampler pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSamplerParameteriv" [LogV'GLuint sampler, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSamplerParameteriv (coerce sampler) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSamplerParameteriv" (LogV'Void)
#endif
    return _result

glScissor :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glScissor x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glScissor" [LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glScissor x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glScissor" (LogV'Void)
#endif
    return _result

glScissorArrayv :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLint -> m ()
glScissorArrayv first count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glScissorArrayv" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glScissorArrayv first count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glScissorArrayv" (LogV'Void)
#endif
    return _result

glScissorIndexed :: MonadIO m => GL.GLuint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glScissorIndexed index left bottom width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glScissorIndexed" [LogV'GLuint index, LogV'GLint left, LogV'GLint bottom, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glScissorIndexed index left bottom width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glScissorIndexed" (LogV'Void)
#endif
    return _result

glScissorIndexedv :: MonadIO m => GL.GLuint -> Ptr GL.GLint -> m ()
glScissorIndexedv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glScissorIndexedv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glScissorIndexedv index v
#ifdef GLW_DEBUG
    logGLCommandEnd "glScissorIndexedv" (LogV'Void)
#endif
    return _result

glSecondaryColor3bEXT :: MonadIO m => GL.GLbyte -> GL.GLbyte -> GL.GLbyte -> m ()
glSecondaryColor3bEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3bEXT" [LogV'GLbyte red, LogV'GLbyte green, LogV'GLbyte blue]
#endif
    _result <- GL.glSecondaryColor3bEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3bEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3bvEXT :: MonadIO m => Ptr GL.GLbyte -> m ()
glSecondaryColor3bvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3bvEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3bvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3bvEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3dEXT :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glSecondaryColor3dEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3dEXT" [LogV'GLdouble red, LogV'GLdouble green, LogV'GLdouble blue]
#endif
    _result <- GL.glSecondaryColor3dEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3dEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3dvEXT :: MonadIO m => Ptr GL.GLdouble -> m ()
glSecondaryColor3dvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3dvEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3dvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3dvEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3fEXT :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glSecondaryColor3fEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3fEXT" [LogV'GLfloat red, LogV'GLfloat green, LogV'GLfloat blue]
#endif
    _result <- GL.glSecondaryColor3fEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3fEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3fvEXT :: MonadIO m => Ptr GL.GLfloat -> m ()
glSecondaryColor3fvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3fvEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3fvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3fvEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glSecondaryColor3hNV red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3hNV" [LogV'GLhalfNV red, LogV'GLhalfNV green, LogV'GLhalfNV blue]
#endif
    _result <- GL.glSecondaryColor3hNV red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3hNV" (LogV'Void)
#endif
    return _result

glSecondaryColor3hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glSecondaryColor3hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3hvNV" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3hvNV" (LogV'Void)
#endif
    return _result

glSecondaryColor3iEXT :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> m ()
glSecondaryColor3iEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3iEXT" [LogV'GLint red, LogV'GLint green, LogV'GLint blue]
#endif
    _result <- GL.glSecondaryColor3iEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3iEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3ivEXT :: MonadIO m => Ptr GL.GLint -> m ()
glSecondaryColor3ivEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3ivEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3ivEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3ivEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3sEXT :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glSecondaryColor3sEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3sEXT" [LogV'GLshort red, LogV'GLshort green, LogV'GLshort blue]
#endif
    _result <- GL.glSecondaryColor3sEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3sEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3svEXT :: MonadIO m => Ptr GL.GLshort -> m ()
glSecondaryColor3svEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3svEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3svEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3svEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3ubEXT :: MonadIO m => GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> m ()
glSecondaryColor3ubEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3ubEXT" [LogV'GLubyte red, LogV'GLubyte green, LogV'GLubyte blue]
#endif
    _result <- GL.glSecondaryColor3ubEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3ubEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3ubvEXT :: MonadIO m => Ptr GL.GLubyte -> m ()
glSecondaryColor3ubvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3ubvEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3ubvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3ubvEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3uiEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glSecondaryColor3uiEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3uiEXT" [LogV'GLuint red, LogV'GLuint green, LogV'GLuint blue]
#endif
    _result <- GL.glSecondaryColor3uiEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3uiEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3uivEXT :: MonadIO m => Ptr GL.GLuint -> m ()
glSecondaryColor3uivEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3uivEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3uivEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3uivEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3usEXT :: MonadIO m => GL.GLushort -> GL.GLushort -> GL.GLushort -> m ()
glSecondaryColor3usEXT red green blue = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3usEXT" [LogV'GLushort red, LogV'GLushort green, LogV'GLushort blue]
#endif
    _result <- GL.glSecondaryColor3usEXT red green blue
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3usEXT" (LogV'Void)
#endif
    return _result

glSecondaryColor3usvEXT :: MonadIO m => Ptr GL.GLushort -> m ()
glSecondaryColor3usvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColor3usvEXT" [LogV'Ptr]
#endif
    _result <- GL.glSecondaryColor3usvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColor3usvEXT" (LogV'Void)
#endif
    return _result

glSecondaryColorFormatNV :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glSecondaryColorFormatNV size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColorFormatNV" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glSecondaryColorFormatNV size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColorFormatNV" (LogV'Void)
#endif
    return _result

glSecondaryColorP3ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glSecondaryColorP3ui type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColorP3ui" [LogV'GLenum type', LogV'GLuint color]
#endif
    _result <- GL.glSecondaryColorP3ui type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColorP3ui" (LogV'Void)
#endif
    return _result

glSecondaryColorP3uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glSecondaryColorP3uiv type' color = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColorP3uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glSecondaryColorP3uiv type' color
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColorP3uiv" (LogV'Void)
#endif
    return _result

glSecondaryColorPointerEXT :: MonadIO m => GL.GLint -> ColorPointerType -> GL.GLsizei -> Ptr () -> m ()
glSecondaryColorPointerEXT size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColorPointerEXT" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glSecondaryColorPointerEXT size (coerce type') stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColorPointerEXT" (LogV'Void)
#endif
    return _result

glSecondaryColorPointerListIBM :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glSecondaryColorPointerListIBM size type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSecondaryColorPointerListIBM" [LogV'GLint size, LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glSecondaryColorPointerListIBM size type' stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glSecondaryColorPointerListIBM" (LogV'Void)
#endif
    return _result

glSeparableFilter2DEXT :: MonadIO m => SeparableTargetEXT -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> Ptr () -> m ()
glSeparableFilter2DEXT target internalformat width height format type' row column = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSeparableFilter2DEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glSeparableFilter2DEXT (coerce target) internalformat width height (coerce format) (coerce type') row column
#ifdef GLW_DEBUG
    logGLCommandEnd "glSeparableFilter2DEXT" (LogV'Void)
#endif
    return _result

glSetFenceAPPLE :: MonadIO m => GL.GLuint -> m ()
glSetFenceAPPLE fence = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSetFenceAPPLE" [LogV'GLuint fence]
#endif
    _result <- GL.glSetFenceAPPLE fence
#ifdef GLW_DEBUG
    logGLCommandEnd "glSetFenceAPPLE" (LogV'Void)
#endif
    return _result

glSetFragmentShaderConstantATI :: MonadIO m => GL.GLuint -> Ptr GL.GLfloat -> m ()
glSetFragmentShaderConstantATI dst value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSetFragmentShaderConstantATI" [LogV'GLuint dst, LogV'Ptr]
#endif
    _result <- GL.glSetFragmentShaderConstantATI dst value
#ifdef GLW_DEBUG
    logGLCommandEnd "glSetFragmentShaderConstantATI" (LogV'Void)
#endif
    return _result

glSetInvariantEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr () -> m ()
glSetInvariantEXT id type' addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSetInvariantEXT" [LogV'GLuint id, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glSetInvariantEXT id type' addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glSetInvariantEXT" (LogV'Void)
#endif
    return _result

glSetLocalConstantEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> Ptr () -> m ()
glSetLocalConstantEXT id type' addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSetLocalConstantEXT" [LogV'GLuint id, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glSetLocalConstantEXT id type' addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glSetLocalConstantEXT" (LogV'Void)
#endif
    return _result

glSetMultisamplefvAMD :: MonadIO m => GL.GLenum -> GL.GLuint -> Ptr GL.GLfloat -> m ()
glSetMultisamplefvAMD pname index val = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSetMultisamplefvAMD" [LogV'GLenum pname, LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glSetMultisamplefvAMD pname index val
#ifdef GLW_DEBUG
    logGLCommandEnd "glSetMultisamplefvAMD" (LogV'Void)
#endif
    return _result

glShaderBinary :: MonadIO m => GL.GLsizei -> Ptr (Shader (a :: ShaderType)) -> GL.GLenum -> Ptr () -> GL.GLsizei -> m ()
glShaderBinary count shaders binaryformat binary length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderBinary" [LogV'GLsizei count, LogV'Ptr, LogV'GLenum binaryformat, LogV'Ptr, LogV'GLsizei length]
#endif
    _result <- GL.glShaderBinary count (coerce shaders) binaryformat binary length
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderBinary" (LogV'Void)
#endif
    return _result

glShaderOp1EXT :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> m ()
glShaderOp1EXT op res arg1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderOp1EXT" [LogV'GLenum op, LogV'GLuint res, LogV'GLuint arg1]
#endif
    _result <- GL.glShaderOp1EXT op res arg1
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderOp1EXT" (LogV'Void)
#endif
    return _result

glShaderOp2EXT :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glShaderOp2EXT op res arg1 arg2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderOp2EXT" [LogV'GLenum op, LogV'GLuint res, LogV'GLuint arg1, LogV'GLuint arg2]
#endif
    _result <- GL.glShaderOp2EXT op res arg1 arg2
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderOp2EXT" (LogV'Void)
#endif
    return _result

glShaderOp3EXT :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glShaderOp3EXT op res arg1 arg2 arg3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderOp3EXT" [LogV'GLenum op, LogV'GLuint res, LogV'GLuint arg1, LogV'GLuint arg2, LogV'GLuint arg3]
#endif
    _result <- GL.glShaderOp3EXT op res arg1 arg2 arg3
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderOp3EXT" (LogV'Void)
#endif
    return _result

glShaderSource :: MonadIO m => Shader (a :: ShaderType) -> GL.GLsizei -> Ptr (Ptr GL.GLchar) -> Ptr GL.GLint -> m ()
glShaderSource shader count string length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderSource" [LogV'GLuint shader, LogV'GLsizei count, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glShaderSource (coerce shader) count string length
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderSource" (LogV'Void)
#endif
    return _result

glShaderSourceARB :: MonadIO m => GL.GLhandleARB -> GL.GLsizei -> Ptr (Ptr GL.GLcharARB) -> Ptr GL.GLint -> m ()
glShaderSourceARB shaderObj count string length = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderSourceARB" [LogV'GLhandleARB shaderObj, LogV'GLsizei count, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glShaderSourceARB shaderObj count string length
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderSourceARB" (LogV'Void)
#endif
    return _result

glShaderStorageBlockBinding :: MonadIO m => Program -> GL.GLuint -> GL.GLuint -> m ()
glShaderStorageBlockBinding program storageBlockIndex storageBlockBinding = do
#ifdef GLW_DEBUG
    logGLCommandStart "glShaderStorageBlockBinding" [LogV'GLuint program, LogV'GLuint storageBlockIndex, LogV'GLuint storageBlockBinding]
#endif
    _result <- GL.glShaderStorageBlockBinding (coerce program) storageBlockIndex storageBlockBinding
#ifdef GLW_DEBUG
    logGLCommandEnd "glShaderStorageBlockBinding" (LogV'Void)
#endif
    return _result

glSharpenTexFuncSGIS :: MonadIO m => TextureTarget -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glSharpenTexFuncSGIS target n points = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSharpenTexFuncSGIS" [LogV'GLenum target, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glSharpenTexFuncSGIS (coerce target) n points
#ifdef GLW_DEBUG
    logGLCommandEnd "glSharpenTexFuncSGIS" (LogV'Void)
#endif
    return _result

glSpriteParameterfSGIX :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glSpriteParameterfSGIX pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSpriteParameterfSGIX" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glSpriteParameterfSGIX pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSpriteParameterfSGIX" (LogV'Void)
#endif
    return _result

glSpriteParameterfvSGIX :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glSpriteParameterfvSGIX pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSpriteParameterfvSGIX" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSpriteParameterfvSGIX pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glSpriteParameterfvSGIX" (LogV'Void)
#endif
    return _result

glSpriteParameteriSGIX :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glSpriteParameteriSGIX pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSpriteParameteriSGIX" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glSpriteParameteriSGIX pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glSpriteParameteriSGIX" (LogV'Void)
#endif
    return _result

glSpriteParameterivSGIX :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glSpriteParameterivSGIX pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSpriteParameterivSGIX" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glSpriteParameterivSGIX pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glSpriteParameterivSGIX" (LogV'Void)
#endif
    return _result

glStartInstrumentsSGIX :: MonadIO m => m ()
glStartInstrumentsSGIX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStartInstrumentsSGIX" []
#endif
    _result <- GL.glStartInstrumentsSGIX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glStartInstrumentsSGIX" (LogV'Void)
#endif
    return _result

glStateCaptureNV :: MonadIO m => GL.GLuint -> GL.GLenum -> m ()
glStateCaptureNV state mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStateCaptureNV" [LogV'GLuint state, LogV'GLenum mode]
#endif
    _result <- GL.glStateCaptureNV state mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glStateCaptureNV" (LogV'Void)
#endif
    return _result

glStencilClearTagEXT :: MonadIO m => GL.GLsizei -> GL.GLuint -> m ()
glStencilClearTagEXT stencilTagBits stencilClearTag = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilClearTagEXT" [LogV'GLsizei stencilTagBits, LogV'GLuint stencilClearTag]
#endif
    _result <- GL.glStencilClearTagEXT stencilTagBits stencilClearTag
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilClearTagEXT" (LogV'Void)
#endif
    return _result

glStencilFunc :: MonadIO m => StencilFunction -> GL.GLint -> GL.GLuint -> m ()
glStencilFunc func ref mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilFunc" [LogV'GLenum func, LogV'GLint ref, LogV'GLuint mask]
#endif
    _result <- GL.glStencilFunc (coerce func) ref mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilFunc" (LogV'Void)
#endif
    return _result

glStencilFuncSeparate :: MonadIO m => GL.GLenum -> StencilFunction -> GL.GLint -> GL.GLuint -> m ()
glStencilFuncSeparate face func ref mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilFuncSeparate" [LogV'GLenum face, LogV'GLenum func, LogV'GLint ref, LogV'GLuint mask]
#endif
    _result <- GL.glStencilFuncSeparate face (coerce func) ref mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilFuncSeparate" (LogV'Void)
#endif
    return _result

glStencilFuncSeparateATI :: MonadIO m => StencilFunction -> StencilFunction -> GL.GLint -> GL.GLuint -> m ()
glStencilFuncSeparateATI frontfunc backfunc ref mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilFuncSeparateATI" [LogV'GLenum frontfunc, LogV'GLenum backfunc, LogV'GLint ref, LogV'GLuint mask]
#endif
    _result <- GL.glStencilFuncSeparateATI (coerce frontfunc) (coerce backfunc) ref mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilFuncSeparateATI" (LogV'Void)
#endif
    return _result

glStencilMask :: MonadIO m => GL.GLuint -> m ()
glStencilMask mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilMask" [LogV'GLuint mask]
#endif
    _result <- GL.glStencilMask mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilMask" (LogV'Void)
#endif
    return _result

glStencilMaskSeparate :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glStencilMaskSeparate face mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilMaskSeparate" [LogV'GLenum face, LogV'GLuint mask]
#endif
    _result <- GL.glStencilMaskSeparate face mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilMaskSeparate" (LogV'Void)
#endif
    return _result

glStencilOp :: MonadIO m => StencilOp -> StencilOp -> StencilOp -> m ()
glStencilOp fail zfail zpass = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilOp" [LogV'GLenum fail, LogV'GLenum zfail, LogV'GLenum zpass]
#endif
    _result <- GL.glStencilOp (coerce fail) (coerce zfail) (coerce zpass)
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilOp" (LogV'Void)
#endif
    return _result

glStencilOpSeparate :: MonadIO m => GL.GLenum -> StencilOp -> StencilOp -> StencilOp -> m ()
glStencilOpSeparate face sfail dpfail dppass = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilOpSeparate" [LogV'GLenum face, LogV'GLenum sfail, LogV'GLenum dpfail, LogV'GLenum dppass]
#endif
    _result <- GL.glStencilOpSeparate face (coerce sfail) (coerce dpfail) (coerce dppass)
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilOpSeparate" (LogV'Void)
#endif
    return _result

glStencilOpSeparateATI :: MonadIO m => GL.GLenum -> StencilOp -> StencilOp -> StencilOp -> m ()
glStencilOpSeparateATI face sfail dpfail dppass = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilOpSeparateATI" [LogV'GLenum face, LogV'GLenum sfail, LogV'GLenum dpfail, LogV'GLenum dppass]
#endif
    _result <- GL.glStencilOpSeparateATI face (coerce sfail) (coerce dpfail) (coerce dppass)
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilOpSeparateATI" (LogV'Void)
#endif
    return _result

glStencilOpValueAMD :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glStencilOpValueAMD face value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStencilOpValueAMD" [LogV'GLenum face, LogV'GLuint value]
#endif
    _result <- GL.glStencilOpValueAMD face value
#ifdef GLW_DEBUG
    logGLCommandEnd "glStencilOpValueAMD" (LogV'Void)
#endif
    return _result

glStopInstrumentsSGIX :: MonadIO m => GL.GLint -> m ()
glStopInstrumentsSGIX marker = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStopInstrumentsSGIX" [LogV'GLint marker]
#endif
    _result <- GL.glStopInstrumentsSGIX marker
#ifdef GLW_DEBUG
    logGLCommandEnd "glStopInstrumentsSGIX" (LogV'Void)
#endif
    return _result

glStringMarkerGREMEDY :: MonadIO m => GL.GLsizei -> Ptr () -> m ()
glStringMarkerGREMEDY len string = do
#ifdef GLW_DEBUG
    logGLCommandStart "glStringMarkerGREMEDY" [LogV'GLsizei len, LogV'Ptr]
#endif
    _result <- GL.glStringMarkerGREMEDY len string
#ifdef GLW_DEBUG
    logGLCommandEnd "glStringMarkerGREMEDY" (LogV'Void)
#endif
    return _result

glSwizzleEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glSwizzleEXT res in' outX outY outZ outW = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSwizzleEXT" [LogV'GLuint res, LogV'GLuint in', LogV'GLenum outX, LogV'GLenum outY, LogV'GLenum outZ, LogV'GLenum outW]
#endif
    _result <- GL.glSwizzleEXT res in' outX outY outZ outW
#ifdef GLW_DEBUG
    logGLCommandEnd "glSwizzleEXT" (LogV'Void)
#endif
    return _result

glSyncTextureINTEL :: MonadIO m => Texture (a :: TextureTarget') -> m ()
glSyncTextureINTEL texture = do
#ifdef GLW_DEBUG
    logGLCommandStart "glSyncTextureINTEL" [LogV'GLuint texture]
#endif
    _result <- GL.glSyncTextureINTEL (coerce texture)
#ifdef GLW_DEBUG
    logGLCommandEnd "glSyncTextureINTEL" (LogV'Void)
#endif
    return _result

glTagSampleBufferSGIX :: MonadIO m => m ()
glTagSampleBufferSGIX  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTagSampleBufferSGIX" []
#endif
    _result <- GL.glTagSampleBufferSGIX 
#ifdef GLW_DEBUG
    logGLCommandEnd "glTagSampleBufferSGIX" (LogV'Void)
#endif
    return _result

glTangent3bEXT :: MonadIO m => GL.GLbyte -> GL.GLbyte -> GL.GLbyte -> m ()
glTangent3bEXT tx ty tz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3bEXT" [LogV'GLbyte tx, LogV'GLbyte ty, LogV'GLbyte tz]
#endif
    _result <- GL.glTangent3bEXT tx ty tz
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3bEXT" (LogV'Void)
#endif
    return _result

glTangent3bvEXT :: MonadIO m => Ptr GL.GLbyte -> m ()
glTangent3bvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3bvEXT" [LogV'Ptr]
#endif
    _result <- GL.glTangent3bvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3bvEXT" (LogV'Void)
#endif
    return _result

glTangent3dEXT :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glTangent3dEXT tx ty tz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3dEXT" [LogV'GLdouble tx, LogV'GLdouble ty, LogV'GLdouble tz]
#endif
    _result <- GL.glTangent3dEXT tx ty tz
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3dEXT" (LogV'Void)
#endif
    return _result

glTangent3dvEXT :: MonadIO m => Ptr GL.GLdouble -> m ()
glTangent3dvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3dvEXT" [LogV'Ptr]
#endif
    _result <- GL.glTangent3dvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3dvEXT" (LogV'Void)
#endif
    return _result

glTangent3fEXT :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTangent3fEXT tx ty tz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3fEXT" [LogV'GLfloat tx, LogV'GLfloat ty, LogV'GLfloat tz]
#endif
    _result <- GL.glTangent3fEXT tx ty tz
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3fEXT" (LogV'Void)
#endif
    return _result

glTangent3fvEXT :: MonadIO m => Ptr GL.GLfloat -> m ()
glTangent3fvEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3fvEXT" [LogV'Ptr]
#endif
    _result <- GL.glTangent3fvEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3fvEXT" (LogV'Void)
#endif
    return _result

glTangent3iEXT :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> m ()
glTangent3iEXT tx ty tz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3iEXT" [LogV'GLint tx, LogV'GLint ty, LogV'GLint tz]
#endif
    _result <- GL.glTangent3iEXT tx ty tz
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3iEXT" (LogV'Void)
#endif
    return _result

glTangent3ivEXT :: MonadIO m => Ptr GL.GLint -> m ()
glTangent3ivEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3ivEXT" [LogV'Ptr]
#endif
    _result <- GL.glTangent3ivEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3ivEXT" (LogV'Void)
#endif
    return _result

glTangent3sEXT :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glTangent3sEXT tx ty tz = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3sEXT" [LogV'GLshort tx, LogV'GLshort ty, LogV'GLshort tz]
#endif
    _result <- GL.glTangent3sEXT tx ty tz
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3sEXT" (LogV'Void)
#endif
    return _result

glTangent3svEXT :: MonadIO m => Ptr GL.GLshort -> m ()
glTangent3svEXT v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangent3svEXT" [LogV'Ptr]
#endif
    _result <- GL.glTangent3svEXT v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangent3svEXT" (LogV'Void)
#endif
    return _result

glTangentPointerEXT :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glTangentPointerEXT type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTangentPointerEXT" [LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glTangentPointerEXT type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glTangentPointerEXT" (LogV'Void)
#endif
    return _result

glTbufferMask3DFX :: MonadIO m => GL.GLuint -> m ()
glTbufferMask3DFX mask = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTbufferMask3DFX" [LogV'GLuint mask]
#endif
    _result <- GL.glTbufferMask3DFX mask
#ifdef GLW_DEBUG
    logGLCommandEnd "glTbufferMask3DFX" (LogV'Void)
#endif
    return _result

glTessellationFactorAMD :: MonadIO m => GL.GLfloat -> m ()
glTessellationFactorAMD factor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTessellationFactorAMD" [LogV'GLfloat factor]
#endif
    _result <- GL.glTessellationFactorAMD factor
#ifdef GLW_DEBUG
    logGLCommandEnd "glTessellationFactorAMD" (LogV'Void)
#endif
    return _result

glTessellationModeAMD :: MonadIO m => GL.GLenum -> m ()
glTessellationModeAMD mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTessellationModeAMD" [LogV'GLenum mode]
#endif
    _result <- GL.glTessellationModeAMD mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTessellationModeAMD" (LogV'Void)
#endif
    return _result

glTestFenceAPPLE :: MonadIO m => GL.GLuint -> m Boolean
glTestFenceAPPLE fence = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTestFenceAPPLE" [LogV'GLuint fence]
#endif
    _result <- coerce <$> GL.glTestFenceAPPLE fence
#ifdef GLW_DEBUG
    logGLCommandEnd "glTestFenceAPPLE" (LogV'GLboolean _result)
#endif
    return _result

glTestObjectAPPLE :: MonadIO m => GL.GLenum -> GL.GLuint -> m Boolean
glTestObjectAPPLE object name = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTestObjectAPPLE" [LogV'GLenum object, LogV'GLuint name]
#endif
    _result <- coerce <$> GL.glTestObjectAPPLE object name
#ifdef GLW_DEBUG
    logGLCommandEnd "glTestObjectAPPLE" (LogV'GLboolean _result)
#endif
    return _result

glTexBuffer :: MonadIO m => TextureTarget -> GL.GLenum -> Buffer -> m ()
glTexBuffer target internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBuffer" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glTexBuffer (coerce target) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBuffer" (LogV'Void)
#endif
    return _result

glTexBufferARB :: MonadIO m => TextureTarget -> GL.GLenum -> Buffer -> m ()
glTexBufferARB target internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBufferARB" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glTexBufferARB (coerce target) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBufferARB" (LogV'Void)
#endif
    return _result

glTexBufferEXT :: MonadIO m => TextureTarget -> GL.GLenum -> Buffer -> m ()
glTexBufferEXT target internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBufferEXT" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glTexBufferEXT (coerce target) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBufferEXT" (LogV'Void)
#endif
    return _result

glTexBufferRange :: MonadIO m => GL.GLenum -> GL.GLenum -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glTexBufferRange target internalformat buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBufferRange" [LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glTexBufferRange target internalformat (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBufferRange" (LogV'Void)
#endif
    return _result

glTexBumpParameterfvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glTexBumpParameterfvATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBumpParameterfvATI" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexBumpParameterfvATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBumpParameterfvATI" (LogV'Void)
#endif
    return _result

glTexBumpParameterivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glTexBumpParameterivATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexBumpParameterivATI" [LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexBumpParameterivATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexBumpParameterivATI" (LogV'Void)
#endif
    return _result

glTexCoord1hNV :: MonadIO m => GL.GLhalfNV -> m ()
glTexCoord1hNV s = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord1hNV" [LogV'GLhalfNV s]
#endif
    _result <- GL.glTexCoord1hNV s
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord1hNV" (LogV'Void)
#endif
    return _result

glTexCoord1hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glTexCoord1hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord1hvNV" [LogV'Ptr]
#endif
    _result <- GL.glTexCoord1hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord1hvNV" (LogV'Void)
#endif
    return _result

glTexCoord2fColor3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord2fColor3fVertex3fSUN s t r g b x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor3fVertex3fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glTexCoord2fColor3fVertex3fSUN s t r g b x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fColor3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord2fColor3fVertex3fvSUN tc c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord2fColor3fVertex3fvSUN tc c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fColor4fNormal3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord2fColor4fNormal3fVertex3fSUN s t r g b a nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor4fNormal3fVertex3fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat a, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glTexCoord2fColor4fNormal3fVertex3fSUN s t r g b a nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor4fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fColor4fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord2fColor4fNormal3fVertex3fvSUN tc c n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor4fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord2fColor4fNormal3fVertex3fvSUN tc c n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor4fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fColor4ubVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord2fColor4ubVertex3fSUN s t r g b a x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor4ubVertex3fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLubyte r, LogV'GLubyte g, LogV'GLubyte b, LogV'GLubyte a, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glTexCoord2fColor4ubVertex3fSUN s t r g b a x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor4ubVertex3fSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fColor4ubVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLubyte -> Ptr GL.GLfloat -> m ()
glTexCoord2fColor4ubVertex3fvSUN tc c v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fColor4ubVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord2fColor4ubVertex3fvSUN tc c v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fColor4ubVertex3fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fNormal3fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord2fNormal3fVertex3fSUN s t nx ny nz x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fNormal3fVertex3fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glTexCoord2fNormal3fVertex3fSUN s t nx ny nz x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fNormal3fVertex3fSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fNormal3fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord2fNormal3fVertex3fvSUN tc n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fNormal3fVertex3fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord2fNormal3fVertex3fvSUN tc n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fNormal3fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fVertex3fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord2fVertex3fSUN s t x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fVertex3fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glTexCoord2fVertex3fSUN s t x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fVertex3fSUN" (LogV'Void)
#endif
    return _result

glTexCoord2fVertex3fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord2fVertex3fvSUN tc v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2fVertex3fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord2fVertex3fvSUN tc v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2fVertex3fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord2hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> m ()
glTexCoord2hNV s t = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2hNV" [LogV'GLhalfNV s, LogV'GLhalfNV t]
#endif
    _result <- GL.glTexCoord2hNV s t
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2hNV" (LogV'Void)
#endif
    return _result

glTexCoord2hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glTexCoord2hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord2hvNV" [LogV'Ptr]
#endif
    _result <- GL.glTexCoord2hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord2hvNV" (LogV'Void)
#endif
    return _result

glTexCoord3hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glTexCoord3hNV s t r = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord3hNV" [LogV'GLhalfNV s, LogV'GLhalfNV t, LogV'GLhalfNV r]
#endif
    _result <- GL.glTexCoord3hNV s t r
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord3hNV" (LogV'Void)
#endif
    return _result

glTexCoord3hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glTexCoord3hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord3hvNV" [LogV'Ptr]
#endif
    _result <- GL.glTexCoord3hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord3hvNV" (LogV'Void)
#endif
    return _result

glTexCoord4fColor4fNormal3fVertex4fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord4fColor4fNormal3fVertex4fSUN s t p q r g b a nx ny nz x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4fColor4fNormal3fVertex4fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat p, LogV'GLfloat q, LogV'GLfloat r, LogV'GLfloat g, LogV'GLfloat b, LogV'GLfloat a, LogV'GLfloat nx, LogV'GLfloat ny, LogV'GLfloat nz, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glTexCoord4fColor4fNormal3fVertex4fSUN s t p q r g b a nx ny nz x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4fColor4fNormal3fVertex4fSUN" (LogV'Void)
#endif
    return _result

glTexCoord4fColor4fNormal3fVertex4fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord4fColor4fNormal3fVertex4fvSUN tc c n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4fColor4fNormal3fVertex4fvSUN" [LogV'Ptr, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord4fColor4fNormal3fVertex4fvSUN tc c n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4fColor4fNormal3fVertex4fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord4fVertex4fSUN :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glTexCoord4fVertex4fSUN s t p q x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4fVertex4fSUN" [LogV'GLfloat s, LogV'GLfloat t, LogV'GLfloat p, LogV'GLfloat q, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glTexCoord4fVertex4fSUN s t p q x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4fVertex4fSUN" (LogV'Void)
#endif
    return _result

glTexCoord4fVertex4fvSUN :: MonadIO m => Ptr GL.GLfloat -> Ptr GL.GLfloat -> m ()
glTexCoord4fVertex4fvSUN tc v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4fVertex4fvSUN" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glTexCoord4fVertex4fvSUN tc v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4fVertex4fvSUN" (LogV'Void)
#endif
    return _result

glTexCoord4hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glTexCoord4hNV s t r q = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4hNV" [LogV'GLhalfNV s, LogV'GLhalfNV t, LogV'GLhalfNV r, LogV'GLhalfNV q]
#endif
    _result <- GL.glTexCoord4hNV s t r q
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4hNV" (LogV'Void)
#endif
    return _result

glTexCoord4hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glTexCoord4hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoord4hvNV" [LogV'Ptr]
#endif
    _result <- GL.glTexCoord4hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoord4hvNV" (LogV'Void)
#endif
    return _result

glTexCoordFormatNV :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glTexCoordFormatNV size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordFormatNV" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glTexCoordFormatNV size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordFormatNV" (LogV'Void)
#endif
    return _result

glTexCoordP1ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glTexCoordP1ui type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP1ui" [LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glTexCoordP1ui type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP1ui" (LogV'Void)
#endif
    return _result

glTexCoordP1uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glTexCoordP1uiv type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP1uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexCoordP1uiv type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP1uiv" (LogV'Void)
#endif
    return _result

glTexCoordP2ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glTexCoordP2ui type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP2ui" [LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glTexCoordP2ui type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP2ui" (LogV'Void)
#endif
    return _result

glTexCoordP2uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glTexCoordP2uiv type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP2uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexCoordP2uiv type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP2uiv" (LogV'Void)
#endif
    return _result

glTexCoordP3ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glTexCoordP3ui type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP3ui" [LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glTexCoordP3ui type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP3ui" (LogV'Void)
#endif
    return _result

glTexCoordP3uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glTexCoordP3uiv type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP3uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexCoordP3uiv type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP3uiv" (LogV'Void)
#endif
    return _result

glTexCoordP4ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glTexCoordP4ui type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP4ui" [LogV'GLenum type', LogV'GLuint coords]
#endif
    _result <- GL.glTexCoordP4ui type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP4ui" (LogV'Void)
#endif
    return _result

glTexCoordP4uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glTexCoordP4uiv type' coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordP4uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexCoordP4uiv type' coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordP4uiv" (LogV'Void)
#endif
    return _result

glTexCoordPointerEXT :: MonadIO m => GL.GLint -> TexCoordPointerType -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glTexCoordPointerEXT size type' stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordPointerEXT" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glTexCoordPointerEXT size (coerce type') stride count pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordPointerEXT" (LogV'Void)
#endif
    return _result

glTexCoordPointerListIBM :: MonadIO m => GL.GLint -> TexCoordPointerType -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glTexCoordPointerListIBM size type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordPointerListIBM" [LogV'GLint size, LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glTexCoordPointerListIBM size (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordPointerListIBM" (LogV'Void)
#endif
    return _result

glTexCoordPointervINTEL :: MonadIO m => GL.GLint -> VertexPointerType -> Ptr (Ptr ()) -> m ()
glTexCoordPointervINTEL size type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexCoordPointervINTEL" [LogV'GLint size, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexCoordPointervINTEL size (coerce type') pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexCoordPointervINTEL" (LogV'Void)
#endif
    return _result

glTexFilterFuncSGIS :: MonadIO m => TextureTarget -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glTexFilterFuncSGIS target filter n weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexFilterFuncSGIS" [LogV'GLenum target, LogV'GLenum filter, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glTexFilterFuncSGIS (coerce target) filter n weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexFilterFuncSGIS" (LogV'Void)
#endif
    return _result

glTexImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexImage1D target level internalformat width border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexImage1D (coerce target) level internalformat width border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage1D" (LogV'Void)
#endif
    return _result

glTexImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexImage2D target level internalformat width height border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexImage2D (coerce target) level internalformat width height border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage2D" (LogV'Void)
#endif
    return _result

glTexImage2DMultisample :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexImage2DMultisample target samples internalformat width height fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage2DMultisample" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTexImage2DMultisample target samples internalformat width height (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage2DMultisample" (LogV'Void)
#endif
    return _result

glTexImage2DMultisampleCoverageNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexImage2DMultisampleCoverageNV target coverageSamples colorSamples internalFormat width height fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage2DMultisampleCoverageNV" [LogV'GLenum target, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTexImage2DMultisampleCoverageNV target coverageSamples colorSamples internalFormat width height (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage2DMultisampleCoverageNV" (LogV'Void)
#endif
    return _result

glTexImage3D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexImage3D target level internalformat width height depth border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage3D" [LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexImage3D (coerce target) level internalformat width height depth border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage3D" (LogV'Void)
#endif
    return _result

glTexImage3DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexImage3DEXT target level internalformat width height depth border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage3DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexImage3DEXT (coerce target) level internalformat width height depth border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage3DEXT" (LogV'Void)
#endif
    return _result

glTexImage3DMultisample :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexImage3DMultisample target samples internalformat width height depth fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage3DMultisample" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTexImage3DMultisample target samples internalformat width height depth (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage3DMultisample" (LogV'Void)
#endif
    return _result

glTexImage3DMultisampleCoverageNV :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexImage3DMultisampleCoverageNV target coverageSamples colorSamples internalFormat width height depth fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage3DMultisampleCoverageNV" [LogV'GLenum target, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTexImage3DMultisampleCoverageNV target coverageSamples colorSamples internalFormat width height depth (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage3DMultisampleCoverageNV" (LogV'Void)
#endif
    return _result

glTexImage4DSGIS :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexImage4DSGIS target level internalformat width height depth size4d border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexImage4DSGIS" [LogV'GLenum target, LogV'GLint level, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLsizei size4d, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexImage4DSGIS (coerce target) level internalformat width height depth size4d border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexImage4DSGIS" (LogV'Void)
#endif
    return _result

glTexParameterIiv :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glTexParameterIiv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterIiv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameterIiv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterIiv" (LogV'Void)
#endif
    return _result

glTexParameterIivEXT :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glTexParameterIivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterIivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameterIivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterIivEXT" (LogV'Void)
#endif
    return _result

glTexParameterIuiv :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLuint -> m ()
glTexParameterIuiv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterIuiv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameterIuiv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterIuiv" (LogV'Void)
#endif
    return _result

glTexParameterIuivEXT :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLuint -> m ()
glTexParameterIuivEXT target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterIuivEXT" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameterIuivEXT (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterIuivEXT" (LogV'Void)
#endif
    return _result

glTexParameterf :: MonadIO m => TextureTarget -> TextureParameterName -> GL.GLfloat -> m ()
glTexParameterf target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterf" [LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glTexParameterf (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterf" (LogV'Void)
#endif
    return _result

glTexParameterfv :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLfloat -> m ()
glTexParameterfv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameterfv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameterfv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameterfv" (LogV'Void)
#endif
    return _result

glTexParameteri :: MonadIO m => TextureTarget -> TextureParameterName -> GL.GLint -> m ()
glTexParameteri target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameteri" [LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glTexParameteri (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameteri" (LogV'Void)
#endif
    return _result

glTexParameteriv :: MonadIO m => TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glTexParameteriv target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexParameteriv" [LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTexParameteriv (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexParameteriv" (LogV'Void)
#endif
    return _result

glTexRenderbufferNV :: MonadIO m => TextureTarget -> Renderbuffer -> m ()
glTexRenderbufferNV target renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexRenderbufferNV" [LogV'GLenum target, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glTexRenderbufferNV (coerce target) (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexRenderbufferNV" (LogV'Void)
#endif
    return _result

glTexStorage1D :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> m ()
glTexStorage1D target levels internalformat width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorage1D" [LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width]
#endif
    _result <- GL.glTexStorage1D target levels internalformat width
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorage1D" (LogV'Void)
#endif
    return _result

glTexStorage2D :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glTexStorage2D target levels internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorage2D" [LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glTexStorage2D target levels internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorage2D" (LogV'Void)
#endif
    return _result

glTexStorage2DMultisample :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexStorage2DMultisample target samples internalformat width height fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorage2DMultisample" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTexStorage2DMultisample target samples internalformat width height (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorage2DMultisample" (LogV'Void)
#endif
    return _result

glTexStorage3D :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glTexStorage3D target levels internalformat width height depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorage3D" [LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth]
#endif
    _result <- GL.glTexStorage3D target levels internalformat width height depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorage3D" (LogV'Void)
#endif
    return _result

glTexStorage3DMultisample :: MonadIO m => GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTexStorage3DMultisample target samples internalformat width height depth fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorage3DMultisample" [LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTexStorage3DMultisample target samples internalformat width height depth (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorage3DMultisample" (LogV'Void)
#endif
    return _result

glTexStorageSparseAMD :: MonadIO m => GL.GLenum -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLbitfield -> m ()
glTexStorageSparseAMD target internalFormat width height depth layers flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexStorageSparseAMD" [LogV'GLenum target, LogV'GLenum internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLsizei layers, LogV'GLbitfield flags]
#endif
    _result <- GL.glTexStorageSparseAMD target internalFormat width height depth layers flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexStorageSparseAMD" (LogV'Void)
#endif
    return _result

glTexSubImage1D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage1D target level xoffset width format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage1D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage1D (coerce target) level xoffset width (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage1D" (LogV'Void)
#endif
    return _result

glTexSubImage1DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage1DEXT target level xoffset width format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage1DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage1DEXT (coerce target) level xoffset width (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage1DEXT" (LogV'Void)
#endif
    return _result

glTexSubImage2D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage2D target level xoffset yoffset width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage2D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage2D (coerce target) level xoffset yoffset width height (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage2D" (LogV'Void)
#endif
    return _result

glTexSubImage2DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage2DEXT target level xoffset yoffset width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage2DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage2DEXT (coerce target) level xoffset yoffset width height (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage2DEXT" (LogV'Void)
#endif
    return _result

glTexSubImage3D :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage3D target level xoffset yoffset zoffset width height depth format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage3D" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage3D (coerce target) level xoffset yoffset zoffset width height depth (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage3D" (LogV'Void)
#endif
    return _result

glTexSubImage3DEXT :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage3DEXT target level xoffset yoffset zoffset width height depth format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage3DEXT" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage3DEXT (coerce target) level xoffset yoffset zoffset width height depth (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage3DEXT" (LogV'Void)
#endif
    return _result

glTexSubImage4DSGIS :: MonadIO m => TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTexSubImage4DSGIS target level xoffset yoffset zoffset woffset width height depth size4d format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexSubImage4DSGIS" [LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLint woffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLsizei size4d, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTexSubImage4DSGIS (coerce target) level xoffset yoffset zoffset woffset width height depth size4d (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexSubImage4DSGIS" (LogV'Void)
#endif
    return _result

glTextureBarrier :: MonadIO m => m ()
glTextureBarrier  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBarrier" []
#endif
    _result <- GL.glTextureBarrier 
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBarrier" (LogV'Void)
#endif
    return _result

glTextureBarrierNV :: MonadIO m => m ()
glTextureBarrierNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBarrierNV" []
#endif
    _result <- GL.glTextureBarrierNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBarrierNV" (LogV'Void)
#endif
    return _result

glTextureBuffer :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Buffer -> m ()
glTextureBuffer texture internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBuffer" [LogV'GLuint texture, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glTextureBuffer (coerce texture) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBuffer" (LogV'Void)
#endif
    return _result

glTextureBufferEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLenum -> Buffer -> m ()
glTextureBufferEXT texture target internalformat buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBufferEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer]
#endif
    _result <- GL.glTextureBufferEXT (coerce texture) (coerce target) internalformat (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBufferEXT" (LogV'Void)
#endif
    return _result

glTextureBufferRange :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glTextureBufferRange texture internalformat buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBufferRange" [LogV'GLuint texture, LogV'GLenum internalformat, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glTextureBufferRange (coerce texture) internalformat (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBufferRange" (LogV'Void)
#endif
    return _result

glTextureBufferRangeEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLenum -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glTextureBufferRangeEXT texture target internalformat buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureBufferRangeEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum internalformat, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glTextureBufferRangeEXT (coerce texture) (coerce target) internalformat (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureBufferRangeEXT" (LogV'Void)
#endif
    return _result

glTextureColorMaskSGIS :: MonadIO m => Boolean -> Boolean -> Boolean -> Boolean -> m ()
glTextureColorMaskSGIS red green blue alpha = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureColorMaskSGIS" [LogV'GLboolean red, LogV'GLboolean green, LogV'GLboolean blue, LogV'GLboolean alpha]
#endif
    _result <- GL.glTextureColorMaskSGIS (coerce red) (coerce green) (coerce blue) (coerce alpha)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureColorMaskSGIS" (LogV'Void)
#endif
    return _result

glTextureImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureImage1DEXT texture target level internalformat width border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureImage1DEXT (coerce texture) (coerce target) level internalformat width border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage1DEXT" (LogV'Void)
#endif
    return _result

glTextureImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureImage2DEXT texture target level internalformat width height border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureImage2DEXT (coerce texture) (coerce target) level internalformat width height border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage2DEXT" (LogV'Void)
#endif
    return _result

glTextureImage2DMultisampleCoverageNV :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureImage2DMultisampleCoverageNV texture target coverageSamples colorSamples internalFormat width height fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage2DMultisampleCoverageNV" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTextureImage2DMultisampleCoverageNV (coerce texture) target coverageSamples colorSamples internalFormat width height (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage2DMultisampleCoverageNV" (LogV'Void)
#endif
    return _result

glTextureImage2DMultisampleNV :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureImage2DMultisampleNV texture target samples internalFormat width height fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage2DMultisampleNV" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei samples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTextureImage2DMultisampleNV (coerce texture) target samples internalFormat width height (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage2DMultisampleNV" (LogV'Void)
#endif
    return _result

glTextureImage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureImage3DEXT texture target level internalformat width height depth border format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLint border, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureImage3DEXT (coerce texture) (coerce target) level internalformat width height depth border (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage3DEXT" (LogV'Void)
#endif
    return _result

glTextureImage3DMultisampleCoverageNV :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureImage3DMultisampleCoverageNV texture target coverageSamples colorSamples internalFormat width height depth fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage3DMultisampleCoverageNV" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei coverageSamples, LogV'GLsizei colorSamples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTextureImage3DMultisampleCoverageNV (coerce texture) target coverageSamples colorSamples internalFormat width height depth (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage3DMultisampleCoverageNV" (LogV'Void)
#endif
    return _result

glTextureImage3DMultisampleNV :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureImage3DMultisampleNV texture target samples internalFormat width height depth fixedSampleLocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureImage3DMultisampleNV" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei samples, LogV'GLint internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedSampleLocations]
#endif
    _result <- GL.glTextureImage3DMultisampleNV (coerce texture) target samples internalFormat width height depth (coerce fixedSampleLocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureImage3DMultisampleNV" (LogV'Void)
#endif
    return _result

glTextureLightEXT :: MonadIO m => GL.GLenum -> m ()
glTextureLightEXT pname = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureLightEXT" [LogV'GLenum pname]
#endif
    _result <- GL.glTextureLightEXT pname
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureLightEXT" (LogV'Void)
#endif
    return _result

glTextureMaterialEXT :: MonadIO m => MaterialFace -> MaterialParameter -> m ()
glTextureMaterialEXT face mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureMaterialEXT" [LogV'GLenum face, LogV'GLenum mode]
#endif
    _result <- GL.glTextureMaterialEXT (coerce face) (coerce mode)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureMaterialEXT" (LogV'Void)
#endif
    return _result

glTextureNormalEXT :: MonadIO m => GL.GLenum -> m ()
glTextureNormalEXT mode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureNormalEXT" [LogV'GLenum mode]
#endif
    _result <- GL.glTextureNormalEXT mode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureNormalEXT" (LogV'Void)
#endif
    return _result

glTexturePageCommitmentEXT :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLboolean -> m ()
glTexturePageCommitmentEXT texture level xoffset yoffset zoffset width height depth commit = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTexturePageCommitmentEXT" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean commit]
#endif
    _result <- GL.glTexturePageCommitmentEXT (coerce texture) level xoffset yoffset zoffset width height depth commit
#ifdef GLW_DEBUG
    logGLCommandEnd "glTexturePageCommitmentEXT" (LogV'Void)
#endif
    return _result

glTextureParameterIiv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLint -> m ()
glTextureParameterIiv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterIiv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterIiv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterIiv" (LogV'Void)
#endif
    return _result

glTextureParameterIivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glTextureParameterIivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterIivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterIivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterIivEXT" (LogV'Void)
#endif
    return _result

glTextureParameterIuiv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLuint -> m ()
glTextureParameterIuiv texture pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterIuiv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterIuiv (coerce texture) pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterIuiv" (LogV'Void)
#endif
    return _result

glTextureParameterIuivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> Ptr GL.GLuint -> m ()
glTextureParameterIuivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterIuivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterIuivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterIuivEXT" (LogV'Void)
#endif
    return _result

glTextureParameterf :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLfloat -> m ()
glTextureParameterf texture pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterf" [LogV'GLuint texture, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glTextureParameterf (coerce texture) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterf" (LogV'Void)
#endif
    return _result

glTextureParameterfEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> GL.GLfloat -> m ()
glTextureParameterfEXT texture target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterfEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glTextureParameterfEXT (coerce texture) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterfEXT" (LogV'Void)
#endif
    return _result

glTextureParameterfv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glTextureParameterfv texture pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterfv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterfv (coerce texture) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterfv" (LogV'Void)
#endif
    return _result

glTextureParameterfvEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> Ptr GL.GLfloat -> m ()
glTextureParameterfvEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterfvEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterfvEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterfvEXT" (LogV'Void)
#endif
    return _result

glTextureParameteri :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLint -> m ()
glTextureParameteri texture pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameteri" [LogV'GLuint texture, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glTextureParameteri (coerce texture) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameteri" (LogV'Void)
#endif
    return _result

glTextureParameteriEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> GL.GLint -> m ()
glTextureParameteriEXT texture target pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameteriEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glTextureParameteriEXT (coerce texture) (coerce target) (coerce pname) param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameteriEXT" (LogV'Void)
#endif
    return _result

glTextureParameteriv :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> Ptr GL.GLint -> m ()
glTextureParameteriv texture pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameteriv" [LogV'GLuint texture, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameteriv (coerce texture) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameteriv" (LogV'Void)
#endif
    return _result

glTextureParameterivEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> TextureParameterName -> Ptr GL.GLint -> m ()
glTextureParameterivEXT texture target pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureParameterivEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glTextureParameterivEXT (coerce texture) (coerce target) (coerce pname) params
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureParameterivEXT" (LogV'Void)
#endif
    return _result

glTextureRangeAPPLE :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glTextureRangeAPPLE target length pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureRangeAPPLE" [LogV'GLenum target, LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glTextureRangeAPPLE target length pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureRangeAPPLE" (LogV'Void)
#endif
    return _result

glTextureRenderbufferEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> Renderbuffer -> m ()
glTextureRenderbufferEXT texture target renderbuffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureRenderbufferEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLuint renderbuffer]
#endif
    _result <- GL.glTextureRenderbufferEXT (coerce texture) (coerce target) (coerce renderbuffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureRenderbufferEXT" (LogV'Void)
#endif
    return _result

glTextureStorage1D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> m ()
glTextureStorage1D texture levels internalformat width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage1D" [LogV'GLuint texture, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width]
#endif
    _result <- GL.glTextureStorage1D (coerce texture) levels internalformat width
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage1D" (LogV'Void)
#endif
    return _result

glTextureStorage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> m ()
glTextureStorage1DEXT texture target levels internalformat width = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width]
#endif
    _result <- GL.glTextureStorage1DEXT (coerce texture) target levels internalformat width
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage1DEXT" (LogV'Void)
#endif
    return _result

glTextureStorage2D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glTextureStorage2D texture levels internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage2D" [LogV'GLuint texture, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glTextureStorage2D (coerce texture) levels internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage2D" (LogV'Void)
#endif
    return _result

glTextureStorage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> m ()
glTextureStorage2DEXT texture target levels internalformat width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glTextureStorage2DEXT (coerce texture) target levels internalformat width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage2DEXT" (LogV'Void)
#endif
    return _result

glTextureStorage2DMultisample :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLboolean -> m ()
glTextureStorage2DMultisample texture samples internalformat width height fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage2DMultisample" [LogV'GLuint texture, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTextureStorage2DMultisample (coerce texture) samples internalformat width height fixedsamplelocations
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage2DMultisample" (LogV'Void)
#endif
    return _result

glTextureStorage2DMultisampleEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureStorage2DMultisampleEXT texture target samples internalformat width height fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage2DMultisampleEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTextureStorage2DMultisampleEXT (coerce texture) (coerce target) samples internalformat width height (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage2DMultisampleEXT" (LogV'Void)
#endif
    return _result

glTextureStorage3D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glTextureStorage3D texture levels internalformat width height depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage3D" [LogV'GLuint texture, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth]
#endif
    _result <- GL.glTextureStorage3D (coerce texture) levels internalformat width height depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage3D" (LogV'Void)
#endif
    return _result

glTextureStorage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> m ()
glTextureStorage3DEXT texture target levels internalformat width height depth = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei levels, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth]
#endif
    _result <- GL.glTextureStorage3DEXT (coerce texture) target levels internalformat width height depth
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage3DEXT" (LogV'Void)
#endif
    return _result

glTextureStorage3DMultisample :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLboolean -> m ()
glTextureStorage3DMultisample texture samples internalformat width height depth fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage3DMultisample" [LogV'GLuint texture, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTextureStorage3DMultisample (coerce texture) samples internalformat width height depth fixedsamplelocations
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage3DMultisample" (LogV'Void)
#endif
    return _result

glTextureStorage3DMultisampleEXT :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLsizei -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> Boolean -> m ()
glTextureStorage3DMultisampleEXT texture target samples internalformat width height depth fixedsamplelocations = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorage3DMultisampleEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLsizei samples, LogV'GLenum internalformat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLboolean fixedsamplelocations]
#endif
    _result <- GL.glTextureStorage3DMultisampleEXT (coerce texture) target samples internalformat width height depth (coerce fixedsamplelocations)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorage3DMultisampleEXT" (LogV'Void)
#endif
    return _result

glTextureStorageSparseAMD :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLenum -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLbitfield -> m ()
glTextureStorageSparseAMD texture target internalFormat width height depth layers flags = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureStorageSparseAMD" [LogV'GLuint texture, LogV'GLenum target, LogV'GLenum internalFormat, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLsizei layers, LogV'GLbitfield flags]
#endif
    _result <- GL.glTextureStorageSparseAMD (coerce texture) target internalFormat width height depth layers flags
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureStorageSparseAMD" (LogV'Void)
#endif
    return _result

glTextureSubImage1D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glTextureSubImage1D texture level xoffset width format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage1D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage1D (coerce texture) level xoffset width format type' pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage1D" (LogV'Void)
#endif
    return _result

glTextureSubImage1DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureSubImage1DEXT texture target level xoffset width format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage1DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLsizei width, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage1DEXT (coerce texture) (coerce target) level xoffset width (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage1DEXT" (LogV'Void)
#endif
    return _result

glTextureSubImage2D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glTextureSubImage2D texture level xoffset yoffset width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage2D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage2D (coerce texture) level xoffset yoffset width height format type' pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage2D" (LogV'Void)
#endif
    return _result

glTextureSubImage2DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureSubImage2DEXT texture target level xoffset yoffset width height format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage2DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage2DEXT (coerce texture) (coerce target) level xoffset yoffset width height (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage2DEXT" (LogV'Void)
#endif
    return _result

glTextureSubImage3D :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> GL.GLenum -> GL.GLenum -> Ptr () -> m ()
glTextureSubImage3D texture level xoffset yoffset zoffset width height depth format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage3D" [LogV'GLuint texture, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage3D (coerce texture) level xoffset yoffset zoffset width height depth format type' pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage3D" (LogV'Void)
#endif
    return _result

glTextureSubImage3DEXT :: MonadIO m => Texture (a :: TextureTarget') -> TextureTarget -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> GL.GLsizei -> PixelFormat -> PixelType -> Ptr () -> m ()
glTextureSubImage3DEXT texture target level xoffset yoffset zoffset width height depth format type' pixels = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureSubImage3DEXT" [LogV'GLuint texture, LogV'GLenum target, LogV'GLint level, LogV'GLint xoffset, LogV'GLint yoffset, LogV'GLint zoffset, LogV'GLsizei width, LogV'GLsizei height, LogV'GLsizei depth, LogV'GLenum format, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glTextureSubImage3DEXT (coerce texture) (coerce target) level xoffset yoffset zoffset width height depth (coerce format) (coerce type') pixels
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureSubImage3DEXT" (LogV'Void)
#endif
    return _result

glTextureView :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glTextureView texture target origtexture internalformat minlevel numlevels minlayer numlayers = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTextureView" [LogV'GLuint texture, LogV'GLenum target, LogV'GLuint origtexture, LogV'GLenum internalformat, LogV'GLuint minlevel, LogV'GLuint numlevels, LogV'GLuint minlayer, LogV'GLuint numlayers]
#endif
    _result <- GL.glTextureView (coerce texture) target origtexture internalformat minlevel numlevels minlayer numlayers
#ifdef GLW_DEBUG
    logGLCommandEnd "glTextureView" (LogV'Void)
#endif
    return _result

glTrackMatrixNV :: MonadIO m => GL.GLenum -> GL.GLuint -> GL.GLenum -> GL.GLenum -> m ()
glTrackMatrixNV target address matrix transform = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTrackMatrixNV" [LogV'GLenum target, LogV'GLuint address, LogV'GLenum matrix, LogV'GLenum transform]
#endif
    _result <- GL.glTrackMatrixNV target address matrix transform
#ifdef GLW_DEBUG
    logGLCommandEnd "glTrackMatrixNV" (LogV'Void)
#endif
    return _result

glTransformFeedbackAttribsNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLint -> GL.GLenum -> m ()
glTransformFeedbackAttribsNV count attribs bufferMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackAttribsNV" [LogV'GLsizei count, LogV'Ptr, LogV'GLenum bufferMode]
#endif
    _result <- GL.glTransformFeedbackAttribsNV count attribs bufferMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackAttribsNV" (LogV'Void)
#endif
    return _result

glTransformFeedbackBufferBase :: MonadIO m => TransformFeedback -> GL.GLuint -> Buffer -> m ()
glTransformFeedbackBufferBase xfb index buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackBufferBase" [LogV'GLuint xfb, LogV'GLuint index, LogV'GLuint buffer]
#endif
    _result <- GL.glTransformFeedbackBufferBase (coerce xfb) index (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackBufferBase" (LogV'Void)
#endif
    return _result

glTransformFeedbackBufferRange :: MonadIO m => TransformFeedback -> GL.GLuint -> Buffer -> GL.GLintptr -> GL.GLsizeiptr -> m ()
glTransformFeedbackBufferRange xfb index buffer offset size = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackBufferRange" [LogV'GLuint xfb, LogV'GLuint index, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizeiptr size]
#endif
    _result <- GL.glTransformFeedbackBufferRange (coerce xfb) index (coerce buffer) offset size
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackBufferRange" (LogV'Void)
#endif
    return _result

glTransformFeedbackStreamAttribsNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLint -> GL.GLsizei -> Ptr GL.GLint -> GL.GLenum -> m ()
glTransformFeedbackStreamAttribsNV count attribs nbuffers bufstreams bufferMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackStreamAttribsNV" [LogV'GLsizei count, LogV'Ptr, LogV'GLsizei nbuffers, LogV'Ptr, LogV'GLenum bufferMode]
#endif
    _result <- GL.glTransformFeedbackStreamAttribsNV count attribs nbuffers bufstreams bufferMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackStreamAttribsNV" (LogV'Void)
#endif
    return _result

glTransformFeedbackVaryings :: MonadIO m => Program -> GL.GLsizei -> Ptr (Ptr GL.GLchar) -> GL.GLenum -> m ()
glTransformFeedbackVaryings program count varyings bufferMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackVaryings" [LogV'GLuint program, LogV'GLsizei count, LogV'Ptr, LogV'GLenum bufferMode]
#endif
    _result <- GL.glTransformFeedbackVaryings (coerce program) count varyings bufferMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackVaryings" (LogV'Void)
#endif
    return _result

glTransformFeedbackVaryingsEXT :: MonadIO m => Program -> GL.GLsizei -> Ptr (Ptr GL.GLchar) -> GL.GLenum -> m ()
glTransformFeedbackVaryingsEXT program count varyings bufferMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackVaryingsEXT" [LogV'GLuint program, LogV'GLsizei count, LogV'Ptr, LogV'GLenum bufferMode]
#endif
    _result <- GL.glTransformFeedbackVaryingsEXT (coerce program) count varyings bufferMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackVaryingsEXT" (LogV'Void)
#endif
    return _result

glTransformFeedbackVaryingsNV :: MonadIO m => Program -> GL.GLsizei -> Ptr GL.GLint -> GL.GLenum -> m ()
glTransformFeedbackVaryingsNV program count locations bufferMode = do
#ifdef GLW_DEBUG
    logGLCommandStart "glTransformFeedbackVaryingsNV" [LogV'GLuint program, LogV'GLsizei count, LogV'Ptr, LogV'GLenum bufferMode]
#endif
    _result <- GL.glTransformFeedbackVaryingsNV (coerce program) count locations bufferMode
#ifdef GLW_DEBUG
    logGLCommandEnd "glTransformFeedbackVaryingsNV" (LogV'Void)
#endif
    return _result

glUniform1d :: MonadIO m => UniformLocation -> GL.GLdouble -> m ()
glUniform1d location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1d" [LogV'GLint location, LogV'GLdouble x]
#endif
    _result <- GL.glUniform1d (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1d" (LogV'Void)
#endif
    return _result

glUniform1dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glUniform1dv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1dv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1dv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1dv" (LogV'Void)
#endif
    return _result

glUniform1f :: MonadIO m => UniformLocation -> GL.GLfloat -> m ()
glUniform1f location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1f" [LogV'GLint location, LogV'GLfloat v0]
#endif
    _result <- GL.glUniform1f (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1f" (LogV'Void)
#endif
    return _result

glUniform1fARB :: MonadIO m => UniformLocation -> GL.GLfloat -> m ()
glUniform1fARB location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1fARB" [LogV'GLint location, LogV'GLfloat v0]
#endif
    _result <- GL.glUniform1fARB (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1fARB" (LogV'Void)
#endif
    return _result

glUniform1fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform1fv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1fv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1fv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1fv" (LogV'Void)
#endif
    return _result

glUniform1fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform1fvARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1fvARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1fvARB" (LogV'Void)
#endif
    return _result

glUniform1i :: MonadIO m => UniformLocation -> GL.GLint -> m ()
glUniform1i location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1i" [LogV'GLint location, LogV'GLint v0]
#endif
    _result <- GL.glUniform1i (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1i" (LogV'Void)
#endif
    return _result

glUniform1i64ARB :: MonadIO m => UniformLocation -> GL.GLint64 -> m ()
glUniform1i64ARB location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1i64ARB" [LogV'GLint location, LogV'GLint64 x]
#endif
    _result <- GL.glUniform1i64ARB (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1i64ARB" (LogV'Void)
#endif
    return _result

glUniform1i64NV :: MonadIO m => UniformLocation -> GL.GLint64EXT -> m ()
glUniform1i64NV location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1i64NV" [LogV'GLint location, LogV'GLint64EXT x]
#endif
    _result <- GL.glUniform1i64NV (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1i64NV" (LogV'Void)
#endif
    return _result

glUniform1i64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glUniform1i64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1i64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1i64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1i64vARB" (LogV'Void)
#endif
    return _result

glUniform1i64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glUniform1i64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1i64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1i64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1i64vNV" (LogV'Void)
#endif
    return _result

glUniform1iARB :: MonadIO m => UniformLocation -> GL.GLint -> m ()
glUniform1iARB location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1iARB" [LogV'GLint location, LogV'GLint v0]
#endif
    _result <- GL.glUniform1iARB (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1iARB" (LogV'Void)
#endif
    return _result

glUniform1iv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform1iv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1iv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1iv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1iv" (LogV'Void)
#endif
    return _result

glUniform1ivARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform1ivARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ivARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1ivARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ivARB" (LogV'Void)
#endif
    return _result

glUniform1ui :: MonadIO m => UniformLocation -> GL.GLuint -> m ()
glUniform1ui location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ui" [LogV'GLint location, LogV'GLuint v0]
#endif
    _result <- GL.glUniform1ui (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ui" (LogV'Void)
#endif
    return _result

glUniform1ui64ARB :: MonadIO m => UniformLocation -> GL.GLuint64 -> m ()
glUniform1ui64ARB location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ui64ARB" [LogV'GLint location, LogV'GLuint64 x]
#endif
    _result <- GL.glUniform1ui64ARB (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ui64ARB" (LogV'Void)
#endif
    return _result

glUniform1ui64NV :: MonadIO m => UniformLocation -> GL.GLuint64EXT -> m ()
glUniform1ui64NV location x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ui64NV" [LogV'GLint location, LogV'GLuint64EXT x]
#endif
    _result <- GL.glUniform1ui64NV (coerce location) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ui64NV" (LogV'Void)
#endif
    return _result

glUniform1ui64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glUniform1ui64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ui64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1ui64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ui64vARB" (LogV'Void)
#endif
    return _result

glUniform1ui64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glUniform1ui64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1ui64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1ui64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1ui64vNV" (LogV'Void)
#endif
    return _result

glUniform1uiEXT :: MonadIO m => UniformLocation -> GL.GLuint -> m ()
glUniform1uiEXT location v0 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1uiEXT" [LogV'GLint location, LogV'GLuint v0]
#endif
    _result <- GL.glUniform1uiEXT (coerce location) v0
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1uiEXT" (LogV'Void)
#endif
    return _result

glUniform1uiv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform1uiv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1uiv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1uiv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1uiv" (LogV'Void)
#endif
    return _result

glUniform1uivEXT :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform1uivEXT location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform1uivEXT" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform1uivEXT (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform1uivEXT" (LogV'Void)
#endif
    return _result

glUniform2d :: MonadIO m => UniformLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glUniform2d location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2d" [LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glUniform2d (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2d" (LogV'Void)
#endif
    return _result

glUniform2dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glUniform2dv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2dv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2dv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2dv" (LogV'Void)
#endif
    return _result

glUniform2f :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform2f location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2f" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1]
#endif
    _result <- GL.glUniform2f (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2f" (LogV'Void)
#endif
    return _result

glUniform2fARB :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform2fARB location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2fARB" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1]
#endif
    _result <- GL.glUniform2fARB (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2fARB" (LogV'Void)
#endif
    return _result

glUniform2fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform2fv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2fv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2fv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2fv" (LogV'Void)
#endif
    return _result

glUniform2fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform2fvARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2fvARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2fvARB" (LogV'Void)
#endif
    return _result

glUniform2i :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> m ()
glUniform2i location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2i" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1]
#endif
    _result <- GL.glUniform2i (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2i" (LogV'Void)
#endif
    return _result

glUniform2i64ARB :: MonadIO m => UniformLocation -> GL.GLint64 -> GL.GLint64 -> m ()
glUniform2i64ARB location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2i64ARB" [LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y]
#endif
    _result <- GL.glUniform2i64ARB (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2i64ARB" (LogV'Void)
#endif
    return _result

glUniform2i64NV :: MonadIO m => UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glUniform2i64NV location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2i64NV" [LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y]
#endif
    _result <- GL.glUniform2i64NV (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2i64NV" (LogV'Void)
#endif
    return _result

glUniform2i64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glUniform2i64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2i64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2i64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2i64vARB" (LogV'Void)
#endif
    return _result

glUniform2i64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glUniform2i64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2i64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2i64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2i64vNV" (LogV'Void)
#endif
    return _result

glUniform2iARB :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> m ()
glUniform2iARB location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2iARB" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1]
#endif
    _result <- GL.glUniform2iARB (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2iARB" (LogV'Void)
#endif
    return _result

glUniform2iv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform2iv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2iv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2iv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2iv" (LogV'Void)
#endif
    return _result

glUniform2ivARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform2ivARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ivARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2ivARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ivARB" (LogV'Void)
#endif
    return _result

glUniform2ui :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> m ()
glUniform2ui location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ui" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1]
#endif
    _result <- GL.glUniform2ui (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ui" (LogV'Void)
#endif
    return _result

glUniform2ui64ARB :: MonadIO m => UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> m ()
glUniform2ui64ARB location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ui64ARB" [LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y]
#endif
    _result <- GL.glUniform2ui64ARB (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ui64ARB" (LogV'Void)
#endif
    return _result

glUniform2ui64NV :: MonadIO m => UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glUniform2ui64NV location x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ui64NV" [LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y]
#endif
    _result <- GL.glUniform2ui64NV (coerce location) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ui64NV" (LogV'Void)
#endif
    return _result

glUniform2ui64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glUniform2ui64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ui64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2ui64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ui64vARB" (LogV'Void)
#endif
    return _result

glUniform2ui64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glUniform2ui64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2ui64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2ui64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2ui64vNV" (LogV'Void)
#endif
    return _result

glUniform2uiEXT :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> m ()
glUniform2uiEXT location v0 v1 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2uiEXT" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1]
#endif
    _result <- GL.glUniform2uiEXT (coerce location) v0 v1
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2uiEXT" (LogV'Void)
#endif
    return _result

glUniform2uiv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform2uiv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2uiv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2uiv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2uiv" (LogV'Void)
#endif
    return _result

glUniform2uivEXT :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform2uivEXT location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform2uivEXT" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform2uivEXT (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform2uivEXT" (LogV'Void)
#endif
    return _result

glUniform3d :: MonadIO m => UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glUniform3d location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3d" [LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glUniform3d (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3d" (LogV'Void)
#endif
    return _result

glUniform3dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glUniform3dv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3dv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3dv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3dv" (LogV'Void)
#endif
    return _result

glUniform3f :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform3f location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3f" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2]
#endif
    _result <- GL.glUniform3f (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3f" (LogV'Void)
#endif
    return _result

glUniform3fARB :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform3fARB location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3fARB" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2]
#endif
    _result <- GL.glUniform3fARB (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3fARB" (LogV'Void)
#endif
    return _result

glUniform3fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform3fv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3fv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3fv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3fv" (LogV'Void)
#endif
    return _result

glUniform3fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform3fvARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3fvARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3fvARB" (LogV'Void)
#endif
    return _result

glUniform3i :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glUniform3i location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3i" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2]
#endif
    _result <- GL.glUniform3i (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3i" (LogV'Void)
#endif
    return _result

glUniform3i64ARB :: MonadIO m => UniformLocation -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> m ()
glUniform3i64ARB location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3i64ARB" [LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y, LogV'GLint64 z]
#endif
    _result <- GL.glUniform3i64ARB (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3i64ARB" (LogV'Void)
#endif
    return _result

glUniform3i64NV :: MonadIO m => UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glUniform3i64NV location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3i64NV" [LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z]
#endif
    _result <- GL.glUniform3i64NV (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3i64NV" (LogV'Void)
#endif
    return _result

glUniform3i64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glUniform3i64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3i64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3i64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3i64vARB" (LogV'Void)
#endif
    return _result

glUniform3i64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glUniform3i64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3i64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3i64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3i64vNV" (LogV'Void)
#endif
    return _result

glUniform3iARB :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glUniform3iARB location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3iARB" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2]
#endif
    _result <- GL.glUniform3iARB (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3iARB" (LogV'Void)
#endif
    return _result

glUniform3iv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform3iv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3iv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3iv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3iv" (LogV'Void)
#endif
    return _result

glUniform3ivARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform3ivARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ivARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3ivARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ivARB" (LogV'Void)
#endif
    return _result

glUniform3ui :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glUniform3ui location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ui" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2]
#endif
    _result <- GL.glUniform3ui (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ui" (LogV'Void)
#endif
    return _result

glUniform3ui64ARB :: MonadIO m => UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> m ()
glUniform3ui64ARB location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ui64ARB" [LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y, LogV'GLuint64 z]
#endif
    _result <- GL.glUniform3ui64ARB (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ui64ARB" (LogV'Void)
#endif
    return _result

glUniform3ui64NV :: MonadIO m => UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glUniform3ui64NV location x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ui64NV" [LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z]
#endif
    _result <- GL.glUniform3ui64NV (coerce location) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ui64NV" (LogV'Void)
#endif
    return _result

glUniform3ui64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glUniform3ui64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ui64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3ui64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ui64vARB" (LogV'Void)
#endif
    return _result

glUniform3ui64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glUniform3ui64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3ui64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3ui64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3ui64vNV" (LogV'Void)
#endif
    return _result

glUniform3uiEXT :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glUniform3uiEXT location v0 v1 v2 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3uiEXT" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2]
#endif
    _result <- GL.glUniform3uiEXT (coerce location) v0 v1 v2
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3uiEXT" (LogV'Void)
#endif
    return _result

glUniform3uiv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform3uiv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3uiv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3uiv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3uiv" (LogV'Void)
#endif
    return _result

glUniform3uivEXT :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform3uivEXT location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform3uivEXT" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform3uivEXT (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform3uivEXT" (LogV'Void)
#endif
    return _result

glUniform4d :: MonadIO m => UniformLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glUniform4d location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4d" [LogV'GLint location, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glUniform4d (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4d" (LogV'Void)
#endif
    return _result

glUniform4dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glUniform4dv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4dv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4dv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4dv" (LogV'Void)
#endif
    return _result

glUniform4f :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform4f location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4f" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLfloat v3]
#endif
    _result <- GL.glUniform4f (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4f" (LogV'Void)
#endif
    return _result

glUniform4fARB :: MonadIO m => UniformLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glUniform4fARB location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4fARB" [LogV'GLint location, LogV'GLfloat v0, LogV'GLfloat v1, LogV'GLfloat v2, LogV'GLfloat v3]
#endif
    _result <- GL.glUniform4fARB (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4fARB" (LogV'Void)
#endif
    return _result

glUniform4fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform4fv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4fv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4fv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4fv" (LogV'Void)
#endif
    return _result

glUniform4fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glUniform4fvARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4fvARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4fvARB" (LogV'Void)
#endif
    return _result

glUniform4i :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glUniform4i location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4i" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2, LogV'GLint v3]
#endif
    _result <- GL.glUniform4i (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4i" (LogV'Void)
#endif
    return _result

glUniform4i64ARB :: MonadIO m => UniformLocation -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> GL.GLint64 -> m ()
glUniform4i64ARB location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4i64ARB" [LogV'GLint location, LogV'GLint64 x, LogV'GLint64 y, LogV'GLint64 z, LogV'GLint64 w]
#endif
    _result <- GL.glUniform4i64ARB (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4i64ARB" (LogV'Void)
#endif
    return _result

glUniform4i64NV :: MonadIO m => UniformLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glUniform4i64NV location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4i64NV" [LogV'GLint location, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z, LogV'GLint64EXT w]
#endif
    _result <- GL.glUniform4i64NV (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4i64NV" (LogV'Void)
#endif
    return _result

glUniform4i64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64 -> m ()
glUniform4i64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4i64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4i64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4i64vARB" (LogV'Void)
#endif
    return _result

glUniform4i64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint64EXT -> m ()
glUniform4i64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4i64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4i64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4i64vNV" (LogV'Void)
#endif
    return _result

glUniform4iARB :: MonadIO m => UniformLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glUniform4iARB location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4iARB" [LogV'GLint location, LogV'GLint v0, LogV'GLint v1, LogV'GLint v2, LogV'GLint v3]
#endif
    _result <- GL.glUniform4iARB (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4iARB" (LogV'Void)
#endif
    return _result

glUniform4iv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform4iv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4iv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4iv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4iv" (LogV'Void)
#endif
    return _result

glUniform4ivARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLint -> m ()
glUniform4ivARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ivARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4ivARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ivARB" (LogV'Void)
#endif
    return _result

glUniform4ui :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glUniform4ui location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ui" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2, LogV'GLuint v3]
#endif
    _result <- GL.glUniform4ui (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ui" (LogV'Void)
#endif
    return _result

glUniform4ui64ARB :: MonadIO m => UniformLocation -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> GL.GLuint64 -> m ()
glUniform4ui64ARB location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ui64ARB" [LogV'GLint location, LogV'GLuint64 x, LogV'GLuint64 y, LogV'GLuint64 z, LogV'GLuint64 w]
#endif
    _result <- GL.glUniform4ui64ARB (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ui64ARB" (LogV'Void)
#endif
    return _result

glUniform4ui64NV :: MonadIO m => UniformLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glUniform4ui64NV location x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ui64NV" [LogV'GLint location, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z, LogV'GLuint64EXT w]
#endif
    _result <- GL.glUniform4ui64NV (coerce location) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ui64NV" (LogV'Void)
#endif
    return _result

glUniform4ui64vARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64 -> m ()
glUniform4ui64vARB location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ui64vARB" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4ui64vARB (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ui64vARB" (LogV'Void)
#endif
    return _result

glUniform4ui64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glUniform4ui64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4ui64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4ui64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4ui64vNV" (LogV'Void)
#endif
    return _result

glUniform4uiEXT :: MonadIO m => UniformLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glUniform4uiEXT location v0 v1 v2 v3 = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4uiEXT" [LogV'GLint location, LogV'GLuint v0, LogV'GLuint v1, LogV'GLuint v2, LogV'GLuint v3]
#endif
    _result <- GL.glUniform4uiEXT (coerce location) v0 v1 v2 v3
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4uiEXT" (LogV'Void)
#endif
    return _result

glUniform4uiv :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform4uiv location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4uiv" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4uiv (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4uiv" (LogV'Void)
#endif
    return _result

glUniform4uivEXT :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniform4uivEXT location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniform4uivEXT" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniform4uivEXT (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniform4uivEXT" (LogV'Void)
#endif
    return _result

glUniformBlockBinding :: MonadIO m => Program -> GL.GLuint -> GL.GLuint -> m ()
glUniformBlockBinding program uniformBlockIndex uniformBlockBinding = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformBlockBinding" [LogV'GLuint program, LogV'GLuint uniformBlockIndex, LogV'GLuint uniformBlockBinding]
#endif
    _result <- GL.glUniformBlockBinding (coerce program) uniformBlockIndex uniformBlockBinding
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformBlockBinding" (LogV'Void)
#endif
    return _result

glUniformBufferEXT :: MonadIO m => Program -> UniformLocation -> Buffer -> m ()
glUniformBufferEXT program location buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformBufferEXT" [LogV'GLuint program, LogV'GLint location, LogV'GLuint buffer]
#endif
    _result <- GL.glUniformBufferEXT (coerce program) (coerce location) (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformBufferEXT" (LogV'Void)
#endif
    return _result

glUniformMatrix2dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix2dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2dv" (LogV'Void)
#endif
    return _result

glUniformMatrix2fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix2fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2fv" (LogV'Void)
#endif
    return _result

glUniformMatrix2fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix2fvARB location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2fvARB (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2fvARB" (LogV'Void)
#endif
    return _result

glUniformMatrix2x3dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix2x3dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2x3dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2x3dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2x3dv" (LogV'Void)
#endif
    return _result

glUniformMatrix2x3fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix2x3fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2x3fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2x3fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2x3fv" (LogV'Void)
#endif
    return _result

glUniformMatrix2x4dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix2x4dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2x4dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2x4dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2x4dv" (LogV'Void)
#endif
    return _result

glUniformMatrix2x4fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix2x4fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix2x4fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix2x4fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix2x4fv" (LogV'Void)
#endif
    return _result

glUniformMatrix3dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix3dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3dv" (LogV'Void)
#endif
    return _result

glUniformMatrix3fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix3fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3fv" (LogV'Void)
#endif
    return _result

glUniformMatrix3fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix3fvARB location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3fvARB (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3fvARB" (LogV'Void)
#endif
    return _result

glUniformMatrix3x2dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix3x2dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3x2dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3x2dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3x2dv" (LogV'Void)
#endif
    return _result

glUniformMatrix3x2fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix3x2fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3x2fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3x2fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3x2fv" (LogV'Void)
#endif
    return _result

glUniformMatrix3x4dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix3x4dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3x4dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3x4dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3x4dv" (LogV'Void)
#endif
    return _result

glUniformMatrix3x4fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix3x4fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix3x4fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix3x4fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix3x4fv" (LogV'Void)
#endif
    return _result

glUniformMatrix4dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix4dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4dv" (LogV'Void)
#endif
    return _result

glUniformMatrix4fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix4fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4fv" (LogV'Void)
#endif
    return _result

glUniformMatrix4fvARB :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix4fvARB location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4fvARB" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4fvARB (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4fvARB" (LogV'Void)
#endif
    return _result

glUniformMatrix4x2dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix4x2dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4x2dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4x2dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4x2dv" (LogV'Void)
#endif
    return _result

glUniformMatrix4x2fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix4x2fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4x2fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4x2fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4x2fv" (LogV'Void)
#endif
    return _result

glUniformMatrix4x3dv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLdouble -> m ()
glUniformMatrix4x3dv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4x3dv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4x3dv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4x3dv" (LogV'Void)
#endif
    return _result

glUniformMatrix4x3fv :: MonadIO m => UniformLocation -> GL.GLsizei -> Boolean -> Ptr GL.GLfloat -> m ()
glUniformMatrix4x3fv location count transpose value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformMatrix4x3fv" [LogV'GLint location, LogV'GLsizei count, LogV'GLboolean transpose, LogV'Ptr]
#endif
    _result <- GL.glUniformMatrix4x3fv (coerce location) count (coerce transpose) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformMatrix4x3fv" (LogV'Void)
#endif
    return _result

glUniformSubroutinesuiv :: MonadIO m => GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> m ()
glUniformSubroutinesuiv shadertype count indices = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformSubroutinesuiv" [LogV'GLenum shadertype, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniformSubroutinesuiv shadertype count indices
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformSubroutinesuiv" (LogV'Void)
#endif
    return _result

glUniformui64NV :: MonadIO m => UniformLocation -> GL.GLuint64EXT -> m ()
glUniformui64NV location value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformui64NV" [LogV'GLint location, LogV'GLuint64EXT value]
#endif
    _result <- GL.glUniformui64NV (coerce location) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformui64NV" (LogV'Void)
#endif
    return _result

glUniformui64vNV :: MonadIO m => UniformLocation -> GL.GLsizei -> Ptr GL.GLuint64EXT -> m ()
glUniformui64vNV location count value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUniformui64vNV" [LogV'GLint location, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glUniformui64vNV (coerce location) count value
#ifdef GLW_DEBUG
    logGLCommandEnd "glUniformui64vNV" (LogV'Void)
#endif
    return _result

glUnlockArraysEXT :: MonadIO m => m ()
glUnlockArraysEXT  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnlockArraysEXT" []
#endif
    _result <- GL.glUnlockArraysEXT 
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnlockArraysEXT" (LogV'Void)
#endif
    return _result

glUnmapBuffer :: MonadIO m => GL.GLenum -> m Boolean
glUnmapBuffer target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapBuffer" [LogV'GLenum target]
#endif
    _result <- coerce <$> GL.glUnmapBuffer target
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapBuffer" (LogV'GLboolean _result)
#endif
    return _result

glUnmapBufferARB :: MonadIO m => GL.GLenum -> m Boolean
glUnmapBufferARB target = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapBufferARB" [LogV'GLenum target]
#endif
    _result <- coerce <$> GL.glUnmapBufferARB target
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapBufferARB" (LogV'GLboolean _result)
#endif
    return _result

glUnmapNamedBuffer :: MonadIO m => Buffer -> m GL.GLboolean
glUnmapNamedBuffer buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapNamedBuffer" [LogV'GLuint buffer]
#endif
    _result <- GL.glUnmapNamedBuffer (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapNamedBuffer" (LogV'GLboolean _result)
#endif
    return _result

glUnmapNamedBufferEXT :: MonadIO m => Buffer -> m Boolean
glUnmapNamedBufferEXT buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapNamedBufferEXT" [LogV'GLuint buffer]
#endif
    _result <- coerce <$> GL.glUnmapNamedBufferEXT (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapNamedBufferEXT" (LogV'GLboolean _result)
#endif
    return _result

glUnmapObjectBufferATI :: MonadIO m => Buffer -> m ()
glUnmapObjectBufferATI buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapObjectBufferATI" [LogV'GLuint buffer]
#endif
    _result <- GL.glUnmapObjectBufferATI (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapObjectBufferATI" (LogV'Void)
#endif
    return _result

glUnmapTexture2DINTEL :: MonadIO m => Texture (a :: TextureTarget') -> GL.GLint -> m ()
glUnmapTexture2DINTEL texture level = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUnmapTexture2DINTEL" [LogV'GLuint texture, LogV'GLint level]
#endif
    _result <- GL.glUnmapTexture2DINTEL (coerce texture) level
#ifdef GLW_DEBUG
    logGLCommandEnd "glUnmapTexture2DINTEL" (LogV'Void)
#endif
    return _result

glUpdateObjectBufferATI :: MonadIO m => Buffer -> GL.GLuint -> GL.GLsizei -> Ptr () -> GL.GLenum -> m ()
glUpdateObjectBufferATI buffer offset size pointer preserve = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUpdateObjectBufferATI" [LogV'GLuint buffer, LogV'GLuint offset, LogV'GLsizei size, LogV'Ptr, LogV'GLenum preserve]
#endif
    _result <- GL.glUpdateObjectBufferATI (coerce buffer) offset size pointer preserve
#ifdef GLW_DEBUG
    logGLCommandEnd "glUpdateObjectBufferATI" (LogV'Void)
#endif
    return _result

glUseProgram :: MonadIO m => Program -> m ()
glUseProgram program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUseProgram" [LogV'GLuint program]
#endif
    _result <- GL.glUseProgram (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUseProgram" (LogV'Void)
#endif
    return _result

glUseProgramObjectARB :: MonadIO m => GL.GLhandleARB -> m ()
glUseProgramObjectARB programObj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUseProgramObjectARB" [LogV'GLhandleARB programObj]
#endif
    _result <- GL.glUseProgramObjectARB programObj
#ifdef GLW_DEBUG
    logGLCommandEnd "glUseProgramObjectARB" (LogV'Void)
#endif
    return _result

glUseProgramStages :: MonadIO m => ProgramPipeline -> GL.GLbitfield -> Program -> m ()
glUseProgramStages pipeline stages program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glUseProgramStages" [LogV'GLuint pipeline, LogV'GLbitfield stages, LogV'GLuint program]
#endif
    _result <- GL.glUseProgramStages (coerce pipeline) stages (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glUseProgramStages" (LogV'Void)
#endif
    return _result

glVDPAUFiniNV :: MonadIO m => m ()
glVDPAUFiniNV  = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUFiniNV" []
#endif
    _result <- GL.glVDPAUFiniNV 
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUFiniNV" (LogV'Void)
#endif
    return _result

glVDPAUGetSurfaceivNV :: MonadIO m => GL.GLvdpauSurfaceNV -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLsizei -> Ptr GL.GLint -> m ()
glVDPAUGetSurfaceivNV surface pname bufSize length values = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUGetSurfaceivNV" [LogV'GLvdpauSurfaceNV surface, LogV'GLenum pname, LogV'GLsizei bufSize, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glVDPAUGetSurfaceivNV surface pname bufSize length values
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUGetSurfaceivNV" (LogV'Void)
#endif
    return _result

glVDPAUInitNV :: MonadIO m => Ptr () -> Ptr () -> m ()
glVDPAUInitNV vdpDevice getProcAddress = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUInitNV" [LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glVDPAUInitNV vdpDevice getProcAddress
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUInitNV" (LogV'Void)
#endif
    return _result

glVDPAUIsSurfaceNV :: MonadIO m => GL.GLvdpauSurfaceNV -> m GL.GLboolean
glVDPAUIsSurfaceNV surface = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUIsSurfaceNV" [LogV'GLvdpauSurfaceNV surface]
#endif
    _result <- GL.glVDPAUIsSurfaceNV surface
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUIsSurfaceNV" (LogV'GLboolean _result)
#endif
    return _result

glVDPAUMapSurfacesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLvdpauSurfaceNV -> m ()
glVDPAUMapSurfacesNV numSurfaces surfaces = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUMapSurfacesNV" [LogV'GLsizei numSurfaces, LogV'Ptr]
#endif
    _result <- GL.glVDPAUMapSurfacesNV numSurfaces surfaces
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUMapSurfacesNV" (LogV'Void)
#endif
    return _result

glVDPAURegisterOutputSurfaceNV :: MonadIO m => Ptr () -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> m GL.GLvdpauSurfaceNV
glVDPAURegisterOutputSurfaceNV vdpSurface target numTextureNames textureNames = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAURegisterOutputSurfaceNV" [LogV'Ptr, LogV'GLenum target, LogV'GLsizei numTextureNames, LogV'Ptr]
#endif
    _result <- GL.glVDPAURegisterOutputSurfaceNV vdpSurface target numTextureNames textureNames
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAURegisterOutputSurfaceNV" (LogV'GLvdpauSurfaceNV _result)
#endif
    return _result

glVDPAURegisterVideoSurfaceNV :: MonadIO m => Ptr () -> GL.GLenum -> GL.GLsizei -> Ptr GL.GLuint -> m GL.GLvdpauSurfaceNV
glVDPAURegisterVideoSurfaceNV vdpSurface target numTextureNames textureNames = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAURegisterVideoSurfaceNV" [LogV'Ptr, LogV'GLenum target, LogV'GLsizei numTextureNames, LogV'Ptr]
#endif
    _result <- GL.glVDPAURegisterVideoSurfaceNV vdpSurface target numTextureNames textureNames
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAURegisterVideoSurfaceNV" (LogV'GLvdpauSurfaceNV _result)
#endif
    return _result

glVDPAUSurfaceAccessNV :: MonadIO m => GL.GLvdpauSurfaceNV -> GL.GLenum -> m ()
glVDPAUSurfaceAccessNV surface access = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUSurfaceAccessNV" [LogV'GLvdpauSurfaceNV surface, LogV'GLenum access]
#endif
    _result <- GL.glVDPAUSurfaceAccessNV surface access
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUSurfaceAccessNV" (LogV'Void)
#endif
    return _result

glVDPAUUnmapSurfacesNV :: MonadIO m => GL.GLsizei -> Ptr GL.GLvdpauSurfaceNV -> m ()
glVDPAUUnmapSurfacesNV numSurface surfaces = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUUnmapSurfacesNV" [LogV'GLsizei numSurface, LogV'Ptr]
#endif
    _result <- GL.glVDPAUUnmapSurfacesNV numSurface surfaces
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUUnmapSurfacesNV" (LogV'Void)
#endif
    return _result

glVDPAUUnregisterSurfaceNV :: MonadIO m => GL.GLvdpauSurfaceNV -> m ()
glVDPAUUnregisterSurfaceNV surface = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVDPAUUnregisterSurfaceNV" [LogV'GLvdpauSurfaceNV surface]
#endif
    _result <- GL.glVDPAUUnregisterSurfaceNV surface
#ifdef GLW_DEBUG
    logGLCommandEnd "glVDPAUUnregisterSurfaceNV" (LogV'Void)
#endif
    return _result

glValidateProgram :: MonadIO m => Program -> m ()
glValidateProgram program = do
#ifdef GLW_DEBUG
    logGLCommandStart "glValidateProgram" [LogV'GLuint program]
#endif
    _result <- GL.glValidateProgram (coerce program)
#ifdef GLW_DEBUG
    logGLCommandEnd "glValidateProgram" (LogV'Void)
#endif
    return _result

glValidateProgramARB :: MonadIO m => GL.GLhandleARB -> m ()
glValidateProgramARB programObj = do
#ifdef GLW_DEBUG
    logGLCommandStart "glValidateProgramARB" [LogV'GLhandleARB programObj]
#endif
    _result <- GL.glValidateProgramARB programObj
#ifdef GLW_DEBUG
    logGLCommandEnd "glValidateProgramARB" (LogV'Void)
#endif
    return _result

glValidateProgramPipeline :: MonadIO m => ProgramPipeline -> m ()
glValidateProgramPipeline pipeline = do
#ifdef GLW_DEBUG
    logGLCommandStart "glValidateProgramPipeline" [LogV'GLuint pipeline]
#endif
    _result <- GL.glValidateProgramPipeline (coerce pipeline)
#ifdef GLW_DEBUG
    logGLCommandEnd "glValidateProgramPipeline" (LogV'Void)
#endif
    return _result

glVariantArrayObjectATI :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLsizei -> Buffer -> GL.GLuint -> m ()
glVariantArrayObjectATI id type' stride buffer offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantArrayObjectATI" [LogV'GLuint id, LogV'GLenum type', LogV'GLsizei stride, LogV'GLuint buffer, LogV'GLuint offset]
#endif
    _result <- GL.glVariantArrayObjectATI id type' stride (coerce buffer) offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantArrayObjectATI" (LogV'Void)
#endif
    return _result

glVariantPointerEXT :: MonadIO m => GL.GLuint -> GL.GLenum -> GL.GLuint -> Ptr () -> m ()
glVariantPointerEXT id type' stride addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantPointerEXT" [LogV'GLuint id, LogV'GLenum type', LogV'GLuint stride, LogV'Ptr]
#endif
    _result <- GL.glVariantPointerEXT id type' stride addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantPointerEXT" (LogV'Void)
#endif
    return _result

glVariantbvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLbyte -> m ()
glVariantbvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantbvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantbvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantbvEXT" (LogV'Void)
#endif
    return _result

glVariantdvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLdouble -> m ()
glVariantdvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantdvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantdvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantdvEXT" (LogV'Void)
#endif
    return _result

glVariantfvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLfloat -> m ()
glVariantfvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantfvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantfvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantfvEXT" (LogV'Void)
#endif
    return _result

glVariantivEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLint -> m ()
glVariantivEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantivEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantivEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantivEXT" (LogV'Void)
#endif
    return _result

glVariantsvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLshort -> m ()
glVariantsvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantsvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantsvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantsvEXT" (LogV'Void)
#endif
    return _result

glVariantubvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLubyte -> m ()
glVariantubvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantubvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantubvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantubvEXT" (LogV'Void)
#endif
    return _result

glVariantuivEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLuint -> m ()
glVariantuivEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantuivEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantuivEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantuivEXT" (LogV'Void)
#endif
    return _result

glVariantusvEXT :: MonadIO m => GL.GLuint -> Ptr GL.GLushort -> m ()
glVariantusvEXT id addr = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVariantusvEXT" [LogV'GLuint id, LogV'Ptr]
#endif
    _result <- GL.glVariantusvEXT id addr
#ifdef GLW_DEBUG
    logGLCommandEnd "glVariantusvEXT" (LogV'Void)
#endif
    return _result

glVertex2hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertex2hNV x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex2hNV" [LogV'GLhalfNV x, LogV'GLhalfNV y]
#endif
    _result <- GL.glVertex2hNV x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex2hNV" (LogV'Void)
#endif
    return _result

glVertex2hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glVertex2hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex2hvNV" [LogV'Ptr]
#endif
    _result <- GL.glVertex2hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex2hvNV" (LogV'Void)
#endif
    return _result

glVertex3hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertex3hNV x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex3hNV" [LogV'GLhalfNV x, LogV'GLhalfNV y, LogV'GLhalfNV z]
#endif
    _result <- GL.glVertex3hNV x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex3hNV" (LogV'Void)
#endif
    return _result

glVertex3hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glVertex3hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex3hvNV" [LogV'Ptr]
#endif
    _result <- GL.glVertex3hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex3hvNV" (LogV'Void)
#endif
    return _result

glVertex4hNV :: MonadIO m => GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertex4hNV x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex4hNV" [LogV'GLhalfNV x, LogV'GLhalfNV y, LogV'GLhalfNV z, LogV'GLhalfNV w]
#endif
    _result <- GL.glVertex4hNV x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex4hNV" (LogV'Void)
#endif
    return _result

glVertex4hvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glVertex4hvNV v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertex4hvNV" [LogV'Ptr]
#endif
    _result <- GL.glVertex4hvNV v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertex4hvNV" (LogV'Void)
#endif
    return _result

glVertexArrayAttribBinding :: MonadIO m => VertexArray -> AttribLocation -> BindingIndex -> m ()
glVertexArrayAttribBinding vaobj attribindex bindingindex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayAttribBinding" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLuint bindingindex]
#endif
    _result <- GL.glVertexArrayAttribBinding (coerce vaobj) (coerce attribindex) (coerce bindingindex)
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayAttribBinding" (LogV'Void)
#endif
    return _result

glVertexArrayAttribFormat :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLboolean -> GL.GLuint -> m ()
glVertexArrayAttribFormat vaobj attribindex size type' normalized relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayAttribFormat" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayAttribFormat (coerce vaobj) (coerce attribindex) size type' normalized relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayAttribFormat" (LogV'Void)
#endif
    return _result

glVertexArrayAttribIFormat :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexArrayAttribIFormat vaobj attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayAttribIFormat" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayAttribIFormat (coerce vaobj) (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayAttribIFormat" (LogV'Void)
#endif
    return _result

glVertexArrayAttribLFormat :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexArrayAttribLFormat vaobj attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayAttribLFormat" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayAttribLFormat (coerce vaobj) (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayAttribLFormat" (LogV'Void)
#endif
    return _result

glVertexArrayBindVertexBufferEXT :: MonadIO m => VertexArray -> BindingIndex -> Buffer -> GL.GLintptr -> GL.GLsizei -> m ()
glVertexArrayBindVertexBufferEXT vaobj bindingindex buffer offset stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayBindVertexBufferEXT" [LogV'GLuint vaobj, LogV'GLuint bindingindex, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizei stride]
#endif
    _result <- GL.glVertexArrayBindVertexBufferEXT (coerce vaobj) (coerce bindingindex) (coerce buffer) offset stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayBindVertexBufferEXT" (LogV'Void)
#endif
    return _result

glVertexArrayBindingDivisor :: MonadIO m => VertexArray -> BindingIndex -> GL.GLuint -> m ()
glVertexArrayBindingDivisor vaobj bindingindex divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayBindingDivisor" [LogV'GLuint vaobj, LogV'GLuint bindingindex, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexArrayBindingDivisor (coerce vaobj) (coerce bindingindex) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayBindingDivisor" (LogV'Void)
#endif
    return _result

glVertexArrayColorOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLint -> ColorPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayColorOffsetEXT vaobj buffer size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayColorOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayColorOffsetEXT (coerce vaobj) (coerce buffer) size (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayColorOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayEdgeFlagOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayEdgeFlagOffsetEXT vaobj buffer stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayEdgeFlagOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayEdgeFlagOffsetEXT (coerce vaobj) (coerce buffer) stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayEdgeFlagOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayElementBuffer :: MonadIO m => VertexArray -> Buffer -> m ()
glVertexArrayElementBuffer vaobj buffer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayElementBuffer" [LogV'GLuint vaobj, LogV'GLuint buffer]
#endif
    _result <- GL.glVertexArrayElementBuffer (coerce vaobj) (coerce buffer)
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayElementBuffer" (LogV'Void)
#endif
    return _result

glVertexArrayFogCoordOffsetEXT :: MonadIO m => VertexArray -> Buffer -> FogCoordinatePointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayFogCoordOffsetEXT vaobj buffer type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayFogCoordOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayFogCoordOffsetEXT (coerce vaobj) (coerce buffer) (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayFogCoordOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayIndexOffsetEXT :: MonadIO m => VertexArray -> Buffer -> IndexPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayIndexOffsetEXT vaobj buffer type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayIndexOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayIndexOffsetEXT (coerce vaobj) (coerce buffer) (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayIndexOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayMultiTexCoordOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLenum -> GL.GLint -> TexCoordPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayMultiTexCoordOffsetEXT vaobj buffer texunit size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayMultiTexCoordOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLenum texunit, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayMultiTexCoordOffsetEXT (coerce vaobj) (coerce buffer) texunit size (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayMultiTexCoordOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayNormalOffsetEXT :: MonadIO m => VertexArray -> Buffer -> NormalPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayNormalOffsetEXT vaobj buffer type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayNormalOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayNormalOffsetEXT (coerce vaobj) (coerce buffer) (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayNormalOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayParameteriAPPLE :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glVertexArrayParameteriAPPLE pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayParameteriAPPLE" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glVertexArrayParameteriAPPLE pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayParameteriAPPLE" (LogV'Void)
#endif
    return _result

glVertexArrayRangeAPPLE :: MonadIO m => GL.GLsizei -> Ptr () -> m ()
glVertexArrayRangeAPPLE length pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayRangeAPPLE" [LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glVertexArrayRangeAPPLE length pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayRangeAPPLE" (LogV'Void)
#endif
    return _result

glVertexArrayRangeNV :: MonadIO m => GL.GLsizei -> Ptr () -> m ()
glVertexArrayRangeNV length pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayRangeNV" [LogV'GLsizei length, LogV'Ptr]
#endif
    _result <- GL.glVertexArrayRangeNV length pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayRangeNV" (LogV'Void)
#endif
    return _result

glVertexArraySecondaryColorOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLint -> ColorPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArraySecondaryColorOffsetEXT vaobj buffer size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArraySecondaryColorOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArraySecondaryColorOffsetEXT (coerce vaobj) (coerce buffer) size (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArraySecondaryColorOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayTexCoordOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLint -> TexCoordPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayTexCoordOffsetEXT vaobj buffer size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayTexCoordOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayTexCoordOffsetEXT (coerce vaobj) (coerce buffer) size (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayTexCoordOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribBindingEXT :: MonadIO m => VertexArray -> AttribLocation -> BindingIndex -> m ()
glVertexArrayVertexAttribBindingEXT vaobj attribindex bindingindex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribBindingEXT" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLuint bindingindex]
#endif
    _result <- GL.glVertexArrayVertexAttribBindingEXT (coerce vaobj) (coerce attribindex) (coerce bindingindex)
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribBindingEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribDivisorEXT :: MonadIO m => VertexArray -> AttribLocation -> GL.GLuint -> m ()
glVertexArrayVertexAttribDivisorEXT vaobj index divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribDivisorEXT" [LogV'GLuint vaobj, LogV'GLuint index, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexArrayVertexAttribDivisorEXT (coerce vaobj) (coerce index) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribDivisorEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribFormatEXT :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexArrayVertexAttribFormatEXT vaobj attribindex size type' normalized relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribFormatEXT" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayVertexAttribFormatEXT (coerce vaobj) (coerce attribindex) size type' (coerce normalized) relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribFormatEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribIFormatEXT :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexArrayVertexAttribIFormatEXT vaobj attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribIFormatEXT" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayVertexAttribIFormatEXT (coerce vaobj) (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribIFormatEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribIOffsetEXT :: MonadIO m => VertexArray -> Buffer -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayVertexAttribIOffsetEXT vaobj buffer index size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribIOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayVertexAttribIOffsetEXT (coerce vaobj) (coerce buffer) (coerce index) size type' stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribIOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribLFormatEXT :: MonadIO m => VertexArray -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexArrayVertexAttribLFormatEXT vaobj attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribLFormatEXT" [LogV'GLuint vaobj, LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexArrayVertexAttribLFormatEXT (coerce vaobj) (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribLFormatEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribLOffsetEXT :: MonadIO m => VertexArray -> Buffer -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayVertexAttribLOffsetEXT vaobj buffer index size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribLOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayVertexAttribLOffsetEXT (coerce vaobj) (coerce buffer) (coerce index) size type' stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribLOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexAttribOffsetEXT :: MonadIO m => VertexArray -> Buffer -> AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLboolean -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayVertexAttribOffsetEXT vaobj buffer index size type' normalized stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexAttribOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayVertexAttribOffsetEXT (coerce vaobj) (coerce buffer) (coerce index) size type' normalized stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexAttribOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexBindingDivisorEXT :: MonadIO m => VertexArray -> BindingIndex -> GL.GLuint -> m ()
glVertexArrayVertexBindingDivisorEXT vaobj bindingindex divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexBindingDivisorEXT" [LogV'GLuint vaobj, LogV'GLuint bindingindex, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexArrayVertexBindingDivisorEXT (coerce vaobj) (coerce bindingindex) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexBindingDivisorEXT" (LogV'Void)
#endif
    return _result

glVertexArrayVertexBuffer :: MonadIO m => VertexArray -> BindingIndex -> Buffer -> GL.GLintptr -> GL.GLsizei -> m ()
glVertexArrayVertexBuffer vaobj bindingindex buffer offset stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexBuffer" [LogV'GLuint vaobj, LogV'GLuint bindingindex, LogV'GLuint buffer, LogV'GLintptr offset, LogV'GLsizei stride]
#endif
    _result <- GL.glVertexArrayVertexBuffer (coerce vaobj) (coerce bindingindex) (coerce buffer) offset stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexBuffer" (LogV'Void)
#endif
    return _result

glVertexArrayVertexBuffers :: MonadIO m => VertexArray -> GL.GLuint -> GL.GLsizei -> Ptr Buffer -> Ptr GL.GLintptr -> Ptr GL.GLsizei -> m ()
glVertexArrayVertexBuffers vaobj first count buffers offsets strides = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexBuffers" [LogV'GLuint vaobj, LogV'GLuint first, LogV'GLsizei count, LogV'Ptr, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glVertexArrayVertexBuffers (coerce vaobj) first count (coerce buffers) offsets strides
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexBuffers" (LogV'Void)
#endif
    return _result

glVertexArrayVertexOffsetEXT :: MonadIO m => VertexArray -> Buffer -> GL.GLint -> VertexPointerType -> GL.GLsizei -> GL.GLintptr -> m ()
glVertexArrayVertexOffsetEXT vaobj buffer size type' stride offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexArrayVertexOffsetEXT" [LogV'GLuint vaobj, LogV'GLuint buffer, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLintptr offset]
#endif
    _result <- GL.glVertexArrayVertexOffsetEXT (coerce vaobj) (coerce buffer) size (coerce type') stride offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexArrayVertexOffsetEXT" (LogV'Void)
#endif
    return _result

glVertexAttrib1d :: MonadIO m => AttribLocation -> GL.GLdouble -> m ()
glVertexAttrib1d index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1d" [LogV'GLuint index, LogV'GLdouble x]
#endif
    _result <- GL.glVertexAttrib1d (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1d" (LogV'Void)
#endif
    return _result

glVertexAttrib1dARB :: MonadIO m => AttribLocation -> GL.GLdouble -> m ()
glVertexAttrib1dARB index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1dARB" [LogV'GLuint index, LogV'GLdouble x]
#endif
    _result <- GL.glVertexAttrib1dARB (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1dARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1dNV :: MonadIO m => AttribLocation -> GL.GLdouble -> m ()
glVertexAttrib1dNV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1dNV" [LogV'GLuint index, LogV'GLdouble x]
#endif
    _result <- GL.glVertexAttrib1dNV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1dNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib1dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1dv" (LogV'Void)
#endif
    return _result

glVertexAttrib1dvARB :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib1dvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1dvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1dvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1dvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1dvNV :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib1dvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1dvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1dvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1dvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1f :: MonadIO m => AttribLocation -> GL.GLfloat -> m ()
glVertexAttrib1f index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1f" [LogV'GLuint index, LogV'GLfloat x]
#endif
    _result <- GL.glVertexAttrib1f (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1f" (LogV'Void)
#endif
    return _result

glVertexAttrib1fARB :: MonadIO m => AttribLocation -> GL.GLfloat -> m ()
glVertexAttrib1fARB index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1fARB" [LogV'GLuint index, LogV'GLfloat x]
#endif
    _result <- GL.glVertexAttrib1fARB (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1fARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1fNV :: MonadIO m => AttribLocation -> GL.GLfloat -> m ()
glVertexAttrib1fNV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1fNV" [LogV'GLuint index, LogV'GLfloat x]
#endif
    _result <- GL.glVertexAttrib1fNV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1fNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1fv :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib1fv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1fv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1fv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1fv" (LogV'Void)
#endif
    return _result

glVertexAttrib1fvARB :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib1fvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1fvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1fvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1fvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1fvNV :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib1fvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1fvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1fvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1fvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1hNV :: MonadIO m => AttribLocation -> GL.GLhalfNV -> m ()
glVertexAttrib1hNV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1hNV" [LogV'GLuint index, LogV'GLhalfNV x]
#endif
    _result <- GL.glVertexAttrib1hNV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1hNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1hvNV :: MonadIO m => AttribLocation -> Ptr GL.GLhalfNV -> m ()
glVertexAttrib1hvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1hvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1hvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1hvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1s :: MonadIO m => AttribLocation -> GL.GLshort -> m ()
glVertexAttrib1s index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1s" [LogV'GLuint index, LogV'GLshort x]
#endif
    _result <- GL.glVertexAttrib1s (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1s" (LogV'Void)
#endif
    return _result

glVertexAttrib1sARB :: MonadIO m => AttribLocation -> GL.GLshort -> m ()
glVertexAttrib1sARB index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1sARB" [LogV'GLuint index, LogV'GLshort x]
#endif
    _result <- GL.glVertexAttrib1sARB (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1sARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1sNV :: MonadIO m => AttribLocation -> GL.GLshort -> m ()
glVertexAttrib1sNV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1sNV" [LogV'GLuint index, LogV'GLshort x]
#endif
    _result <- GL.glVertexAttrib1sNV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1sNV" (LogV'Void)
#endif
    return _result

glVertexAttrib1sv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib1sv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1sv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1sv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1sv" (LogV'Void)
#endif
    return _result

glVertexAttrib1svARB :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib1svARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1svARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1svARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1svARB" (LogV'Void)
#endif
    return _result

glVertexAttrib1svNV :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib1svNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib1svNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib1svNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib1svNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib2d index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexAttrib2d (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2d" (LogV'Void)
#endif
    return _result

glVertexAttrib2dARB :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib2dARB index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2dARB" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexAttrib2dARB (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2dARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2dNV :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib2dNV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2dNV" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexAttrib2dNV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2dNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib2dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2dv" (LogV'Void)
#endif
    return _result

glVertexAttrib2dvARB :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib2dvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2dvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2dvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2dvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2dvNV :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib2dvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2dvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2dvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2dvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2f :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib2f index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2f" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glVertexAttrib2f (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2f" (LogV'Void)
#endif
    return _result

glVertexAttrib2fARB :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib2fARB index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2fARB" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glVertexAttrib2fARB (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2fARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2fNV :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib2fNV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2fNV" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glVertexAttrib2fNV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2fNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2fv :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib2fv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2fv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2fv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2fv" (LogV'Void)
#endif
    return _result

glVertexAttrib2fvARB :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib2fvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2fvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2fvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2fvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2fvNV :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib2fvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2fvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2fvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2fvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2hNV :: MonadIO m => AttribLocation -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertexAttrib2hNV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2hNV" [LogV'GLuint index, LogV'GLhalfNV x, LogV'GLhalfNV y]
#endif
    _result <- GL.glVertexAttrib2hNV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2hNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2hvNV :: MonadIO m => AttribLocation -> Ptr GL.GLhalfNV -> m ()
glVertexAttrib2hvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2hvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2hvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2hvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2s :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib2s index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2s" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glVertexAttrib2s (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2s" (LogV'Void)
#endif
    return _result

glVertexAttrib2sARB :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib2sARB index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2sARB" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glVertexAttrib2sARB (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2sARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2sNV :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib2sNV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2sNV" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glVertexAttrib2sNV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2sNV" (LogV'Void)
#endif
    return _result

glVertexAttrib2sv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib2sv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2sv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2sv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2sv" (LogV'Void)
#endif
    return _result

glVertexAttrib2svARB :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib2svARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2svARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2svARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2svARB" (LogV'Void)
#endif
    return _result

glVertexAttrib2svNV :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib2svNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib2svNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib2svNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib2svNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib3d index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexAttrib3d (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3d" (LogV'Void)
#endif
    return _result

glVertexAttrib3dARB :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib3dARB index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3dARB" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexAttrib3dARB (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3dARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3dNV :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib3dNV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3dNV" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexAttrib3dNV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3dNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib3dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3dv" (LogV'Void)
#endif
    return _result

glVertexAttrib3dvARB :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib3dvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3dvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3dvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3dvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3dvNV :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib3dvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3dvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3dvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3dvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3f :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib3f index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3f" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glVertexAttrib3f (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3f" (LogV'Void)
#endif
    return _result

glVertexAttrib3fARB :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib3fARB index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3fARB" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glVertexAttrib3fARB (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3fARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3fNV :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib3fNV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3fNV" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glVertexAttrib3fNV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3fNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3fv :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib3fv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3fv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3fv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3fv" (LogV'Void)
#endif
    return _result

glVertexAttrib3fvARB :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib3fvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3fvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3fvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3fvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3fvNV :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib3fvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3fvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3fvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3fvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3hNV :: MonadIO m => AttribLocation -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertexAttrib3hNV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3hNV" [LogV'GLuint index, LogV'GLhalfNV x, LogV'GLhalfNV y, LogV'GLhalfNV z]
#endif
    _result <- GL.glVertexAttrib3hNV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3hNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3hvNV :: MonadIO m => AttribLocation -> Ptr GL.GLhalfNV -> m ()
glVertexAttrib3hvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3hvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3hvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3hvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3s :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib3s index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3s" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glVertexAttrib3s (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3s" (LogV'Void)
#endif
    return _result

glVertexAttrib3sARB :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib3sARB index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3sARB" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glVertexAttrib3sARB (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3sARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3sNV :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib3sNV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3sNV" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glVertexAttrib3sNV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3sNV" (LogV'Void)
#endif
    return _result

glVertexAttrib3sv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib3sv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3sv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3sv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3sv" (LogV'Void)
#endif
    return _result

glVertexAttrib3svARB :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib3svARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3svARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3svARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3svARB" (LogV'Void)
#endif
    return _result

glVertexAttrib3svNV :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib3svNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib3svNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib3svNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib3svNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nbv :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttrib4Nbv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nbv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Nbv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nbv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NbvARB :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttrib4NbvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NbvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NbvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NbvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Niv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttrib4Niv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Niv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Niv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Niv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NivARB :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttrib4NivARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NivARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NivARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NivARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nsv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib4Nsv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nsv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Nsv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nsv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NsvARB :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib4NsvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NsvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NsvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NsvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nub :: MonadIO m => AttribLocation -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> m ()
glVertexAttrib4Nub index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nub" [LogV'GLuint index, LogV'GLubyte x, LogV'GLubyte y, LogV'GLubyte z, LogV'GLubyte w]
#endif
    _result <- GL.glVertexAttrib4Nub (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nub" (LogV'Void)
#endif
    return _result

glVertexAttrib4NubARB :: MonadIO m => AttribLocation -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> m ()
glVertexAttrib4NubARB index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NubARB" [LogV'GLuint index, LogV'GLubyte x, LogV'GLubyte y, LogV'GLubyte z, LogV'GLubyte w]
#endif
    _result <- GL.glVertexAttrib4NubARB (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NubARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nubv :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttrib4Nubv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nubv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Nubv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nubv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NubvARB :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttrib4NubvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NubvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NubvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NubvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nuiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttrib4Nuiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nuiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Nuiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nuiv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NuivARB :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttrib4NuivARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NuivARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NuivARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NuivARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4Nusv :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttrib4Nusv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4Nusv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4Nusv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4Nusv" (LogV'Void)
#endif
    return _result

glVertexAttrib4NusvARB :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttrib4NusvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4NusvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4NusvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4NusvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4bv :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttrib4bv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4bv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4bv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4bv" (LogV'Void)
#endif
    return _result

glVertexAttrib4bvARB :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttrib4bvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4bvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4bvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4bvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib4d index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexAttrib4d (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4d" (LogV'Void)
#endif
    return _result

glVertexAttrib4dARB :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib4dARB index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4dARB" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexAttrib4dARB (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4dARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4dNV :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttrib4dNV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4dNV" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexAttrib4dNV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4dNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib4dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4dv" (LogV'Void)
#endif
    return _result

glVertexAttrib4dvARB :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib4dvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4dvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4dvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4dvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4dvNV :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttrib4dvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4dvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4dvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4dvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4f :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib4f index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4f" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glVertexAttrib4f (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4f" (LogV'Void)
#endif
    return _result

glVertexAttrib4fARB :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib4fARB index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4fARB" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glVertexAttrib4fARB (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4fARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4fNV :: MonadIO m => AttribLocation -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexAttrib4fNV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4fNV" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glVertexAttrib4fNV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4fNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4fv :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib4fv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4fv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4fv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4fv" (LogV'Void)
#endif
    return _result

glVertexAttrib4fvARB :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib4fvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4fvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4fvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4fvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4fvNV :: MonadIO m => AttribLocation -> Ptr GL.GLfloat -> m ()
glVertexAttrib4fvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4fvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4fvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4fvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4hNV :: MonadIO m => AttribLocation -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> GL.GLhalfNV -> m ()
glVertexAttrib4hNV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4hNV" [LogV'GLuint index, LogV'GLhalfNV x, LogV'GLhalfNV y, LogV'GLhalfNV z, LogV'GLhalfNV w]
#endif
    _result <- GL.glVertexAttrib4hNV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4hNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4hvNV :: MonadIO m => AttribLocation -> Ptr GL.GLhalfNV -> m ()
glVertexAttrib4hvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4hvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4hvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4hvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4iv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttrib4iv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4iv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4iv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4iv" (LogV'Void)
#endif
    return _result

glVertexAttrib4ivARB :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttrib4ivARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4ivARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4ivARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4ivARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4s :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib4s index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4s" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z, LogV'GLshort w]
#endif
    _result <- GL.glVertexAttrib4s (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4s" (LogV'Void)
#endif
    return _result

glVertexAttrib4sARB :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib4sARB index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4sARB" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z, LogV'GLshort w]
#endif
    _result <- GL.glVertexAttrib4sARB (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4sARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4sNV :: MonadIO m => AttribLocation -> GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexAttrib4sNV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4sNV" [LogV'GLuint index, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z, LogV'GLshort w]
#endif
    _result <- GL.glVertexAttrib4sNV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4sNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4sv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib4sv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4sv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4sv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4sv" (LogV'Void)
#endif
    return _result

glVertexAttrib4svARB :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib4svARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4svARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4svARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4svARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4svNV :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttrib4svNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4svNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4svNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4svNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4ubNV :: MonadIO m => AttribLocation -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> GL.GLubyte -> m ()
glVertexAttrib4ubNV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4ubNV" [LogV'GLuint index, LogV'GLubyte x, LogV'GLubyte y, LogV'GLubyte z, LogV'GLubyte w]
#endif
    _result <- GL.glVertexAttrib4ubNV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4ubNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4ubv :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttrib4ubv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4ubv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4ubv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4ubv" (LogV'Void)
#endif
    return _result

glVertexAttrib4ubvARB :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttrib4ubvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4ubvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4ubvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4ubvARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4ubvNV :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttrib4ubvNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4ubvNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4ubvNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4ubvNV" (LogV'Void)
#endif
    return _result

glVertexAttrib4uiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttrib4uiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4uiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4uiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4uiv" (LogV'Void)
#endif
    return _result

glVertexAttrib4uivARB :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttrib4uivARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4uivARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4uivARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4uivARB" (LogV'Void)
#endif
    return _result

glVertexAttrib4usv :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttrib4usv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4usv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4usv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4usv" (LogV'Void)
#endif
    return _result

glVertexAttrib4usvARB :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttrib4usvARB index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttrib4usvARB" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttrib4usvARB (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttrib4usvARB" (LogV'Void)
#endif
    return _result

glVertexAttribArrayObjectATI :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLsizei -> Buffer -> GL.GLuint -> m ()
glVertexAttribArrayObjectATI index size type' normalized stride buffer offset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribArrayObjectATI" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLsizei stride, LogV'GLuint buffer, LogV'GLuint offset]
#endif
    _result <- GL.glVertexAttribArrayObjectATI (coerce index) size type' (coerce normalized) stride (coerce buffer) offset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribArrayObjectATI" (LogV'Void)
#endif
    return _result

glVertexAttribBinding :: MonadIO m => AttribLocation -> BindingIndex -> m ()
glVertexAttribBinding attribindex bindingindex = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribBinding" [LogV'GLuint attribindex, LogV'GLuint bindingindex]
#endif
    _result <- GL.glVertexAttribBinding (coerce attribindex) (coerce bindingindex)
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribBinding" (LogV'Void)
#endif
    return _result

glVertexAttribDivisor :: MonadIO m => AttribLocation -> GL.GLuint -> m ()
glVertexAttribDivisor index divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribDivisor" [LogV'GLuint index, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexAttribDivisor (coerce index) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribDivisor" (LogV'Void)
#endif
    return _result

glVertexAttribDivisorARB :: MonadIO m => AttribLocation -> GL.GLuint -> m ()
glVertexAttribDivisorARB index divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribDivisorARB" [LogV'GLuint index, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexAttribDivisorARB (coerce index) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribDivisorARB" (LogV'Void)
#endif
    return _result

glVertexAttribFormat :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexAttribFormat attribindex size type' normalized relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribFormat" [LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexAttribFormat (coerce attribindex) size type' (coerce normalized) relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribFormat" (LogV'Void)
#endif
    return _result

glVertexAttribFormatNV :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLsizei -> m ()
glVertexAttribFormatNV index size type' normalized stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribFormatNV" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLsizei stride]
#endif
    _result <- GL.glVertexAttribFormatNV (coerce index) size type' (coerce normalized) stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribFormatNV" (LogV'Void)
#endif
    return _result

glVertexAttribI1i :: MonadIO m => AttribLocation -> GL.GLint -> m ()
glVertexAttribI1i index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1i" [LogV'GLuint index, LogV'GLint x]
#endif
    _result <- GL.glVertexAttribI1i (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1i" (LogV'Void)
#endif
    return _result

glVertexAttribI1iEXT :: MonadIO m => AttribLocation -> GL.GLint -> m ()
glVertexAttribI1iEXT index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1iEXT" [LogV'GLuint index, LogV'GLint x]
#endif
    _result <- GL.glVertexAttribI1iEXT (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1iEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI1iv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI1iv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1iv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI1iv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1iv" (LogV'Void)
#endif
    return _result

glVertexAttribI1ivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI1ivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1ivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI1ivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1ivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI1ui :: MonadIO m => AttribLocation -> GL.GLuint -> m ()
glVertexAttribI1ui index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1ui" [LogV'GLuint index, LogV'GLuint x]
#endif
    _result <- GL.glVertexAttribI1ui (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1ui" (LogV'Void)
#endif
    return _result

glVertexAttribI1uiEXT :: MonadIO m => AttribLocation -> GL.GLuint -> m ()
glVertexAttribI1uiEXT index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1uiEXT" [LogV'GLuint index, LogV'GLuint x]
#endif
    _result <- GL.glVertexAttribI1uiEXT (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1uiEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI1uiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI1uiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1uiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI1uiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1uiv" (LogV'Void)
#endif
    return _result

glVertexAttribI1uivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI1uivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI1uivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI1uivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI1uivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI2i :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI2i index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2i" [LogV'GLuint index, LogV'GLint x, LogV'GLint y]
#endif
    _result <- GL.glVertexAttribI2i (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2i" (LogV'Void)
#endif
    return _result

glVertexAttribI2iEXT :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI2iEXT index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2iEXT" [LogV'GLuint index, LogV'GLint x, LogV'GLint y]
#endif
    _result <- GL.glVertexAttribI2iEXT (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2iEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI2iv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI2iv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2iv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI2iv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2iv" (LogV'Void)
#endif
    return _result

glVertexAttribI2ivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI2ivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2ivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI2ivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2ivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI2ui :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI2ui index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2ui" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y]
#endif
    _result <- GL.glVertexAttribI2ui (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2ui" (LogV'Void)
#endif
    return _result

glVertexAttribI2uiEXT :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI2uiEXT index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2uiEXT" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y]
#endif
    _result <- GL.glVertexAttribI2uiEXT (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2uiEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI2uiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI2uiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2uiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI2uiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2uiv" (LogV'Void)
#endif
    return _result

glVertexAttribI2uivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI2uivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI2uivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI2uivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI2uivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI3i :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI3i index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3i" [LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z]
#endif
    _result <- GL.glVertexAttribI3i (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3i" (LogV'Void)
#endif
    return _result

glVertexAttribI3iEXT :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI3iEXT index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3iEXT" [LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z]
#endif
    _result <- GL.glVertexAttribI3iEXT (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3iEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI3iv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI3iv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3iv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI3iv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3iv" (LogV'Void)
#endif
    return _result

glVertexAttribI3ivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI3ivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3ivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI3ivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3ivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI3ui :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI3ui index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3ui" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z]
#endif
    _result <- GL.glVertexAttribI3ui (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3ui" (LogV'Void)
#endif
    return _result

glVertexAttribI3uiEXT :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI3uiEXT index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3uiEXT" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z]
#endif
    _result <- GL.glVertexAttribI3uiEXT (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3uiEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI3uiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI3uiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3uiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI3uiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3uiv" (LogV'Void)
#endif
    return _result

glVertexAttribI3uivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI3uivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI3uivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI3uivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI3uivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4bv :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttribI4bv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4bv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4bv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4bv" (LogV'Void)
#endif
    return _result

glVertexAttribI4bvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLbyte -> m ()
glVertexAttribI4bvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4bvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4bvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4bvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4i :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI4i index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4i" [LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glVertexAttribI4i (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4i" (LogV'Void)
#endif
    return _result

glVertexAttribI4iEXT :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexAttribI4iEXT index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4iEXT" [LogV'GLuint index, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glVertexAttribI4iEXT (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4iEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4iv :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI4iv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4iv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4iv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4iv" (LogV'Void)
#endif
    return _result

glVertexAttribI4ivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLint -> m ()
glVertexAttribI4ivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4ivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4ivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4ivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4sv :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttribI4sv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4sv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4sv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4sv" (LogV'Void)
#endif
    return _result

glVertexAttribI4svEXT :: MonadIO m => AttribLocation -> Ptr GL.GLshort -> m ()
glVertexAttribI4svEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4svEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4svEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4svEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4ubv :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttribI4ubv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4ubv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4ubv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4ubv" (LogV'Void)
#endif
    return _result

glVertexAttribI4ubvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLubyte -> m ()
glVertexAttribI4ubvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4ubvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4ubvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4ubvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4ui :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI4ui index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4ui" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z, LogV'GLuint w]
#endif
    _result <- GL.glVertexAttribI4ui (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4ui" (LogV'Void)
#endif
    return _result

glVertexAttribI4uiEXT :: MonadIO m => AttribLocation -> GL.GLuint -> GL.GLuint -> GL.GLuint -> GL.GLuint -> m ()
glVertexAttribI4uiEXT index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4uiEXT" [LogV'GLuint index, LogV'GLuint x, LogV'GLuint y, LogV'GLuint z, LogV'GLuint w]
#endif
    _result <- GL.glVertexAttribI4uiEXT (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4uiEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4uiv :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI4uiv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4uiv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4uiv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4uiv" (LogV'Void)
#endif
    return _result

glVertexAttribI4uivEXT :: MonadIO m => AttribLocation -> Ptr GL.GLuint -> m ()
glVertexAttribI4uivEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4uivEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4uivEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4uivEXT" (LogV'Void)
#endif
    return _result

glVertexAttribI4usv :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttribI4usv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4usv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4usv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4usv" (LogV'Void)
#endif
    return _result

glVertexAttribI4usvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLushort -> m ()
glVertexAttribI4usvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribI4usvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribI4usvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribI4usvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribIFormat :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexAttribIFormat attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribIFormat" [LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexAttribIFormat (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribIFormat" (LogV'Void)
#endif
    return _result

glVertexAttribIFormatNV :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glVertexAttribIFormatNV index size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribIFormatNV" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glVertexAttribIFormatNV (coerce index) size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribIFormatNV" (LogV'Void)
#endif
    return _result

glVertexAttribIPointer :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribIPointer index size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribIPointer" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribIPointer (coerce index) size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribIPointer" (LogV'Void)
#endif
    return _result

glVertexAttribIPointerEXT :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribIPointerEXT index size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribIPointerEXT" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribIPointerEXT (coerce index) size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribIPointerEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL1d :: MonadIO m => AttribLocation -> GL.GLdouble -> m ()
glVertexAttribL1d index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1d" [LogV'GLuint index, LogV'GLdouble x]
#endif
    _result <- GL.glVertexAttribL1d (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1d" (LogV'Void)
#endif
    return _result

glVertexAttribL1dEXT :: MonadIO m => AttribLocation -> GL.GLdouble -> m ()
glVertexAttribL1dEXT index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1dEXT" [LogV'GLuint index, LogV'GLdouble x]
#endif
    _result <- GL.glVertexAttribL1dEXT (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1dEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL1dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL1dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL1dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1dv" (LogV'Void)
#endif
    return _result

glVertexAttribL1dvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL1dvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1dvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL1dvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1dvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL1i64NV :: MonadIO m => AttribLocation -> GL.GLint64EXT -> m ()
glVertexAttribL1i64NV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1i64NV" [LogV'GLuint index, LogV'GLint64EXT x]
#endif
    _result <- GL.glVertexAttribL1i64NV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1i64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL1i64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLint64EXT -> m ()
glVertexAttribL1i64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1i64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL1i64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1i64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL1ui64NV :: MonadIO m => AttribLocation -> GL.GLuint64EXT -> m ()
glVertexAttribL1ui64NV index x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1ui64NV" [LogV'GLuint index, LogV'GLuint64EXT x]
#endif
    _result <- GL.glVertexAttribL1ui64NV (coerce index) x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1ui64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL1ui64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLuint64EXT -> m ()
glVertexAttribL1ui64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL1ui64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL1ui64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL1ui64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL2d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL2d index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexAttribL2d (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2d" (LogV'Void)
#endif
    return _result

glVertexAttribL2dEXT :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL2dEXT index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2dEXT" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexAttribL2dEXT (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2dEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL2dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL2dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL2dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2dv" (LogV'Void)
#endif
    return _result

glVertexAttribL2dvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL2dvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2dvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL2dvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2dvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL2i64NV :: MonadIO m => AttribLocation -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glVertexAttribL2i64NV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2i64NV" [LogV'GLuint index, LogV'GLint64EXT x, LogV'GLint64EXT y]
#endif
    _result <- GL.glVertexAttribL2i64NV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2i64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL2i64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLint64EXT -> m ()
glVertexAttribL2i64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2i64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL2i64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2i64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL2ui64NV :: MonadIO m => AttribLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glVertexAttribL2ui64NV index x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2ui64NV" [LogV'GLuint index, LogV'GLuint64EXT x, LogV'GLuint64EXT y]
#endif
    _result <- GL.glVertexAttribL2ui64NV (coerce index) x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2ui64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL2ui64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLuint64EXT -> m ()
glVertexAttribL2ui64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL2ui64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL2ui64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL2ui64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL3d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL3d index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexAttribL3d (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3d" (LogV'Void)
#endif
    return _result

glVertexAttribL3dEXT :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL3dEXT index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3dEXT" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexAttribL3dEXT (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3dEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL3dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL3dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL3dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3dv" (LogV'Void)
#endif
    return _result

glVertexAttribL3dvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL3dvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3dvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL3dvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3dvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL3i64NV :: MonadIO m => AttribLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glVertexAttribL3i64NV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3i64NV" [LogV'GLuint index, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z]
#endif
    _result <- GL.glVertexAttribL3i64NV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3i64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL3i64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLint64EXT -> m ()
glVertexAttribL3i64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3i64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL3i64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3i64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL3ui64NV :: MonadIO m => AttribLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glVertexAttribL3ui64NV index x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3ui64NV" [LogV'GLuint index, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z]
#endif
    _result <- GL.glVertexAttribL3ui64NV (coerce index) x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3ui64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL3ui64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLuint64EXT -> m ()
glVertexAttribL3ui64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL3ui64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL3ui64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL3ui64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL4d :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL4d index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4d" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexAttribL4d (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4d" (LogV'Void)
#endif
    return _result

glVertexAttribL4dEXT :: MonadIO m => AttribLocation -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexAttribL4dEXT index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4dEXT" [LogV'GLuint index, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexAttribL4dEXT (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4dEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL4dv :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL4dv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4dv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL4dv (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4dv" (LogV'Void)
#endif
    return _result

glVertexAttribL4dvEXT :: MonadIO m => AttribLocation -> Ptr GL.GLdouble -> m ()
glVertexAttribL4dvEXT index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4dvEXT" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL4dvEXT (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4dvEXT" (LogV'Void)
#endif
    return _result

glVertexAttribL4i64NV :: MonadIO m => AttribLocation -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> GL.GLint64EXT -> m ()
glVertexAttribL4i64NV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4i64NV" [LogV'GLuint index, LogV'GLint64EXT x, LogV'GLint64EXT y, LogV'GLint64EXT z, LogV'GLint64EXT w]
#endif
    _result <- GL.glVertexAttribL4i64NV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4i64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL4i64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLint64EXT -> m ()
glVertexAttribL4i64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4i64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL4i64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4i64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribL4ui64NV :: MonadIO m => AttribLocation -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> GL.GLuint64EXT -> m ()
glVertexAttribL4ui64NV index x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4ui64NV" [LogV'GLuint index, LogV'GLuint64EXT x, LogV'GLuint64EXT y, LogV'GLuint64EXT z, LogV'GLuint64EXT w]
#endif
    _result <- GL.glVertexAttribL4ui64NV (coerce index) x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4ui64NV" (LogV'Void)
#endif
    return _result

glVertexAttribL4ui64vNV :: MonadIO m => AttribLocation -> Ptr GL.GLuint64EXT -> m ()
glVertexAttribL4ui64vNV index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribL4ui64vNV" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribL4ui64vNV (coerce index) v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribL4ui64vNV" (LogV'Void)
#endif
    return _result

glVertexAttribLFormat :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLuint -> m ()
glVertexAttribLFormat attribindex size type' relativeoffset = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribLFormat" [LogV'GLuint attribindex, LogV'GLint size, LogV'GLenum type', LogV'GLuint relativeoffset]
#endif
    _result <- GL.glVertexAttribLFormat (coerce attribindex) size type' relativeoffset
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribLFormat" (LogV'Void)
#endif
    return _result

glVertexAttribLFormatNV :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glVertexAttribLFormatNV index size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribLFormatNV" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glVertexAttribLFormatNV (coerce index) size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribLFormatNV" (LogV'Void)
#endif
    return _result

glVertexAttribLPointer :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribLPointer index size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribLPointer" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribLPointer (coerce index) size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribLPointer" (LogV'Void)
#endif
    return _result

glVertexAttribLPointerEXT :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribLPointerEXT index size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribLPointerEXT" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribLPointerEXT (coerce index) size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribLPointerEXT" (LogV'Void)
#endif
    return _result

glVertexAttribP1ui :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexAttribP1ui index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP1ui" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint value]
#endif
    _result <- GL.glVertexAttribP1ui (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP1ui" (LogV'Void)
#endif
    return _result

glVertexAttribP1uiv :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> Ptr GL.GLuint -> m ()
glVertexAttribP1uiv index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP1uiv" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribP1uiv (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP1uiv" (LogV'Void)
#endif
    return _result

glVertexAttribP2ui :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexAttribP2ui index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP2ui" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint value]
#endif
    _result <- GL.glVertexAttribP2ui (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP2ui" (LogV'Void)
#endif
    return _result

glVertexAttribP2uiv :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> Ptr GL.GLuint -> m ()
glVertexAttribP2uiv index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP2uiv" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribP2uiv (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP2uiv" (LogV'Void)
#endif
    return _result

glVertexAttribP3ui :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexAttribP3ui index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP3ui" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint value]
#endif
    _result <- GL.glVertexAttribP3ui (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP3ui" (LogV'Void)
#endif
    return _result

glVertexAttribP3uiv :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> Ptr GL.GLuint -> m ()
glVertexAttribP3uiv index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP3uiv" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribP3uiv (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP3uiv" (LogV'Void)
#endif
    return _result

glVertexAttribP4ui :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> GL.GLuint -> m ()
glVertexAttribP4ui index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP4ui" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLuint value]
#endif
    _result <- GL.glVertexAttribP4ui (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP4ui" (LogV'Void)
#endif
    return _result

glVertexAttribP4uiv :: MonadIO m => AttribLocation -> GL.GLenum -> Boolean -> Ptr GL.GLuint -> m ()
glVertexAttribP4uiv index type' normalized value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribP4uiv" [LogV'GLuint index, LogV'GLenum type', LogV'GLboolean normalized, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribP4uiv (coerce index) type' (coerce normalized) value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribP4uiv" (LogV'Void)
#endif
    return _result

glVertexAttribParameteriAMD :: MonadIO m => AttribLocation -> GL.GLenum -> GL.GLint -> m ()
glVertexAttribParameteriAMD index pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribParameteriAMD" [LogV'GLuint index, LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glVertexAttribParameteriAMD (coerce index) pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribParameteriAMD" (LogV'Void)
#endif
    return _result

glVertexAttribPointer :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribPointer index size type' normalized stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribPointer" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribPointer (coerce index) size type' (coerce normalized) stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribPointer" (LogV'Void)
#endif
    return _result

glVertexAttribPointerARB :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> Boolean -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribPointerARB index size type' normalized stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribPointerARB" [LogV'GLuint index, LogV'GLint size, LogV'GLenum type', LogV'GLboolean normalized, LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribPointerARB (coerce index) size type' (coerce normalized) stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribPointerARB" (LogV'Void)
#endif
    return _result

glVertexAttribPointerNV :: MonadIO m => AttribLocation -> GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexAttribPointerNV index fsize type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribPointerNV" [LogV'GLuint index, LogV'GLint fsize, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribPointerNV (coerce index) fsize type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribPointerNV" (LogV'Void)
#endif
    return _result

glVertexAttribs1dvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glVertexAttribs1dvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs1dvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs1dvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs1dvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs1fvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glVertexAttribs1fvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs1fvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs1fvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs1fvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs1hvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLhalfNV -> m ()
glVertexAttribs1hvNV index n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs1hvNV" [LogV'GLuint index, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs1hvNV (coerce index) n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs1hvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs1svNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLshort -> m ()
glVertexAttribs1svNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs1svNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs1svNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs1svNV" (LogV'Void)
#endif
    return _result

glVertexAttribs2dvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glVertexAttribs2dvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs2dvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs2dvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs2dvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs2fvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glVertexAttribs2fvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs2fvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs2fvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs2fvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs2hvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLhalfNV -> m ()
glVertexAttribs2hvNV index n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs2hvNV" [LogV'GLuint index, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs2hvNV (coerce index) n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs2hvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs2svNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLshort -> m ()
glVertexAttribs2svNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs2svNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs2svNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs2svNV" (LogV'Void)
#endif
    return _result

glVertexAttribs3dvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glVertexAttribs3dvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs3dvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs3dvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs3dvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs3fvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glVertexAttribs3fvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs3fvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs3fvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs3fvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs3hvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLhalfNV -> m ()
glVertexAttribs3hvNV index n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs3hvNV" [LogV'GLuint index, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs3hvNV (coerce index) n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs3hvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs3svNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLshort -> m ()
glVertexAttribs3svNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs3svNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs3svNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs3svNV" (LogV'Void)
#endif
    return _result

glVertexAttribs4dvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLdouble -> m ()
glVertexAttribs4dvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs4dvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs4dvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs4dvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs4fvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glVertexAttribs4fvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs4fvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs4fvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs4fvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs4hvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLhalfNV -> m ()
glVertexAttribs4hvNV index n v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs4hvNV" [LogV'GLuint index, LogV'GLsizei n, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs4hvNV (coerce index) n v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs4hvNV" (LogV'Void)
#endif
    return _result

glVertexAttribs4svNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLshort -> m ()
glVertexAttribs4svNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs4svNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs4svNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs4svNV" (LogV'Void)
#endif
    return _result

glVertexAttribs4ubvNV :: MonadIO m => AttribLocation -> GL.GLsizei -> Ptr GL.GLubyte -> m ()
glVertexAttribs4ubvNV index count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexAttribs4ubvNV" [LogV'GLuint index, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexAttribs4ubvNV (coerce index) count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexAttribs4ubvNV" (LogV'Void)
#endif
    return _result

glVertexBindingDivisor :: MonadIO m => BindingIndex -> GL.GLuint -> m ()
glVertexBindingDivisor bindingindex divisor = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexBindingDivisor" [LogV'GLuint bindingindex, LogV'GLuint divisor]
#endif
    _result <- GL.glVertexBindingDivisor (coerce bindingindex) divisor
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexBindingDivisor" (LogV'Void)
#endif
    return _result

glVertexBlendARB :: MonadIO m => GL.GLint -> m ()
glVertexBlendARB count = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexBlendARB" [LogV'GLint count]
#endif
    _result <- GL.glVertexBlendARB count
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexBlendARB" (LogV'Void)
#endif
    return _result

glVertexBlendEnvfATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glVertexBlendEnvfATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexBlendEnvfATI" [LogV'GLenum pname, LogV'GLfloat param]
#endif
    _result <- GL.glVertexBlendEnvfATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexBlendEnvfATI" (LogV'Void)
#endif
    return _result

glVertexBlendEnviATI :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glVertexBlendEnviATI pname param = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexBlendEnviATI" [LogV'GLenum pname, LogV'GLint param]
#endif
    _result <- GL.glVertexBlendEnviATI pname param
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexBlendEnviATI" (LogV'Void)
#endif
    return _result

glVertexFormatNV :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> m ()
glVertexFormatNV size type' stride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexFormatNV" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride]
#endif
    _result <- GL.glVertexFormatNV size type' stride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexFormatNV" (LogV'Void)
#endif
    return _result

glVertexP2ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glVertexP2ui type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP2ui" [LogV'GLenum type', LogV'GLuint value]
#endif
    _result <- GL.glVertexP2ui type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP2ui" (LogV'Void)
#endif
    return _result

glVertexP2uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glVertexP2uiv type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP2uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glVertexP2uiv type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP2uiv" (LogV'Void)
#endif
    return _result

glVertexP3ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glVertexP3ui type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP3ui" [LogV'GLenum type', LogV'GLuint value]
#endif
    _result <- GL.glVertexP3ui type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP3ui" (LogV'Void)
#endif
    return _result

glVertexP3uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glVertexP3uiv type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP3uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glVertexP3uiv type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP3uiv" (LogV'Void)
#endif
    return _result

glVertexP4ui :: MonadIO m => GL.GLenum -> GL.GLuint -> m ()
glVertexP4ui type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP4ui" [LogV'GLenum type', LogV'GLuint value]
#endif
    _result <- GL.glVertexP4ui type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP4ui" (LogV'Void)
#endif
    return _result

glVertexP4uiv :: MonadIO m => GL.GLenum -> Ptr GL.GLuint -> m ()
glVertexP4uiv type' value = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexP4uiv" [LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glVertexP4uiv type' value
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexP4uiv" (LogV'Void)
#endif
    return _result

glVertexPointerEXT :: MonadIO m => GL.GLint -> VertexPointerType -> GL.GLsizei -> GL.GLsizei -> Ptr () -> m ()
glVertexPointerEXT size type' stride count pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexPointerEXT" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glVertexPointerEXT size (coerce type') stride count pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexPointerEXT" (LogV'Void)
#endif
    return _result

glVertexPointerListIBM :: MonadIO m => GL.GLint -> VertexPointerType -> GL.GLint -> Ptr (Ptr ()) -> GL.GLint -> m ()
glVertexPointerListIBM size type' stride pointer ptrstride = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexPointerListIBM" [LogV'GLint size, LogV'GLenum type', LogV'GLint stride, LogV'Ptr, LogV'GLint ptrstride]
#endif
    _result <- GL.glVertexPointerListIBM size (coerce type') stride pointer ptrstride
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexPointerListIBM" (LogV'Void)
#endif
    return _result

glVertexPointervINTEL :: MonadIO m => GL.GLint -> VertexPointerType -> Ptr (Ptr ()) -> m ()
glVertexPointervINTEL size type' pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexPointervINTEL" [LogV'GLint size, LogV'GLenum type', LogV'Ptr]
#endif
    _result <- GL.glVertexPointervINTEL size (coerce type') pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexPointervINTEL" (LogV'Void)
#endif
    return _result

glVertexStream1dATI :: MonadIO m => GL.GLenum -> GL.GLdouble -> m ()
glVertexStream1dATI stream x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1dATI" [LogV'GLenum stream, LogV'GLdouble x]
#endif
    _result <- GL.glVertexStream1dATI stream x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1dATI" (LogV'Void)
#endif
    return _result

glVertexStream1dvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glVertexStream1dvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1dvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream1dvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1dvATI" (LogV'Void)
#endif
    return _result

glVertexStream1fATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> m ()
glVertexStream1fATI stream x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1fATI" [LogV'GLenum stream, LogV'GLfloat x]
#endif
    _result <- GL.glVertexStream1fATI stream x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1fATI" (LogV'Void)
#endif
    return _result

glVertexStream1fvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glVertexStream1fvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1fvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream1fvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1fvATI" (LogV'Void)
#endif
    return _result

glVertexStream1iATI :: MonadIO m => GL.GLenum -> GL.GLint -> m ()
glVertexStream1iATI stream x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1iATI" [LogV'GLenum stream, LogV'GLint x]
#endif
    _result <- GL.glVertexStream1iATI stream x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1iATI" (LogV'Void)
#endif
    return _result

glVertexStream1ivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glVertexStream1ivATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1ivATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream1ivATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1ivATI" (LogV'Void)
#endif
    return _result

glVertexStream1sATI :: MonadIO m => GL.GLenum -> GL.GLshort -> m ()
glVertexStream1sATI stream x = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1sATI" [LogV'GLenum stream, LogV'GLshort x]
#endif
    _result <- GL.glVertexStream1sATI stream x
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1sATI" (LogV'Void)
#endif
    return _result

glVertexStream1svATI :: MonadIO m => GL.GLenum -> Ptr GL.GLshort -> m ()
glVertexStream1svATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream1svATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream1svATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream1svATI" (LogV'Void)
#endif
    return _result

glVertexStream2dATI :: MonadIO m => GL.GLenum -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexStream2dATI stream x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2dATI" [LogV'GLenum stream, LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glVertexStream2dATI stream x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2dATI" (LogV'Void)
#endif
    return _result

glVertexStream2dvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glVertexStream2dvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2dvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream2dvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2dvATI" (LogV'Void)
#endif
    return _result

glVertexStream2fATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexStream2fATI stream x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2fATI" [LogV'GLenum stream, LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glVertexStream2fATI stream x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2fATI" (LogV'Void)
#endif
    return _result

glVertexStream2fvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glVertexStream2fvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2fvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream2fvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2fvATI" (LogV'Void)
#endif
    return _result

glVertexStream2iATI :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLint -> m ()
glVertexStream2iATI stream x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2iATI" [LogV'GLenum stream, LogV'GLint x, LogV'GLint y]
#endif
    _result <- GL.glVertexStream2iATI stream x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2iATI" (LogV'Void)
#endif
    return _result

glVertexStream2ivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glVertexStream2ivATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2ivATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream2ivATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2ivATI" (LogV'Void)
#endif
    return _result

glVertexStream2sATI :: MonadIO m => GL.GLenum -> GL.GLshort -> GL.GLshort -> m ()
glVertexStream2sATI stream x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2sATI" [LogV'GLenum stream, LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glVertexStream2sATI stream x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2sATI" (LogV'Void)
#endif
    return _result

glVertexStream2svATI :: MonadIO m => GL.GLenum -> Ptr GL.GLshort -> m ()
glVertexStream2svATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream2svATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream2svATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream2svATI" (LogV'Void)
#endif
    return _result

glVertexStream3dATI :: MonadIO m => GL.GLenum -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexStream3dATI stream x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3dATI" [LogV'GLenum stream, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glVertexStream3dATI stream x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3dATI" (LogV'Void)
#endif
    return _result

glVertexStream3dvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glVertexStream3dvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3dvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream3dvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3dvATI" (LogV'Void)
#endif
    return _result

glVertexStream3fATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexStream3fATI stream x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3fATI" [LogV'GLenum stream, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glVertexStream3fATI stream x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3fATI" (LogV'Void)
#endif
    return _result

glVertexStream3fvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glVertexStream3fvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3fvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream3fvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3fvATI" (LogV'Void)
#endif
    return _result

glVertexStream3iATI :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexStream3iATI stream x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3iATI" [LogV'GLenum stream, LogV'GLint x, LogV'GLint y, LogV'GLint z]
#endif
    _result <- GL.glVertexStream3iATI stream x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3iATI" (LogV'Void)
#endif
    return _result

glVertexStream3ivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glVertexStream3ivATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3ivATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream3ivATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3ivATI" (LogV'Void)
#endif
    return _result

glVertexStream3sATI :: MonadIO m => GL.GLenum -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexStream3sATI stream x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3sATI" [LogV'GLenum stream, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glVertexStream3sATI stream x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3sATI" (LogV'Void)
#endif
    return _result

glVertexStream3svATI :: MonadIO m => GL.GLenum -> Ptr GL.GLshort -> m ()
glVertexStream3svATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream3svATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream3svATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream3svATI" (LogV'Void)
#endif
    return _result

glVertexStream4dATI :: MonadIO m => GL.GLenum -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glVertexStream4dATI stream x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4dATI" [LogV'GLenum stream, LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glVertexStream4dATI stream x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4dATI" (LogV'Void)
#endif
    return _result

glVertexStream4dvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLdouble -> m ()
glVertexStream4dvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4dvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream4dvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4dvATI" (LogV'Void)
#endif
    return _result

glVertexStream4fATI :: MonadIO m => GL.GLenum -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glVertexStream4fATI stream x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4fATI" [LogV'GLenum stream, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glVertexStream4fATI stream x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4fATI" (LogV'Void)
#endif
    return _result

glVertexStream4fvATI :: MonadIO m => GL.GLenum -> Ptr GL.GLfloat -> m ()
glVertexStream4fvATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4fvATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream4fvATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4fvATI" (LogV'Void)
#endif
    return _result

glVertexStream4iATI :: MonadIO m => GL.GLenum -> GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glVertexStream4iATI stream x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4iATI" [LogV'GLenum stream, LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glVertexStream4iATI stream x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4iATI" (LogV'Void)
#endif
    return _result

glVertexStream4ivATI :: MonadIO m => GL.GLenum -> Ptr GL.GLint -> m ()
glVertexStream4ivATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4ivATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream4ivATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4ivATI" (LogV'Void)
#endif
    return _result

glVertexStream4sATI :: MonadIO m => GL.GLenum -> GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glVertexStream4sATI stream x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4sATI" [LogV'GLenum stream, LogV'GLshort x, LogV'GLshort y, LogV'GLshort z, LogV'GLshort w]
#endif
    _result <- GL.glVertexStream4sATI stream x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4sATI" (LogV'Void)
#endif
    return _result

glVertexStream4svATI :: MonadIO m => GL.GLenum -> Ptr GL.GLshort -> m ()
glVertexStream4svATI stream coords = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexStream4svATI" [LogV'GLenum stream, LogV'Ptr]
#endif
    _result <- GL.glVertexStream4svATI stream coords
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexStream4svATI" (LogV'Void)
#endif
    return _result

glVertexWeightPointerEXT :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glVertexWeightPointerEXT size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexWeightPointerEXT" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glVertexWeightPointerEXT size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexWeightPointerEXT" (LogV'Void)
#endif
    return _result

glVertexWeightfEXT :: MonadIO m => GL.GLfloat -> m ()
glVertexWeightfEXT weight = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexWeightfEXT" [LogV'GLfloat weight]
#endif
    _result <- GL.glVertexWeightfEXT weight
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexWeightfEXT" (LogV'Void)
#endif
    return _result

glVertexWeightfvEXT :: MonadIO m => Ptr GL.GLfloat -> m ()
glVertexWeightfvEXT weight = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexWeightfvEXT" [LogV'Ptr]
#endif
    _result <- GL.glVertexWeightfvEXT weight
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexWeightfvEXT" (LogV'Void)
#endif
    return _result

glVertexWeighthNV :: MonadIO m => GL.GLhalfNV -> m ()
glVertexWeighthNV weight = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexWeighthNV" [LogV'GLhalfNV weight]
#endif
    _result <- GL.glVertexWeighthNV weight
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexWeighthNV" (LogV'Void)
#endif
    return _result

glVertexWeighthvNV :: MonadIO m => Ptr GL.GLhalfNV -> m ()
glVertexWeighthvNV weight = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVertexWeighthvNV" [LogV'Ptr]
#endif
    _result <- GL.glVertexWeighthvNV weight
#ifdef GLW_DEBUG
    logGLCommandEnd "glVertexWeighthvNV" (LogV'Void)
#endif
    return _result

glVideoCaptureNV :: MonadIO m => GL.GLuint -> Ptr GL.GLuint -> Ptr GL.GLuint64EXT -> m GL.GLenum
glVideoCaptureNV video_capture_slot sequence_num capture_time = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVideoCaptureNV" [LogV'GLuint video_capture_slot, LogV'Ptr, LogV'Ptr]
#endif
    _result <- GL.glVideoCaptureNV video_capture_slot sequence_num capture_time
#ifdef GLW_DEBUG
    logGLCommandEnd "glVideoCaptureNV" (LogV'GLenum _result)
#endif
    return _result

glVideoCaptureStreamParameterdvNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLdouble -> m ()
glVideoCaptureStreamParameterdvNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVideoCaptureStreamParameterdvNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glVideoCaptureStreamParameterdvNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glVideoCaptureStreamParameterdvNV" (LogV'Void)
#endif
    return _result

glVideoCaptureStreamParameterfvNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLfloat -> m ()
glVideoCaptureStreamParameterfvNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVideoCaptureStreamParameterfvNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glVideoCaptureStreamParameterfvNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glVideoCaptureStreamParameterfvNV" (LogV'Void)
#endif
    return _result

glVideoCaptureStreamParameterivNV :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> Ptr GL.GLint -> m ()
glVideoCaptureStreamParameterivNV video_capture_slot stream pname params = do
#ifdef GLW_DEBUG
    logGLCommandStart "glVideoCaptureStreamParameterivNV" [LogV'GLuint video_capture_slot, LogV'GLuint stream, LogV'GLenum pname, LogV'Ptr]
#endif
    _result <- GL.glVideoCaptureStreamParameterivNV video_capture_slot stream pname params
#ifdef GLW_DEBUG
    logGLCommandEnd "glVideoCaptureStreamParameterivNV" (LogV'Void)
#endif
    return _result

glViewport :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLsizei -> GL.GLsizei -> m ()
glViewport x y width height = do
#ifdef GLW_DEBUG
    logGLCommandStart "glViewport" [LogV'GLint x, LogV'GLint y, LogV'GLsizei width, LogV'GLsizei height]
#endif
    _result <- GL.glViewport x y width height
#ifdef GLW_DEBUG
    logGLCommandEnd "glViewport" (LogV'Void)
#endif
    return _result

glViewportArrayv :: MonadIO m => GL.GLuint -> GL.GLsizei -> Ptr GL.GLfloat -> m ()
glViewportArrayv first count v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glViewportArrayv" [LogV'GLuint first, LogV'GLsizei count, LogV'Ptr]
#endif
    _result <- GL.glViewportArrayv first count v
#ifdef GLW_DEBUG
    logGLCommandEnd "glViewportArrayv" (LogV'Void)
#endif
    return _result

glViewportIndexedf :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glViewportIndexedf index x y w h = do
#ifdef GLW_DEBUG
    logGLCommandStart "glViewportIndexedf" [LogV'GLuint index, LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat w, LogV'GLfloat h]
#endif
    _result <- GL.glViewportIndexedf index x y w h
#ifdef GLW_DEBUG
    logGLCommandEnd "glViewportIndexedf" (LogV'Void)
#endif
    return _result

glViewportIndexedfv :: MonadIO m => GL.GLuint -> Ptr GL.GLfloat -> m ()
glViewportIndexedfv index v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glViewportIndexedfv" [LogV'GLuint index, LogV'Ptr]
#endif
    _result <- GL.glViewportIndexedfv index v
#ifdef GLW_DEBUG
    logGLCommandEnd "glViewportIndexedfv" (LogV'Void)
#endif
    return _result

glViewportPositionWScaleNV :: MonadIO m => GL.GLuint -> GL.GLfloat -> GL.GLfloat -> m ()
glViewportPositionWScaleNV index xcoeff ycoeff = do
#ifdef GLW_DEBUG
    logGLCommandStart "glViewportPositionWScaleNV" [LogV'GLuint index, LogV'GLfloat xcoeff, LogV'GLfloat ycoeff]
#endif
    _result <- GL.glViewportPositionWScaleNV index xcoeff ycoeff
#ifdef GLW_DEBUG
    logGLCommandEnd "glViewportPositionWScaleNV" (LogV'Void)
#endif
    return _result

glWaitSync :: MonadIO m => GL.GLsync -> GL.GLbitfield -> GL.GLuint64 -> m ()
glWaitSync sync flags timeout = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWaitSync" [LogV'GLsync sync, LogV'GLbitfield flags, LogV'GLuint64 timeout]
#endif
    _result <- GL.glWaitSync sync flags timeout
#ifdef GLW_DEBUG
    logGLCommandEnd "glWaitSync" (LogV'Void)
#endif
    return _result

glWeightPointerARB :: MonadIO m => GL.GLint -> GL.GLenum -> GL.GLsizei -> Ptr () -> m ()
glWeightPointerARB size type' stride pointer = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightPointerARB" [LogV'GLint size, LogV'GLenum type', LogV'GLsizei stride, LogV'Ptr]
#endif
    _result <- GL.glWeightPointerARB size type' stride pointer
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightPointerARB" (LogV'Void)
#endif
    return _result

glWeightbvARB :: MonadIO m => GL.GLint -> Ptr GL.GLbyte -> m ()
glWeightbvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightbvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightbvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightbvARB" (LogV'Void)
#endif
    return _result

glWeightdvARB :: MonadIO m => GL.GLint -> Ptr GL.GLdouble -> m ()
glWeightdvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightdvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightdvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightdvARB" (LogV'Void)
#endif
    return _result

glWeightfvARB :: MonadIO m => GL.GLint -> Ptr GL.GLfloat -> m ()
glWeightfvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightfvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightfvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightfvARB" (LogV'Void)
#endif
    return _result

glWeightivARB :: MonadIO m => GL.GLint -> Ptr GL.GLint -> m ()
glWeightivARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightivARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightivARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightivARB" (LogV'Void)
#endif
    return _result

glWeightsvARB :: MonadIO m => GL.GLint -> Ptr GL.GLshort -> m ()
glWeightsvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightsvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightsvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightsvARB" (LogV'Void)
#endif
    return _result

glWeightubvARB :: MonadIO m => GL.GLint -> Ptr GL.GLubyte -> m ()
glWeightubvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightubvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightubvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightubvARB" (LogV'Void)
#endif
    return _result

glWeightuivARB :: MonadIO m => GL.GLint -> Ptr GL.GLuint -> m ()
glWeightuivARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightuivARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightuivARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightuivARB" (LogV'Void)
#endif
    return _result

glWeightusvARB :: MonadIO m => GL.GLint -> Ptr GL.GLushort -> m ()
glWeightusvARB size weights = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWeightusvARB" [LogV'GLint size, LogV'Ptr]
#endif
    _result <- GL.glWeightusvARB size weights
#ifdef GLW_DEBUG
    logGLCommandEnd "glWeightusvARB" (LogV'Void)
#endif
    return _result

glWindowPos2dARB :: MonadIO m => GL.GLdouble -> GL.GLdouble -> m ()
glWindowPos2dARB x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2dARB" [LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glWindowPos2dARB x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2dARB" (LogV'Void)
#endif
    return _result

glWindowPos2dMESA :: MonadIO m => GL.GLdouble -> GL.GLdouble -> m ()
glWindowPos2dMESA x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2dMESA" [LogV'GLdouble x, LogV'GLdouble y]
#endif
    _result <- GL.glWindowPos2dMESA x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2dMESA" (LogV'Void)
#endif
    return _result

glWindowPos2dvARB :: MonadIO m => Ptr GL.GLdouble -> m ()
glWindowPos2dvARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2dvARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2dvARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2dvARB" (LogV'Void)
#endif
    return _result

glWindowPos2dvMESA :: MonadIO m => Ptr GL.GLdouble -> m ()
glWindowPos2dvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2dvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2dvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2dvMESA" (LogV'Void)
#endif
    return _result

glWindowPos2fARB :: MonadIO m => GL.GLfloat -> GL.GLfloat -> m ()
glWindowPos2fARB x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2fARB" [LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glWindowPos2fARB x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2fARB" (LogV'Void)
#endif
    return _result

glWindowPos2fMESA :: MonadIO m => GL.GLfloat -> GL.GLfloat -> m ()
glWindowPos2fMESA x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2fMESA" [LogV'GLfloat x, LogV'GLfloat y]
#endif
    _result <- GL.glWindowPos2fMESA x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2fMESA" (LogV'Void)
#endif
    return _result

glWindowPos2fvARB :: MonadIO m => Ptr GL.GLfloat -> m ()
glWindowPos2fvARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2fvARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2fvARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2fvARB" (LogV'Void)
#endif
    return _result

glWindowPos2fvMESA :: MonadIO m => Ptr GL.GLfloat -> m ()
glWindowPos2fvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2fvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2fvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2fvMESA" (LogV'Void)
#endif
    return _result

glWindowPos2iARB :: MonadIO m => GL.GLint -> GL.GLint -> m ()
glWindowPos2iARB x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2iARB" [LogV'GLint x, LogV'GLint y]
#endif
    _result <- GL.glWindowPos2iARB x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2iARB" (LogV'Void)
#endif
    return _result

glWindowPos2iMESA :: MonadIO m => GL.GLint -> GL.GLint -> m ()
glWindowPos2iMESA x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2iMESA" [LogV'GLint x, LogV'GLint y]
#endif
    _result <- GL.glWindowPos2iMESA x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2iMESA" (LogV'Void)
#endif
    return _result

glWindowPos2ivARB :: MonadIO m => Ptr GL.GLint -> m ()
glWindowPos2ivARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2ivARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2ivARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2ivARB" (LogV'Void)
#endif
    return _result

glWindowPos2ivMESA :: MonadIO m => Ptr GL.GLint -> m ()
glWindowPos2ivMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2ivMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2ivMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2ivMESA" (LogV'Void)
#endif
    return _result

glWindowPos2sARB :: MonadIO m => GL.GLshort -> GL.GLshort -> m ()
glWindowPos2sARB x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2sARB" [LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glWindowPos2sARB x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2sARB" (LogV'Void)
#endif
    return _result

glWindowPos2sMESA :: MonadIO m => GL.GLshort -> GL.GLshort -> m ()
glWindowPos2sMESA x y = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2sMESA" [LogV'GLshort x, LogV'GLshort y]
#endif
    _result <- GL.glWindowPos2sMESA x y
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2sMESA" (LogV'Void)
#endif
    return _result

glWindowPos2svARB :: MonadIO m => Ptr GL.GLshort -> m ()
glWindowPos2svARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2svARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2svARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2svARB" (LogV'Void)
#endif
    return _result

glWindowPos2svMESA :: MonadIO m => Ptr GL.GLshort -> m ()
glWindowPos2svMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos2svMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos2svMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos2svMESA" (LogV'Void)
#endif
    return _result

glWindowPos3dARB :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glWindowPos3dARB x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3dARB" [LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glWindowPos3dARB x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3dARB" (LogV'Void)
#endif
    return _result

glWindowPos3dMESA :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glWindowPos3dMESA x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3dMESA" [LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z]
#endif
    _result <- GL.glWindowPos3dMESA x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3dMESA" (LogV'Void)
#endif
    return _result

glWindowPos3dvARB :: MonadIO m => Ptr GL.GLdouble -> m ()
glWindowPos3dvARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3dvARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3dvARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3dvARB" (LogV'Void)
#endif
    return _result

glWindowPos3dvMESA :: MonadIO m => Ptr GL.GLdouble -> m ()
glWindowPos3dvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3dvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3dvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3dvMESA" (LogV'Void)
#endif
    return _result

glWindowPos3fARB :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glWindowPos3fARB x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3fARB" [LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glWindowPos3fARB x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3fARB" (LogV'Void)
#endif
    return _result

glWindowPos3fMESA :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glWindowPos3fMESA x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3fMESA" [LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z]
#endif
    _result <- GL.glWindowPos3fMESA x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3fMESA" (LogV'Void)
#endif
    return _result

glWindowPos3fvARB :: MonadIO m => Ptr GL.GLfloat -> m ()
glWindowPos3fvARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3fvARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3fvARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3fvARB" (LogV'Void)
#endif
    return _result

glWindowPos3fvMESA :: MonadIO m => Ptr GL.GLfloat -> m ()
glWindowPos3fvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3fvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3fvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3fvMESA" (LogV'Void)
#endif
    return _result

glWindowPos3iARB :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> m ()
glWindowPos3iARB x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3iARB" [LogV'GLint x, LogV'GLint y, LogV'GLint z]
#endif
    _result <- GL.glWindowPos3iARB x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3iARB" (LogV'Void)
#endif
    return _result

glWindowPos3iMESA :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> m ()
glWindowPos3iMESA x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3iMESA" [LogV'GLint x, LogV'GLint y, LogV'GLint z]
#endif
    _result <- GL.glWindowPos3iMESA x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3iMESA" (LogV'Void)
#endif
    return _result

glWindowPos3ivARB :: MonadIO m => Ptr GL.GLint -> m ()
glWindowPos3ivARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3ivARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3ivARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3ivARB" (LogV'Void)
#endif
    return _result

glWindowPos3ivMESA :: MonadIO m => Ptr GL.GLint -> m ()
glWindowPos3ivMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3ivMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3ivMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3ivMESA" (LogV'Void)
#endif
    return _result

glWindowPos3sARB :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glWindowPos3sARB x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3sARB" [LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glWindowPos3sARB x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3sARB" (LogV'Void)
#endif
    return _result

glWindowPos3sMESA :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glWindowPos3sMESA x y z = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3sMESA" [LogV'GLshort x, LogV'GLshort y, LogV'GLshort z]
#endif
    _result <- GL.glWindowPos3sMESA x y z
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3sMESA" (LogV'Void)
#endif
    return _result

glWindowPos3svARB :: MonadIO m => Ptr GL.GLshort -> m ()
glWindowPos3svARB v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3svARB" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3svARB v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3svARB" (LogV'Void)
#endif
    return _result

glWindowPos3svMESA :: MonadIO m => Ptr GL.GLshort -> m ()
glWindowPos3svMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos3svMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos3svMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos3svMESA" (LogV'Void)
#endif
    return _result

glWindowPos4dMESA :: MonadIO m => GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> GL.GLdouble -> m ()
glWindowPos4dMESA x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4dMESA" [LogV'GLdouble x, LogV'GLdouble y, LogV'GLdouble z, LogV'GLdouble w]
#endif
    _result <- GL.glWindowPos4dMESA x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4dMESA" (LogV'Void)
#endif
    return _result

glWindowPos4dvMESA :: MonadIO m => Ptr GL.GLdouble -> m ()
glWindowPos4dvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4dvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos4dvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4dvMESA" (LogV'Void)
#endif
    return _result

glWindowPos4fMESA :: MonadIO m => GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> GL.GLfloat -> m ()
glWindowPos4fMESA x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4fMESA" [LogV'GLfloat x, LogV'GLfloat y, LogV'GLfloat z, LogV'GLfloat w]
#endif
    _result <- GL.glWindowPos4fMESA x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4fMESA" (LogV'Void)
#endif
    return _result

glWindowPos4fvMESA :: MonadIO m => Ptr GL.GLfloat -> m ()
glWindowPos4fvMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4fvMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos4fvMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4fvMESA" (LogV'Void)
#endif
    return _result

glWindowPos4iMESA :: MonadIO m => GL.GLint -> GL.GLint -> GL.GLint -> GL.GLint -> m ()
glWindowPos4iMESA x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4iMESA" [LogV'GLint x, LogV'GLint y, LogV'GLint z, LogV'GLint w]
#endif
    _result <- GL.glWindowPos4iMESA x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4iMESA" (LogV'Void)
#endif
    return _result

glWindowPos4ivMESA :: MonadIO m => Ptr GL.GLint -> m ()
glWindowPos4ivMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4ivMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos4ivMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4ivMESA" (LogV'Void)
#endif
    return _result

glWindowPos4sMESA :: MonadIO m => GL.GLshort -> GL.GLshort -> GL.GLshort -> GL.GLshort -> m ()
glWindowPos4sMESA x y z w = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4sMESA" [LogV'GLshort x, LogV'GLshort y, LogV'GLshort z, LogV'GLshort w]
#endif
    _result <- GL.glWindowPos4sMESA x y z w
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4sMESA" (LogV'Void)
#endif
    return _result

glWindowPos4svMESA :: MonadIO m => Ptr GL.GLshort -> m ()
glWindowPos4svMESA v = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWindowPos4svMESA" [LogV'Ptr]
#endif
    _result <- GL.glWindowPos4svMESA v
#ifdef GLW_DEBUG
    logGLCommandEnd "glWindowPos4svMESA" (LogV'Void)
#endif
    return _result

glWriteMaskEXT :: MonadIO m => GL.GLuint -> GL.GLuint -> GL.GLenum -> GL.GLenum -> GL.GLenum -> GL.GLenum -> m ()
glWriteMaskEXT res in' outX outY outZ outW = do
#ifdef GLW_DEBUG
    logGLCommandStart "glWriteMaskEXT" [LogV'GLuint res, LogV'GLuint in', LogV'GLenum outX, LogV'GLenum outY, LogV'GLenum outZ, LogV'GLenum outW]
#endif
    _result <- GL.glWriteMaskEXT res in' outX outY outZ outW
#ifdef GLW_DEBUG
    logGLCommandEnd "glWriteMaskEXT" (LogV'Void)
#endif
    return _result
